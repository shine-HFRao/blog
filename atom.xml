<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HFRao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-14T08:12:42.734Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HFRao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有关原生函数封装的库</title>
    <link href="http://yoursite.com/2018/10/14/tools/"/>
    <id>http://yoursite.com/2018/10/14/tools/</id>
    <published>2018-10-14T07:47:27.499Z</published>
    <updated>2018-10-14T08:12:42.734Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅度克隆"><a href="#浅度克隆" class="headerlink" title="浅度克隆"></a><strong>浅度克隆</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name : &apos;abc&apos;,</span><br><span class="line">    age : 123,</span><br><span class="line">    sex : &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;&#125;</span><br><span class="line"> function clone(origin,target)&#123;</span><br><span class="line">    var target = target || &#123;&#125;;</span><br><span class="line">    for(var propo in obj)&#123;</span><br><span class="line">        target[propo] = origin[propo];</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a><strong>深度克隆</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(target, origin) &#123;</span><br><span class="line">    var target = target || &#123;&#125;;</span><br><span class="line">    var arrStr = &apos;[object Array]&apos;;</span><br><span class="line">    var toStr = Object.prototype.toString;</span><br><span class="line">    if (origin != null) &#123;            //注意 undefined == null 返回的是true, 此处排除这两个的干扰 ，因为们俩都不是对象，也没有包装类</span><br><span class="line">        for (var prop in origin) &#123;</span><br><span class="line">            var ori = origin[prop];</span><br><span class="line">            var tar = target[prop];</span><br><span class="line">            if (ori !== &apos;null&apos; &amp;&amp; typeof(ori) == &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">                console.log(toStr.call(ori) == arrStr);</span><br><span class="line">                tar = (toStr.call(ori) == arrStr) ? [] : &#123;&#125;;</span><br><span class="line">                target[prop] = deepClone(tar, ori)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                target[prop] = ori;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义数组push-模拟Array原型链上的push方法"><a href="#自定义数组push-模拟Array原型链上的push方法" class="headerlink" title="自定义数组push,模拟Array原型链上的push方法 "></a><strong>自定义数组push,模拟Array原型链上的push方法 </strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">Array.prototype.push = function () &#123;</span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i ++) &#123;</span><br><span class="line">        this[this.length] = arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return this.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自己设置的type返回值类型"><a href="#自己设置的type返回值类型" class="headerlink" title="自己设置的type返回值类型"></a><strong>自己设置的type返回值类型</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function type(target) &#123;</span><br><span class="line">    var ret = typeof (target);</span><br><span class="line">    var template = &#123;</span><br><span class="line">        &apos;[object Array]&apos;: &apos;array&apos;,</span><br><span class="line">        &apos;[object Object]&apos;: &apos;object&apos;,</span><br><span class="line">        &apos;[object Number]&apos;: &apos;number-object&apos;,</span><br><span class="line">        &apos;[object Boolean]&apos;: &apos;boolean-object&apos;,</span><br><span class="line">        &apos;[object String]&apos;: &apos;string-object&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target === null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;else if(ret == &apos;object&apos;) &#123;</span><br><span class="line">        var str = Object.prototype.toString.call(target);</span><br><span class="line">        return template[str];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母"><a href="#一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母" class="headerlink" title="一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母"></a><strong>一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;dsXazhdkasxhdlkasjzdlksajdlksajlkdaXs&apos;;</span><br><span class="line">function singleStr(str) &#123;</span><br><span class="line">    var temp = &#123;&#125;,</span><br><span class="line">        oldArr = str.split(&apos;&apos;),</span><br><span class="line">        newArr = [],</span><br><span class="line">        newStr = &apos;&apos;,</span><br><span class="line">        temp = oldArr.unique();</span><br><span class="line">    for (var prop in temp) &#123;</span><br><span class="line">        if (temp[prop] == 1) &#123;</span><br><span class="line">            newArr.push(prop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newStr = newArr[0];</span><br><span class="line">    return newStr;</span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">    var temp = &#123;&#125;,</span><br><span class="line">        len = this.length;</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (!temp[this[i]]) &#123;</span><br><span class="line">            temp[this[i]] = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[this[i]] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母-别人编写"><a href="#一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母-别人编写" class="headerlink" title="一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母(别人编写)"></a><strong>一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母(别人编写)</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;mdsaahjzsjkjkjkjkvlkllopoopopopop&apos; ;</span><br><span class="line">console.log(firstSingle(str));</span><br><span class="line">function firstSingle(str)&#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    for(var i = 0; i &lt; str.length; i ++)&#123;</span><br><span class="line">        if(!obj[str[i]])&#123;</span><br><span class="line">            obj[str[i]] = true;               </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            str = deleteLetter(str,str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deleteLetter(str,char) &#123;</span><br><span class="line">    var reg = new RegExp(char, &apos;g&apos;);</span><br><span class="line">    for(var i = 0; i &lt; str.length;)&#123;</span><br><span class="line">        if(str[i] === char)&#123;</span><br><span class="line">            str = str.replace(reg, &apos;&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a><strong>圣杯模式</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function inherit(Target,Origin) &#123;</span><br><span class="line">    function F() &#123;&#125;;</span><br><span class="line">    F.prototype = Origin.prototype;</span><br><span class="line">    Target.prototype = new F();</span><br><span class="line">    Target.prototype.constuctor = Target;</span><br><span class="line">    Target.prototype.uber = Origin.prototype; //就是来知道真正继承的是谁</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.lastName = &apos;xiao&apos;;</span><br><span class="line">function Father() &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">function Son() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">inhert(Son,Father);</span><br><span class="line">var father = new Father();</span><br><span class="line">var son = new Son();</span><br></pre></td></tr></table></figure><h3 id="雅虎（圣杯模式）"><a href="#雅虎（圣杯模式）" class="headerlink" title="雅虎（圣杯模式）"></a><strong>雅虎（圣杯模式）</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (function()&#123;</span><br><span class="line">    var F = function () &#123;&#125;;//私有化变量</span><br><span class="line">    return function (Target,Origin) &#123;</span><br><span class="line">        F.prototype = Origin.prototype;</span><br><span class="line">        Target.prototype = new F();</span><br><span class="line">        Target.prototype.constuctor = Target;</span><br><span class="line">        Target.prototype.uber = Origin.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="封装兼容性方法，求滚动条滚动距离getScrollOffset"><a href="#封装兼容性方法，求滚动条滚动距离getScrollOffset" class="headerlink" title="封装兼容性方法，求滚动条滚动距离getScrollOffset()"></a><strong>封装兼容性方法，求滚动条滚动距离getScrollOffset()</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getScrollOffset() &#123;</span><br><span class="line">    if(window.pageXOffset)&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x : window.pageXOffset,</span><br><span class="line">            y : window.pageYOffset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x : document.body.scrollLeft + document.documentElement.scrollLeft,</span><br><span class="line">            y : document.body.scrollTop + document.documentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装兼容性方法，返回浏览器视口尺寸getViewportOffset"><a href="#封装兼容性方法，返回浏览器视口尺寸getViewportOffset" class="headerlink" title="封装兼容性方法，返回浏览器视口尺寸getViewportOffset() "></a><strong>封装兼容性方法，返回浏览器视口尺寸getViewportOffset() </strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getViewportOffset() &#123;</span><br><span class="line">    if(window.innerWidth)&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            w : window.innerWidth,</span><br><span class="line">            h : window.innerHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if(document.compatMode === &apos;BackCompat&apos;)&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: document.body.clientWidth,</span><br><span class="line">                h: document.body.clientHeight </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                w: document.documentElement.clientWidth,</span><br><span class="line">                h: document.documentElement.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装兼容方法getStyle-elem-prop"><a href="#封装兼容方法getStyle-elem-prop" class="headerlink" title="封装兼容方法getStyle(elem,prop)"></a><strong>封装兼容方法getStyle(elem,prop)</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getStyle(elem,prop) &#123;</span><br><span class="line">    if(window.getComputedStyle)&#123;</span><br><span class="line">        return window.getComputedStyle(elem,null)[prop];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return elem.currentStyle[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装兼容性的addEvent-elem-type-handle-方法"><a href="#封装兼容性的addEvent-elem-type-handle-方法" class="headerlink" title="封装兼容性的addEvent(elem,type,handle)方法"></a><strong>封装兼容性的addEvent(elem,type,handle)方法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(elem,type,handle)&#123;</span><br><span class="line">    if(elem.addEventListener)&#123;</span><br><span class="line">        elem.addEventListener(type,handle,false);</span><br><span class="line">    &#125;else if(elem.attachEvent)&#123;</span><br><span class="line">        elem.attachEvent(&apos;on&apos; + type,function()&#123;</span><br><span class="line">            handle.call(elem);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        elem[&apos;on&apos;+ type] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装兼容性的removeEvent-elem-type-handle-方法"><a href="#封装兼容性的removeEvent-elem-type-handle-方法" class="headerlink" title="封装兼容性的removeEvent(elem,type,handle)方法"></a><strong>封装兼容性的removeEvent(elem,type,handle)方法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function removeEvent(elem, type, handle) &#123;</span><br><span class="line">    if (elem.removeEventListener) &#123;</span><br><span class="line">        elem.removeEventListener(type, handle, false);</span><br><span class="line">    &#125; else if (elem.detachEvent) &#123;</span><br><span class="line">        elem.detachEvent(&apos;on&apos; + type, function () &#123;</span><br><span class="line">            handle.call(elem);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        elem[&apos;on&apos; + type] = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装取消冒泡的函数stopBubble-event"><a href="#封装取消冒泡的函数stopBubble-event" class="headerlink" title="封装取消冒泡的函数stopBubble(event)"></a><strong>封装取消冒泡的函数stopBubble(event)</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function stopBubble(event) &#123;</span><br><span class="line">    if(event.stopPropagation)&#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        event.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装阻止默认事件的函数cancelHandle"><a href="#封装阻止默认事件的函数cancelHandle" class="headerlink" title="封装阻止默认事件的函数cancelHandle()"></a><strong>封装阻止默认事件的函数cancelHandle()</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function cancelHandle(event) &#123;</span><br><span class="line">    if(event.preventDefault)&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        event.returnValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将目标节点内部的节点顺序逆序。eg-—-gt"><a href="#将目标节点内部的节点顺序逆序。eg-—-gt" class="headerlink" title="将目标节点内部的节点顺序逆序。eg:   —&gt;  "></a><strong>将目标节点内部的节点顺序逆序。eg: <div><p></p><a></a></div>  —&gt;  <div><a></a><p></p></div></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.reverseElement = function () &#123;</span><br><span class="line">    var len = this.childNodes.length,</span><br><span class="line">        child,</span><br><span class="line">        first = this.firstChild;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        child = this.lastChild;</span><br><span class="line">        this.insertBefore(child, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装remove-函数，使得child-remove-可以销毁自身。"><a href="#封装remove-函数，使得child-remove-可以销毁自身。" class="headerlink" title="封装remove()函数，使得child.remove()可以销毁自身。"></a><strong>封装remove()函数，使得child.remove()可以销毁自身。</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.remove = function () &#123;</span><br><span class="line">    var parent = this.parentNode;</span><br><span class="line">    parent.removeChild(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装函数InsertAfter-功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。"><a href="#封装函数InsertAfter-功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。" class="headerlink" title="封装函数InsertAfter();功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。"></a><strong>封装函数InsertAfter();功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Element.protoType.insertAfter = function (targetNode, afterNode) &#123;</span><br><span class="line">    var nextSib = afterNode.nextElementSibling;</span><br><span class="line">    if (this.children.length &lt;= 1 || !nextSib) &#123;</span><br><span class="line">        this.appendChild(targetNode);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.insertBefore(targetNode, nextSibling);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲移动运动"><a href="#缓冲移动运动" class="headerlink" title="缓冲移动运动"></a><strong>缓冲移动运动</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function move(obj, target) &#123;</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    var speed;</span><br><span class="line">    timer = setInterval(function () &#123;</span><br><span class="line">        speed = (target - obj.offsetLeft) / 7;</span><br><span class="line">        speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);</span><br><span class="line">        if (obj.offsetLeft === target) &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj.style.left = obj.offsetLeft + speed + &apos;px&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明度缓存"><a href="#透明度缓存" class="headerlink" title="透明度缓存"></a><strong>透明度缓存</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function move(obj, target) &#123;</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    var speed,opa;</span><br><span class="line">    timer = setInterval(function () &#123;</span><br><span class="line">        opa = parseFloat(getstyle(obj, false)[prop]) * 100;</span><br><span class="line">        speed = (target - opa) / 7;</span><br><span class="line">        speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);</span><br><span class="line">        if (target === opa) &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            obj.style.opacity = (speed + opa) / 100;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="foreach源码"><a href="#foreach源码" class="headerlink" title="foreach源码"></a><strong>foreach源码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myForEach = function (func, context) &#123;</span><br><span class="line">     var len = this.length;</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        func.call(context, this[i], i, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter源码"><a href="#filter源码" class="headerlink" title="filter源码"></a><strong>filter源码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myFilter = function (func, context) &#123;</span><br><span class="line">     var newArr = [],</span><br><span class="line">         len = his.length;</span><br><span class="line">     for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">         func.call(context, this[i], i, this) ? newArr.push(this[i]) : &apos;&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">     return newArr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="map源码"><a href="#map源码" class="headerlink" title="map源码"></a><strong>map源码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myMap = function (func, context) &#123;</span><br><span class="line">    var newArr = [],</span><br><span class="line">        len = this.length;</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        newArr.push(func.call(context, this[i], i, this));</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduce源码-跟原数组的reduce不太一样"><a href="#reduce源码-跟原数组的reduce不太一样" class="headerlink" title="reduce源码(跟原数组的reduce不太一样)"></a><strong>reduce源码(跟原数组的reduce不太一样)</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce = function (func, orgin) &#123;</span><br><span class="line">    var previous = orgin,</span><br><span class="line">        i = 0,</span><br><span class="line">        len = this.length;</span><br><span class="line">    if (orgin === undefined) &#123;</span><br><span class="line">        orgin = this[0];</span><br><span class="line">        i = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i; i &lt; len; i++) &#123;</span><br><span class="line">        previous = func(previous, this[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下面这个跟原数组的reduce不太一样"><a href="#下面这个跟原数组的reduce不太一样" class="headerlink" title="下面这个跟原数组的reduce不太一样"></a><strong>下面这个跟原数组的reduce不太一样</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce = function (func, initialValue, context) &#123;</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        initialValue = func.call(context, initialValue, this[i], i, this);</span><br><span class="line">    &#125;</span><br><span class="line">    return initialValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="some源码"><a href="#some源码" class="headerlink" title="some源码"></a><strong>some源码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.mySome = function (func, context) &#123;</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        if (func.call(context, this[i], i, this)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="every源码"><a href="#every源码" class="headerlink" title="every源码"></a><strong>every源码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myEvery = function (func, context) &#123;</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        if (!func.call(context, this[i], i, this)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a><strong>防抖</strong></h3><p>运动场景：比如 oInp.oninout = debounce(ajax, 2000);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debounce(handle, delay)&#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        var _self = this,</span><br><span class="line">            _arg = arguments;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(function ()&#123;</span><br><span class="line">            handle.apply(_self, _arg)</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a><strong>节流</strong></h3><p>运用场景： 窗口调整，页面滚动，抢购疯狂点击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function throttle(handle, wait)&#123;</span><br><span class="line">    var lastTime = 0;</span><br><span class="line">    var nowTime;</span><br><span class="line">    return function (e)&#123;</span><br><span class="line">        nowTime = new Date().getTime();</span><br><span class="line">        if(nowTime - lastTime &gt; wait)&#123;</span><br><span class="line">            handle.apply(this,arguments);</span><br><span class="line">            lastTime = nowTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind-的源码"><a href="#bind-的源码" class="headerlink" title="bind 的源码"></a><strong>bind 的源码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.newBind = function (target) &#123;</span><br><span class="line">    target = target || window;</span><br><span class="line">    var self = this;</span><br><span class="line">    var arg = [].slice.call(arguments, 1);</span><br><span class="line">    var Temp = function () &#123; &#125;;</span><br><span class="line">    var F = function () &#123;</span><br><span class="line">        var _arg = [].slice.call(arguments, 0);</span><br><span class="line">        return self.apply(this instanceof Temp ? this : target, arg.concat(_arg));</span><br><span class="line">    &#125;</span><br><span class="line">    Temp.prototype = this.prototype;</span><br><span class="line">    F.prototype = new Temp(); //将F函数的的原型跟调用newBind 函数的原型一样（就是将函数F变得跟调用newBind 的函数一样）</span><br><span class="line"></span><br><span class="line">    return F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call的原理实现"><a href="#call的原理实现" class="headerlink" title="call的原理实现"></a><strong>call的原理实现</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.newCall = function () &#123;</span><br><span class="line">    var ctx = arguments[0] || window;</span><br><span class="line">    ctx.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    for (var i = 1; i &lt;= arguments.length; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class="line">    delete ctx.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply的原理实现"><a href="#apply的原理实现" class="headerlink" title="apply的原理实现"></a><strong>apply的原理实现</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.newApply = function (ctx, arr) &#123;</span><br><span class="line">    var ctx = ctx || window;</span><br><span class="line">    ctx.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    if (arr) &#123;</span><br><span class="line">        console.log(&apos;haha&apos;)</span><br><span class="line">        for (var i = 0; i &lt;= arr.length; i++) &#123;</span><br><span class="line">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var result = ctx.fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete ctx.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装的manageCookie的方法"><a href="#封装的manageCookie的方法" class="headerlink" title="封装的manageCookie的方法"></a><strong>封装的manageCookie的方法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var manageCookie = &#123;</span><br><span class="line">    setCookie: function (name, age, time) &#123;</span><br><span class="line">        document.cookie = name + &apos;=&apos; + value + &apos;; max-age=&apos; + time;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeCookie: function (name) &#123;</span><br><span class="line">        return this.setCookie(name, &apos;&apos;, -1);</span><br><span class="line">    &#125;,</span><br><span class="line">    getCookie: function (name, callback) &#123;</span><br><span class="line">        var cookieStrArr = document.cookie.split(&apos;; &apos;);</span><br><span class="line">        var len = cookieStrArr.length;</span><br><span class="line">        for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            var cookieName = cookieStrArr[i].split(&apos;=&apos;)[0];</span><br><span class="line">            if (cookieName == name) &#123;</span><br><span class="line">                callback(cookieStrArr[i].split(&apos;=&apos;)[1]);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callback(null);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装requestAnimationFrame的实现"><a href="#封装requestAnimationFrame的实现" class="headerlink" title="封装requestAnimationFrame的实现"></a><strong>封装requestAnimationFrame的实现</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimFrame = (function () &#123;</span><br><span class="line">    return window.requestAnimationFrame ||</span><br><span class="line">        window.webkitRequestAnimationFrame ||</span><br><span class="line">        window.mozRequestAnimationFrame ||</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">window.cancelAnimFrame = (function () &#123;</span><br><span class="line">    return window.cancelAnimationFrame ||</span><br><span class="line">        window.webkitCancelAnimationFrame ||</span><br><span class="line">        window.mozCancelAnimationFrame ||</span><br><span class="line">        function (id) &#123;</span><br><span class="line">            window.clearTimeout(id);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="传func-返回新的函数"><a href="#传func-返回新的函数" class="headerlink" title="传func 返回新的函数"></a><strong>传func 返回新的函数</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var getSingle = function (func) &#123;</span><br><span class="line">    var result;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (!result) &#123;</span><br><span class="line">            result = func.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浅度克隆&quot;&gt;&lt;a href=&quot;#浅度克隆&quot; class=&quot;headerlink&quot; title=&quot;浅度克隆&quot;&gt;&lt;/a&gt;&lt;strong&gt;浅度克隆&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>谈JavaScript性能提升</title>
    <link href="http://yoursite.com/2018/09/29/JS_High_Performance/"/>
    <id>http://yoursite.com/2018/09/29/JS_High_Performance/</id>
    <published>2018-09-29T09:43:49.007Z</published>
    <updated>2018-10-18T15:34:13.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基于数据访问提升性能"><a href="#一、基于数据访问提升性能" class="headerlink" title="一、基于数据访问提升性能"></a><strong>一、基于数据访问提升性能</strong></h3><ol><li><p>在JavaScript中，数组的存储位置可以对代码整体性能产生重要的影响。有四种数据访问类型：直接量，变量，数组项，对象成员。他们有不同的性能考虑：</p><ul><li><p>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间</p></li><li><p>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为他们总是位于作用域链的最后一环</p></li><li><p>避免使用width表达式，因为他改变了运行期上下文的作用域链。而且因当小心try-catch表达式的catch子句，因为它具有同样的效果</p></li><li><p>嵌套对象成员会造成重大的性能影响，尽量少用</p></li><li><p>一个属性或方法在原型链中的位置越深，访问他的速度就越慢</p></li></ul></li><li><p><strong>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的书读会快于那些原始变量</strong>通过使用这些策略，你可以极大地提高那些需要大量JavaScript代码的网页应用的实际性能</p></li></ol><h3 id="二、基于DOM创建、访问和操作提升性能"><a href="#二、基于DOM创建、访问和操作提升性能" class="headerlink" title="二、基于DOM创建、访问和操作提升性能"></a><strong>二、基于DOM创建、访问和操作提升性能</strong></h3><ol><li><p>Javascript分为三部分DOM,BOM和ECMAScript，他们都是相互独立的，JavaScript要访问DOM，这两个独立的部分以功能接口连接就会带来性能损耗。一个很形象的的比域就是帮他们两个比作是两个独立的岛屿，其中一个岛屿要到另一岛屿就要通过一座桥，通过这座桥是要交费用的所以每过一次就多一次费用，好比JavaScript对DOM的访问获取，所以要尽量减少对DOM节点的访问获取，努力停留在ECMAScript岛屿上，还有DOM获取后还会操作DOM，那这个费用就更高了（即修改DOM的长宽、颜色等会导致页面的回流和重绘，消耗性能，也应该尽量减少）</p></li><li><p>在innerHTML和document.createElemnt来给文档创建DOM节点中，innerHTML速度会更快些，除了最新的基于webkit的浏览器（Chrome和Safari，反而另外一个更快），还有一种创建新的DOM节点就是通过克隆已有的节点，在大多数浏览器中，克隆节点更有效率，但提高不太多</p></li><li><p>HTML集合是存放DOM的一个对象（类数组），比如下面函数返回的就是一个集合：</p></li></ol><blockquote><p>document.getElementsByName()<br>document.getElementsByClassName()<br>document.getElementsByTagName_r()<br>document.images 页面中所有的<img>元素<br>document.links 页面中所有的<a>元素<br>document.forms 页面中所有的表单<br>document.forms[0].elements 页面中第一个表单的所有字段</a></p></blockquote><p><strong>记住：正如DOM标准所定义那样，HTML集合是一个“虚拟存在，意味着底层文档更新时，它们将自动更新”</strong></p><ol start="4"><li>HTML集合实际上在查询文档，当你信息更新时，每次都要重复这种查询操作，例如读取集合元素的数目。这正是低效率的来源</li></ol><h3 id="三、基于DOM节点的访问的性能提升"><a href="#三、基于DOM节点的访问的性能提升" class="headerlink" title="三、基于DOM节点的访问的性能提升"></a><strong>三、基于DOM节点的访问的性能提升</strong></h3><ol><li><p>节点访问的时候如果有直接访问元素节点的API就直接用（比如children的访问肯定比childrenNode访问要快，因为children集合项更新少遍历快），不能直接访问元素节点的 <strong>如IE9及以下仅支持node.children</strong> </p></li><li><p>DOM选择器API：querySelectorAll()，括号内的查找跟css选择器查找类似（IE8及以上支持）,还有一个就是querySelector()，这个选择器放回符合元素节点的<br>第一位，<strong>他们不是HTML集合（即信息不是实时的）</strong>，相比于通过getElementsByClassName等的方法来通过迭代操作获取到精确的DOM，querySelectorAll()更快</p></li><li><p>获取DOM布局信息的操作时也会导致重排重绘制（因为这些信息要返回的时最新的数据，所以要重新计算)：如</p><ul><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li><li>clientTop, clientLeft, clientWidth, clientHeight</li><li>getComputedStyle() (currentStyle in IE)在IE中此函数称作为currentStyle</li></ul></li><li><p>页面上的某一个元素的大小信息的改变都会导致一部分需要重排重绘，但是某些改变可导致重排整个页面，例如，当一个咕哝当条的出现</p></li></ol><h3 id="四、减少DOM的重派重绘"><a href="#四、减少DOM的重派重绘" class="headerlink" title="四、减少DOM的重派重绘"></a><strong>四、减少DOM的重派重绘</strong></h3><ol><li><p>优化style的改变</p><ul><li><p>为减少重排重绘的发生次数，应该将多个DOM和风格的改变合并到一块一次性执行（大多数浏览器都会进行优化只进行一次重排重绘）。</p></li><li><p>还有一个具有同样效果的方法就是使用cssText属性：el.style.cssText = ‘border-left: 1px; border-right: 2px; padding: 5px;’;el.style.cssText += ‘; border-left: 1px;’;</p></li><li><p>还有另外一种就是改变DOM的class值，通过切换class值来达到样式的改变</p></li></ul></li><li><p>批量修改DOM</p><ul><li><p>要对一个DOM元素进行修改，将他的display设置为none之后进行操作，操作完毕后将display再设置回去</p></li><li><p>针对要增加节点之类的可以通过文档片断，文档片断是一个轻量级的document对象，将你到添加的DOM内容放入文档片断中，然后将文档片断添加到实际的DOM中，注意实际添加的时文档片断中的内容，不是片断本身( <strong>推荐尽可能的用这种，因为这种涉及最少的DOM操作</strong> )</p></li><li><p>可以通过克隆节点的方法，将克隆下来的节点进行修改（ele.cloneNode()），修改后再替换旧的节点</p></li></ul></li></ol><h3 id="五、基于动画性能优化"><a href="#五、基于动画性能优化" class="headerlink" title="五、基于动画性能优化"></a><strong>五、基于动画性能优化</strong></h3><ol><li><p>动画中使用绝对坐标定位页面中的动画元素，使他位于页面布局流之外</p></li><li><p>启动GPU硬件加速</p><ul><li><a href="https://aotu.io/notes/2017/04/11/GPU/" target="_blank" rel="noopener">GPU加速是什么</a></li><li><a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html" target="_blank" rel="noopener">普通图层和复合图层</a></li><li><a href="http://web.jobbole.com/83575/" target="_blank" rel="noopener">CSS3硬件加速也有坑</a></li></ul></li></ol><h3 id="六、-hover"><a href="#六、-hover" class="headerlink" title="六、:hover"></a><strong>六、:hover</strong></h3><ol><li>避免过多的元素中（如500-1000行5列构成的表）使用：hover时 否则会降低反映速度，cpu使用率会提高到80%-90%</li></ol><h3 id="七、事件委托"><a href="#七、事件委托" class="headerlink" title="七、事件委托"></a><strong>七、事件委托</strong></h3><ol><li>利用了事件流的事件冒泡和事件源对象来实现事件委托</li></ol><p>2.优点：</p><pre><code>- 不需要对每个dom进行绑定事件，只需对父级进行绑定，减少内存消耗，提高性能- 动态绑定事件，对新添进来的子元素不需要绑定事件</code></pre><h3 id="八、基于循环的性能优化"><a href="#八、基于循环的性能优化" class="headerlink" title="八、基于循环的性能优化"></a><strong>八、基于循环的性能优化</strong></h3><ol><li><p>JavaScript有四种循环： for循环，while，do-while，for-in</p></li><li><p>JavaScript提供的四中循环里，只有一种循环比其他的循环明显要慢：for-in循环，由于每次迭代时都要搜索对象中的属性和对象原型上的属性，同样的循环迭代的操作中，for-in循环要比其它的循环慢7倍之多，除非你对数目不详的对象属性进行操作，否则避免使用for-in循环，其它的三个循环性能都相当</p></li><li><p>对一个数组的循环遍历属性，一个优化就是将数组的长度存放到局部变量中，以防止每次循环都要访问数组的长度arr.length,以此提升性能</p></li><li><p>还有一个很重要的优化就是使用倒序循环，并在控制条件中使用了减法，每个控制条件只是简单的和0进行比较。控制条件与true值进行比较，任何非零数字转化为true，0转化为false，控制条件已从两次比较（迭代次数小于总数了吗？它等于false了吗）变成了一次比较（它等于true了吗？），以此可以大幅度提高循环速度，<strong>通过倒序循环和最小化属性查询，当循环迭代次数很多时可以大幅度提升执行速度</strong></p></li><li><p>事实证明大多数情况下switch表达式比if-else更快，担当只有条件数量很大时才明显更快，if-else适合判断两个离散的值或判断几个不同的值域。如果判断多余两个离散值，switch表达式更好</p></li></ol><h3 id="九、递归和迭代"><a href="#九、递归和迭代" class="headerlink" title="九、递归和迭代"></a><strong>九、递归和迭代</strong></h3><ol><li><p>任何可以实现递归的算法都可以用迭代实现。迭代算法通常包括几个不同的循环，分别对应算法过程的不同方面，也会导致自己的性能问题。但是，使用优化的循环代替长时间的运行的递归函数可以提高性能，因为运行一个循环比反复调用一个函数的开销要低。</p></li><li><p>将递归算法切换为迭代只是避免栈溢出错误的方法之一</p></li></ol><h3 id="十、制表"><a href="#十、制表" class="headerlink" title="十、制表"></a><strong>十、制表</strong></h3><ol><li><p>制表，通过缓存先前计算结果为后续计算所重复使用，避免了重复的工作。这使得制表成为递归算法中有用的技术</p></li><li><p>为了是一个函数的制表过程更加容易，你可以定义一个memorize()函数封装基本功能。例如：</p><pre><code>function memoize(fundamental, cache){    cache = cache || {};    var shell = function(arg){        if (!cache.hasOwnProperty(arg)){            cache[arg] = fundamental(arg);        }        return cache[arg];    };    return shell;}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基于数据访问提升性能&quot;&gt;&lt;a href=&quot;#一、基于数据访问提升性能&quot; class=&quot;headerlink&quot; title=&quot;一、基于数据访问提升性能&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、基于数据访问提升性能&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Jav
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理清[[scope]]、运行期上下文和函数作用域链、闭包</title>
    <link href="http://yoursite.com/2018/09/28/%5B%5Bscope%5D%5D/"/>
    <id>http://yoursite.com/2018/09/28/[[scope]]/</id>
    <published>2018-09-28T07:00:32.277Z</published>
    <updated>2018-10-11T07:46:58.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域链的解析"><a href="#作用域链的解析" class="headerlink" title="作用域链的解析"></a>作用域链的解析</h2><h3 id="scope-是啥，它与作用域链之间的关系"><a href="#scope-是啥，它与作用域链之间的关系" class="headerlink" title="[[scope]]是啥，它与作用域链之间的关系"></a><strong>[[scope]]是啥，它与作用域链之间的关系</strong></h3><p>我们都知道每个JavaScript函数都是一个对象，更确切的说它是一个函数的实例，他会像对象那样存在自身的属性（可以被程序访问），还存在一系列只被JS引擎使用的内部属性，其中一个内部属性就是[[scope]]，[[scope]]属性中包含了一个函数被创建时作用域对象的集合，此集合就称作是作用域链，这些作用域对象就是代表在创建此函数的环境中能够访问的数据</p><p>add函数的内置属性[[scope]]图：<br>    <img src="/images/blog_images/scope1.png" alt="image"></p><h3 id="再来讲下运行期上下文"><a href="#再来讲下运行期上下文" class="headerlink" title="再来讲下运行期上下文"></a><strong>再来讲下运行期上下文</strong></h3><p>函数被执行时，函数会创建一个内部对象，称作“运行期上下文”。这个运行期上下文定义了一个函数运行时的环境，而且运行期上下文有自己独立的作用域链，这个作用域链在此对象创建时就会被初始化，此时函数内部属性[[scope]]中的作用域链中的对象会按顺序被复制到运行期上下文的作用域链中，此时还会创建一新对象（即此函数的作用域）AO放到运行期上下文作用域链的前端，这个新对象被称为“激活对象”，它存放着此函数的局部变量和this接口等。</p><p>运行期上下文在函数执行完就被销毁，所以函数每次执行的运行期上下文是独一无二的</p><p>add函数执行时的作用域链<br>    <img src="/images/blog_images/scope2.png" alt="image"></p><p>函数在运行时所遇到的变量（即标识符）都会按照运行期上下文的作用域链前端进行查找，变量所处的越深，它的读写书读就越慢，从而影响性能，所以为了能够减少性能损耗，最好将所需的变量编程局部变量（<strong>局部变量访问的总是最快的</strong>），有些也可以通过优化JS引擎来解决</p><p>说到在作用域链上访问变量，我们又可以联想到在对象中 <strong>原型链</strong> 上访问对象属性和方法，与访问变量一样，在对象中访问的属性和方法所在原型链越深搜索速度越慢，性能损耗越多，也可通过缓存属性或方法来提升性能（基于不会改变的值），但是 <strong>记住搜索实例成员的过程比访问直接量或局部变量负担更重</strong>。还有一个需要注意的就是 <strong>嵌套对象</strong>（如window.location.href.toString()，它的情况也与前两个很类似，在处理嵌套对象成员时要特别注意，否则它会对运行速度产生难以置信的影响</p><p>下面的代码就是将全局的变量document变成局部变量来提高性能，虽然一次不能够有较大性能的提升，但是访问多次的话性能改进将显的很出色<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function initUI() &#123;</span><br><span class="line">    var doc = document,</span><br><span class="line">        bd = doc.body,</span><br><span class="line">        links = doc.getElementsByTagName_r(&quot;a&quot;),</span><br><span class="line">        i = 0,</span><br><span class="line">        len = links.length;</span><br><span class="line">    while (i &lt; len) &#123;</span><br><span class="line">        update(links[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    doc.getElementById(&quot;go-btn&quot;).onclick = function () &#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;;</span><br><span class="line">    bd.className = &quot;active&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="改变作用域链"><a href="#改变作用域链" class="headerlink" title="改变作用域链"></a><strong>改变作用域链</strong></h3><p>一般来说，一个运行期上下文的作用域链不会被改变，但是有两种表达式可以改变其作用域链，第一个是width：width属性会为所有的对象属性添加一个操作变量，当代码在width运算符中执行，函数运行期上下文的作用域链就会被临时改变，一个新的对象（作用域）会被创建，这个对象包含with括号中执行对象的所有属性，他会被放到运行期上下文中的前端，意味着现在函数的作用域对象将被放置于作用域的第二位，是的访问局部变量的速度变慢了，正是这个原因，最好不要用width表达式，如下只要将document对象变成局部变量就可以获得性能提升<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function initUI() &#123;</span><br><span class="line">    with (document) &#123; //avoid!</span><br><span class="line">        var bd = body,</span><br><span class="line">            links = getElementsByTagName_r(&quot;a&quot;),</span><br><span class="line">            i = 0,</span><br><span class="line">            len = links.length;</span><br><span class="line">        while (i &lt; len) &#123;</span><br><span class="line">            update(links[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        getElementById(&quot;go-btn&quot;).onclick = function () &#123;</span><br><span class="line">            start();</span><br><span class="line">        &#125;;</span><br><span class="line">        bd.className = &quot;active&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为一个表达书就是try-catch表达式的catch语句，当进入catch块中，会将异常的对象放入到运行期上下文作用域链的最前端，将存有局部变量的对象放入到作用域链的第二个位置（ 但是只要catch执行完作用域链就会回到原来的样子 ），如果非要用catch可以将catch中的对象给外部的函数来处理，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    methodThatMightCauseAnError();</span><br><span class="line">&#125; catch (ex) &#123;</span><br><span class="line">    handleError(ex); //delegate to handler method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><ol><li><p>闭包可以理解成“定义在一个函数内部的函数“。即当函数可以记住并访问所在的词法作用域时，就产生了闭包。在本质上，闭包是将函数内部和函数外部连接起来的桥梁，通过将函数内部定义的函数赋值给外部变量或用return返回出来。</p></li><li><p>闭包无处不在：</p><ul><li>在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！<br>-还有个非常典型的例子就是立即执行函数（IIFE模式），看下面的代码，尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">(function IIFE() &#123;</span><br><span class="line">    console.log( a );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用了闭包的强大的威力：<strong>模块</strong></p><ul><li><p>考虑以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function CoolModule() &#123;</span><br><span class="line">    var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        console.log( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        console.log( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var foo = CoolModule();</span><br><span class="line">foo.doSomething(); // cool</span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></li><li><p>以上这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。</p></li><li><p>从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。</p></li><li><p>如果要更简单的描述，模块模式需要具备两个必要条件。</p><ul><li><p>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</p></li><li><p>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</p><h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a><strong>词法作用域和动态作用域</strong></h3></li></ul></li></ul></li><li><p>JavaScript 中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval() 或 with）</p></li><li><p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p></li><li><p>事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域</p></li><li><p>主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用域链的解析&quot;&gt;&lt;a href=&quot;#作用域链的解析&quot; class=&quot;headerlink&quot; title=&quot;作用域链的解析&quot;&gt;&lt;/a&gt;作用域链的解析&lt;/h2&gt;&lt;h3 id=&quot;scope-是啥，它与作用域链之间的关系&quot;&gt;&lt;a href=&quot;#scope-是啥，它与作用
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this的全面解析</title>
    <link href="http://yoursite.com/2018/09/28/This/"/>
    <id>http://yoursite.com/2018/09/28/This/</id>
    <published>2018-09-28T05:38:50.401Z</published>
    <updated>2018-10-19T12:02:49.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域链的解析"><a href="#作用域链的解析" class="headerlink" title="作用域链的解析"></a>作用域链的解析</h2><h3 id="什么是this"><a href="#什么是this" class="headerlink" title="什么是this"></a><strong>什么是this</strong></h3><ol><li>对于this，this的作用是提供了一种更优雅的方式来隐式“传递”一个对象引用（即上下文对象），它的特性跟动态作用域有点相似，this 是在运行时进行绑定的，即this在一个函数调用时发生绑定，就是当函数调用时，函数会创建一个AO对象，这个对象中会存放记录函数内的变量，函数传进来的参数，函数是在哪里被调用的等信息，this就是其中的一个属性，会在函数执行过程中用到，<strong>this的指向取决于函数在哪里被调用</strong>。</li></ol><h3 id="对于this的绑定有四个绑定规则"><a href="#对于this的绑定有四个绑定规则" class="headerlink" title="对于this的绑定有四个绑定规则"></a><strong>对于this的绑定有四个绑定规则</strong></h3><ol><li>this含有四种绑定规则</li></ol><p><strong>默认绑定</strong>：</p><pre><code>- 一个函数foo在不带任何参数修饰调用时（即foo函数执行时没有被任何对象调用），这个函数内部的this就会使用默认绑定，this指向window，但前提是在非严格模式下，如果在严格模式下，this就会绑定undefiend，注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式，看下面的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">    var a = 2;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        &quot;use strict&quot;; </span><br><span class="line">        foo();    // 2 </span><br><span class="line">    &#125;)();</span><br></pre></td></tr></table></figure>- 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</code></pre><p><strong>隐式绑定</strong>：</p><pre><code>- 当一个函数在一个上下文对象中调用时，隐式绑定规则就会将函数中的this绑定到这个上下文对象中，比如obj.fn();对象属性引用链中只有最顶层或者说最后一层会影响调用位置,比如, obj1.obj2.fn()，fn执行中this指向obj2，还存在一些javascript内置函数比如：setTimeout它第一个参数函数中的this指向的是window，还有一些事件处理函数中的回调函数中的this指向的是dom元素</code></pre><p><strong>显示绑定</strong>：</p><pre><code>- 显示绑定就是通过函数原型链上的两个方法call和apply还有bind来实现改变this的指向，数组的foreach和map函数中的就用到了call和apply来进行显示绑定this</code></pre><p><strong>new绑定</strong>：</p><pre><code>- 每个函数都可以通过new操作符来实例化一个对象，每个函数在new之后函数内部就会隐式创建一个this对象，this对象中有一个默认属性__proto__指向该函数的原型链，如果该函数最后没有返回值，那么会隐式返回这个this对象，如果该函数返回一个不是对象的值，那么还是会返回这个this对象，如果返回的是一个对象，呢么该函数将会返回的是这个对象</code></pre><ol start="2"><li>绑定优先级</li></ol><p>New绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h3 id="对于涉及到this但是不关心this的情况"><a href="#对于涉及到this但是不关心this的情况" class="headerlink" title="对于涉及到this但是不关心this的情况"></a><strong>对于涉及到this但是不关心this的情况</strong></h3><ol><li><p>比如在一个函数进行执行的过程中传入的参数是一个数组的话，可以用apply来将数组作为第二个参数进行传入（fn.apply(null,[1,2])），但是对于该函数来说第一个参数是没有不需要关心的，但人需要一个占位符，这是null是一个很不错的选择（undefined也可以），在es6直接可以使用扩展运算符fn(…[1,2])。另外一个引用就是使用bind来实现柯里化思想时，这是this也是我们不会关心的对象。</p></li><li><p>但考虑到this只想全局对象后会对全局对象有影响，我们给出了一个更好的解决方法，就是我们在忽略 this 绑定时总是传入一个 DMZ（它就是一个空的非委托的对象）对象，在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和{}很 像， 但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”，用这个对象去表示“ 我希望this是空”，这比 null 的含义更清楚。</p></li></ol><h2 id="说说箭头函数中的this"><a href="#说说箭头函数中的this" class="headerlink" title="说说箭头函数中的this"></a><strong>说说箭头函数中的this</strong></h2><ol><li><p>要知道箭头函数不是使用function来定义的，它是通过被称为“胖箭头”的操作符“=&gt;”来定义的。箭头函数不使用this的四种绑定规则，而是根据离他最近的作用域来决定this的，而且箭头函数的this绑定是无法被修改的（new也不行）</p></li><li><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式，就是使用self=this</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用域链的解析&quot;&gt;&lt;a href=&quot;#作用域链的解析&quot; class=&quot;headerlink&quot; title=&quot;作用域链的解析&quot;&gt;&lt;/a&gt;作用域链的解析&lt;/h2&gt;&lt;h3 id=&quot;什么是this&quot;&gt;&lt;a href=&quot;#什么是this&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>刷算法题</title>
    <link href="http://yoursite.com/2018/09/22/Algorithm/"/>
    <id>http://yoursite.com/2018/09/22/Algorithm/</id>
    <published>2018-09-22T05:37:26.080Z</published>
    <updated>2018-10-10T03:10:09.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="刷leetcode算法"><a href="#刷leetcode算法" class="headerlink" title="刷leetcode算法"></a>刷leetcode算法</h2><h3 id="26-从排序数组中删除重复项"><a href="#26-从排序数组中删除重复项" class="headerlink" title="#26-从排序数组中删除重复项"></a><strong>#26-从排序数组中删除重复项</strong></h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeDuplicates = function(arr) &#123;</span><br><span class="line">    for(var i = 0; i &lt; arr.length - 1; i ++)&#123;</span><br><span class="line">                for(var j = i + 1; j &lt; arr.length; j ++)&#123;</span><br><span class="line">                    if(arr[i] === arr[j])&#123;</span><br><span class="line">                        arr.splice(j--, 1)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return arr.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="#189-旋转数组"></a><strong>#189-旋转数组</strong></h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span><br><span class="line"> */</span><br><span class="line">var rotate = function(nums, k) &#123;</span><br><span class="line">    nums.unshift(...nums.splice(nums.length - k))</span><br><span class="line">    // 另一种</span><br><span class="line">    // if(typeof k === &apos;number&apos; &amp;&amp; k &gt;= 0)&#123;</span><br><span class="line">    //             for(var i = 0; i &lt; k; i++)&#123;</span><br><span class="line">    //                 nums.unshift(nums.pop());</span><br><span class="line">    //             &#125;</span><br><span class="line">    //         &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="260-只出现一次的数字"><a href="#260-只出现一次的数字" class="headerlink" title="#260-只出现一次的数字"></a><strong>#260-只出现一次的数字</strong></h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var singleNumber = function(nums) &#123;</span><br><span class="line">    var a = 0;</span><br><span class="line">            for (let val of nums) &#123;a ^= val&#125;</span><br><span class="line">            return a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="#350-两个数组的交集 II"></a><strong>#350-两个数组的交集 II</strong></h3><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums1</span><br><span class="line"> * @param &#123;number[]&#125; nums2</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var intersect = function(nums1, nums2) &#123;</span><br><span class="line">     nums1.sort(sortFun)</span><br><span class="line">    nums2.sort(sortFun)</span><br><span class="line"></span><br><span class="line">    if (nums1.length &lt; nums2.length) &#123;</span><br><span class="line">        let tmp = nums1</span><br><span class="line">        nums1 = nums2</span><br><span class="line">        nums2 = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    const ans = []</span><br><span class="line">    let index1 = 0, index2 = 0</span><br><span class="line">    while (index1 &lt; nums1.length) &#123;</span><br><span class="line">        if (nums1[index1] == nums2[index2]) &#123;</span><br><span class="line">            ans.push(nums2[index2])</span><br><span class="line">            index1++</span><br><span class="line">            index2++</span><br><span class="line">        &#125; else if (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            index2++</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;;</span><br><span class="line">function sortFun(a, b) &#123;</span><br><span class="line">    return a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="66-加一"><a href="#66-加一" class="headerlink" title="#66-加一"></a><strong>#66-加一</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="#283-移动零"></a><strong>#283-移动零</strong></h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span><br><span class="line"> */</span><br><span class="line">var moveZeroes = function(nums) &#123;</span><br><span class="line">    let i = 0; len = nums.length</span><br><span class="line">    while (i &lt; len) &#123;</span><br><span class="line">        if (nums[i] == 0) &#123;</span><br><span class="line">            nums.splice(i, 1)</span><br><span class="line">            nums.push(0)</span><br><span class="line">            len--</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="#1-两数之和"></a><strong>#1-两数之和</strong></h3><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    //第一种</span><br><span class="line">    // var len = nums.length</span><br><span class="line">    // for(var i = 0; i &lt; len; i ++)&#123;</span><br><span class="line">    //            for(var j = i + 1; j &lt; len; j ++)&#123;</span><br><span class="line">    //                if( nums[i] + nums[j] == target)&#123;</span><br><span class="line">    //                    return [i, j]</span><br><span class="line">    //                &#125;</span><br><span class="line">    //            &#125;</span><br><span class="line">    //        &#125;</span><br><span class="line">    </span><br><span class="line">    //第二种</span><br><span class="line">    //空间换时间 哈希表查找最快</span><br><span class="line">    var hashList = &#123;&#125;;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        //判断已存在哈希表是否有匹配</span><br><span class="line">        var pairNum = target - nums[i];</span><br><span class="line">        if (hashList[pairNum] !== undefined) return [hashList[pairNum], i];</span><br><span class="line">        //无匹配则将当前项加入哈希表</span><br><span class="line">        hashList[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="#48-旋转图像"></a><strong>#48-旋转图像</strong></h3><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.</span><br><span class="line"> */</span><br><span class="line">var rotate = function(matrix) &#123;</span><br><span class="line">    matrix.reverse()</span><br><span class="line">    for (let i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        for (let j = i + 1; j &lt; matrix[0].length; j++) &#123;</span><br><span class="line">            let tmp = matrix[i][j]</span><br><span class="line">            matrix[i][j] = matrix[j][i]</span><br><span class="line">            matrix[j][i] = tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="#242-有效的字母异位词"></a><strong>#242-有效的字母异位词</strong></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @param &#123;string&#125; t</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isAnagram = function(s, t) &#123;</span><br><span class="line">    const arr = new Array(26);</span><br><span class="line">    arr.fill(0)</span><br><span class="line">    for(let item of s)&#123;</span><br><span class="line">        arr[item.charCodeAt() - &quot;a&quot;.charCodeAt()]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let item of t)&#123;</span><br><span class="line">        arr[item.charCodeAt() - &quot;a&quot;.charCodeAt()]--;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let item of arr)&#123;</span><br><span class="line">        if(item != 0) return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="125-验证回文字符串"><a href="#125-验证回文字符串" class="headerlink" title="#125-验证回文字符串"></a><strong>#125-验证回文字符串</strong></h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isPalindrome = function(s) &#123;</span><br><span class="line">        s = s.replace(/[^\w]/g, &quot;&quot;)</span><br><span class="line">    if (s.length == 0) return true</span><br><span class="line"></span><br><span class="line">    var start = 0, end = s.length - 1</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        if (!s[start] || !s[end]) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[start].toLowerCase() != s[end].toLowerCase()) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        start++</span><br><span class="line">        end--</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;刷leetcode算法&quot;&gt;&lt;a href=&quot;#刷leetcode算法&quot; class=&quot;headerlink&quot; title=&quot;刷leetcode算法&quot;&gt;&lt;/a&gt;刷leetcode算法&lt;/h2&gt;&lt;h3 id=&quot;26-从排序数组中删除重复项&quot;&gt;&lt;a href=&quot;#26-
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>事件, 事件处理模型, 事件流, 事件委托</title>
    <link href="http://yoursite.com/2018/09/18/Event/"/>
    <id>http://yoursite.com/2018/09/18/Event/</id>
    <published>2018-09-18T05:16:39.091Z</published>
    <updated>2018-09-28T08:19:13.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="如何绑定事件-事件是天生自然有的"><a href="#如何绑定事件-事件是天生自然有的" class="headerlink" title="如何绑定事件(事件是天生自然有的)"></a><strong>如何绑定事件(事件是天生自然有的)</strong></h3><p>1.ele.onxxx = function (event) {}</p><ul><li>兼容性很好，但是一个元素只能绑定一个处理程序</li><li>基本等同于写在HTML行间上（两种都称为句柄的绑定方式）</li><li>程序this指向是dom元素本身</li></ul><p>2.ele.addEventListener(type, fn, false);</p><ul><li>IE9 以下不兼容，可以为一个事件绑定多个处理程序，并且按绑定的顺序去执行（谁先绑定谁先执行， 但不能够给同一个函数绑定多次）</li><li>程序this指向是dom元素本身</li></ul><p>3.ele.attachEvent(‘on’ + type, fn);</p><ul><li>IE独有，一个事件同样可以绑定多个处理程序（但是它一个对象的一个事件绑定同一个函数绑定了多次，它都能执行多次）</li><li>程序this指向window</li></ul><ol start="4"><li><p>封装兼容性的 addEvent(elem, type, handle)方法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(elem,type,handle)&#123;</span><br><span class="line">    if(elem.addEventListener)&#123;</span><br><span class="line">        elem.addEventListener(type,handle,false);</span><br><span class="line">    &#125;else if(elem.attachEvent)&#123;</span><br><span class="line">        elem.attachEvent(&apos;on&apos; + type,function()&#123;</span><br><span class="line">            handle.call(elem);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        elem[&apos;on&apos;+ type] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="解除事件处理程序"><a href="#解除事件处理程序" class="headerlink" title="解除事件处理程序"></a><strong>解除事件处理程序</strong></h3><ol><li><p>ele.onclick = false/‘’/null;</p></li><li><p>ele.removeEventListener(type, fn, false);</p></li><li><p>ele.detachEvent(‘on’ + type, fn);</p></li><li><p>注:解除事件，要用相对应的解除事件处理程序，若绑定匿名函数，则无法解除</p></li><li><p>封装兼容性的 removeEvent(elem, type, handle)方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function removeEvent(elem, type, handle) &#123;</span><br><span class="line">    if (elem.removeEventListener) &#123;</span><br><span class="line">        elem.removeEventListener(type, handle, false);</span><br><span class="line">    &#125; else if (elem.detachEvent) &#123;</span><br><span class="line">        elem.detachEvent(&apos;on&apos; + type, function () &#123;</span><br><span class="line">            handle.call(elem);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        elem[&apos;on&apos; + type] = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="事件处理模型-事件冒泡、事件捕获"><a href="#事件处理模型-事件冒泡、事件捕获" class="headerlink" title="事件处理模型 - 事件冒泡、事件捕获"></a><strong>事件处理模型 - 事件冒泡、事件捕获</strong></h3><ol><li><p>事件冒泡：结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）</p></li><li><p>事件捕获：结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自底向上）</p></li><li><p>IE没有捕获事件</p></li><li><p>触发顺序，先捕获，后冒泡，focus blur change submit reset select load unload等事件不冒泡</p></li><li><p>当一个对象的一个事件类型绑定两个函数是，一个是冒泡，一个是捕获，执行的顺序是先捕获后冒泡：（执行结果中box在boxBubble下面是因为一个对象的一个事件类型绑定不同的函数，谁先绑定谁先执行）注意：冒泡的开始不属于冒泡是执行，捕获的最终不属于捕获是执行，如下：</p><p> <img src="/images/blog_images/Event1.png" alt="image">    <img src="/images/blog_images/Event2.png" alt="image"></p></li></ol><h3 id="取消冒泡和阻止默认事件"><a href="#取消冒泡和阻止默认事件" class="headerlink" title="取消冒泡和阻止默认事件"></a><strong>取消冒泡和阻止默认事件</strong></h3><ol><li><p>取消冒泡：</p><ul><li><p>W3C标准 event.stopPropagation();但不支持ie9以下版本</p></li><li><p>IE独有 event.cancelBubble = true;</p></li><li><p>封装取消冒泡的函数 stopBubble(event)：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function stopBubble(event) &#123;</span><br><span class="line">    if(event.stopPropagation)&#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        event.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>阻止默认事件:</p><ul><li>默认事件 — 表单提交，a标签跳转，右键菜单等</li><li>return false;  以对象属性的方式注册的事件才生效（是句柄的方式来阻止默认事件。只有我们用句柄的方式绑定默认事件用return false才好使）</li><li>event.preventDefault(); W3C标准，IE9以下不兼容</li><li>event.returnValue = false; 兼容IE</li><li><p>封装阻止默认事件的函数 cancelHandler(event)，<strong>return false 是封装不进去的</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function cancelHandle(event) &#123;</span><br><span class="line">    if(event.preventDefault)&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        event.returnValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.div.onclick = function(e){},这个e参数添加后，系统会帮我们传一个事件对象，对象上面有很多属性，每一个属性都记载了事件发生时的关键性数据和一系列信息，event.stopPropagation();  e.cancelBubble = true:谷歌也能实现了</p></li><li><p>A标签有一个默认事件，就是点击后会回到页面最顶端，取消这个默认事件的简便方法有：void（false/ 0）意思是return false：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: void(false)&quot;&gt;demo&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a><strong>事件流</strong></h3><ol><li><p>事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。</p><ul><li>事件捕获阶段（IE8及以下不支持）</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul></li></ol><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a><strong>事件委托</strong></h3><ol><li><p>利用事件冒泡，和事件源对象进行处理</p></li><li><p>优点：</p><ul><li>不需要对每个dom进行绑定事件，只需对父级进行绑定，减少内存消耗，提高性能</li><li>动态绑定事件，对新添进来的子元素不需要绑定事件</li></ul></li><li><p>适合用事件委托的事件：click, mousedown, mouseup, keydown, keyup, keypress</p></li></ol><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a><strong>事件对象</strong></h3><ol><li><p>window.event适合于IE8及以下 || event</p></li><li><p>事件源对象：event.target || event.srcElement(IE8及以下)</p></li></ol><h3 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a><strong>事件分类</strong></h3><ol><li><p>鼠标事件：click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout、 mouseenter mouseleave</p></li><li><p>表单事件：submit、reset、change、focus、blur、input、</p></li><li><p>window事件：load、DOMContentLoaded、unload、beforeLoad、scroll、resize</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h2&gt;&lt;h3 id=&quot;如何绑定事件-事件是天生自然有的&quot;&gt;&lt;a href=&quot;#如何绑定事件-事件是天生自然有的&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>预编译, 递归, 作用域和作用域链</title>
    <link href="http://yoursite.com/2018/09/18/precompile/"/>
    <id>http://yoursite.com/2018/09/18/precompile/</id>
    <published>2018-09-17T16:23:29.500Z</published>
    <updated>2018-10-10T07:04:38.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预编译-递归"><a href="#预编译-递归" class="headerlink" title="预编译, 递归"></a>预编译, 递归</h2><h3 id="Js运行机制"><a href="#Js运行机制" class="headerlink" title="Js运行机制"></a><strong>Js运行机制</strong></h3><ol><li>语法分析 2. 预编译 3. 解析执行</li></ol><h3 id="预编译前奏"><a href="#预编译前奏" class="headerlink" title="预编译前奏"></a><strong>预编译前奏</strong></h3><p>1.暗示全局变量（imply global）：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有</p><ol start="2"><li>一切声明的全局变量，全是window的属性（window就是全局的域）</li></ol><h3 id="预编译四部曲（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）"><a href="#预编译四部曲（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）" class="headerlink" title="预编译四部曲（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）"></a><strong>预编译四部曲</strong>（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）</h3><ol><li><p>创建AO对象（Activity  Object （执行期上下文）），全局的话是生成一个GO对象（Global Object ,   GO === window）</p></li><li><p>找形参和变量声明，将变量和形参名作为AO属性名，值为undefined</p></li><li><p>将实参值和形参统一</p></li><li><p>在函数体里面找函数声明，值赋予函数体</p></li></ol><p>同时也要记住，函数表达式是不会被提升的，还有具名的函数表达式,它的名称标识符是存在函数作用域中的，外接式访问不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line">var foo = function bar() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码片段经过提升后，实际上会被理解为以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo;</span><br><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line">foo = function() &#123;</span><br><span class="line">    var bar = ...self...</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：现在的语法是不允许在if和for的{}中定义变量或者函数的（以前好使），但是定义了不会报错，变量可以访问但是值是undefined。预编译的时候也不会看if（）里面的东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(test); //undefined</span><br><span class="line">console.log(foo); //报错referenceError</span><br><span class="line">if(function foo()&#123;&#125;)&#123;</span><br><span class="line">    function test()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h3><ol><li><p>递归要符合两点：1.找规律（递归的过程），2.递归必须要有出口(递归的中止条件)</p></li><li><p>递归的一点好处就是能是代码变得更加简洁，除此之外没有任何好处，递归特别慢,而且函数递归调用过多超过调用栈的大小，会导致栈溢出</p></li><li><p>递归应用：</p><ul><li><p>递归求n的阶乘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mul(n)&#123;</span><br><span class="line">    if(n == 1 || n == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * mul(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fb(n)&#123;</span><br><span class="line">    if(n == 1 || n == 2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fb(n - 1) + fb(n - 2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说到这就说下斐波那契的非递归实现方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fb(n)&#123;</span><br><span class="line">    var n1 = 1,</span><br><span class="line">        n2 = 1,</span><br><span class="line">        n = 1;</span><br><span class="line">    for(var i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">        n = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n;</span><br><span class="line">    &#125;</span><br><span class="line">    return n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a><strong>作用域和作用域链</strong></h3><ol><li><p>[[scope]]:每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供javascript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域,其中存储了执行期上下文的集合</p></li><li><p>作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链</p></li><li><p>执行期上下文:当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁</p></li><li><p>查找变量：从作用域链的顶端依次向下查找</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;预编译-递归&quot;&gt;&lt;a href=&quot;#预编译-递归&quot; class=&quot;headerlink&quot; title=&quot;预编译, 递归&quot;&gt;&lt;/a&gt;预编译, 递归&lt;/h2&gt;&lt;h3 id=&quot;Js运行机制&quot;&gt;&lt;a href=&quot;#Js运行机制&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存sessionStorage, localStorage, cookie</title>
    <link href="http://yoursite.com/2018/09/17/Browser_Cache/"/>
    <id>http://yoursite.com/2018/09/17/Browser_Cache/</id>
    <published>2018-09-17T03:50:07.146Z</published>
    <updated>2018-09-17T07:19:07.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sessionStorage-localStorage-cookie"><a href="#sessionStorage-localStorage-cookie" class="headerlink" title="sessionStorage, localStorage, cookie"></a>sessionStorage, localStorage, cookie</h2><p>三个存储的共同点：都存储在浏览器端，都需符合同源策略</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h3><ol><li><p>主要用于用户的身份信息存储，cookie的内容会在请求的时候传递给服务器</p></li><li><p>cookie数据还有path路径的概念，可以限制cookie只属于某个路径下</p></li><li><p>cookie可以设置过期时间，当超过时间期限后cookie就会自动消失</p></li><li><p>cookie没有增删改查对应的api，但是我们可以自己封装一个</p></li><li><p>cookie的存储大小在 4KB 左右，很多浏览器都限制一个站点最多保存20个cookie</p></li><li><p>封装的 manageCookie 的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var manageCookie = &#123;</span><br><span class="line">    setCookie: function (name, age, time) &#123;</span><br><span class="line">        document.cookie = name + &apos;=&apos; + value + &apos;; max-age=&apos; + time;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeCookie: function (name) &#123;</span><br><span class="line">        return this.setCookie(name, &apos;&apos;, -1);</span><br><span class="line">    &#125;,</span><br><span class="line">    getCookie: function (name, callback) &#123;</span><br><span class="line">        var cookieStrArr = document.cookie.split(&apos;; &apos;);</span><br><span class="line">        var len = cookieStrArr.length;</span><br><span class="line">        for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            var cookieName = cookieStrArr[i].split(&apos;=&apos;)[0];</span><br><span class="line">            if (cookieName == name) &#123;</span><br><span class="line">                callback(cookieStrArr[i].split(&apos;=&apos;)[1]);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callback(null);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a><strong>sessionStorage</strong></h3><ol><li><p>它的生命周期同标签页的生命周期，当当前标签页被关闭，他存储的数据将被销毁</p></li><li><p>sessionStorage的存储大小 5MB 左右</p></li></ol><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a><strong>localStorage</strong></h3><ol><li><p>localStorage存储的数据是永久性的，不主动删除数据，数据永远存在</p></li><li><p>localStorage的存储大小 5MB 左右</p></li><li><p>sessionStorage和localStorage有增删改查的api, 例如setItem、getItem和removeItem等</p><ul><li>setItem存储value, getItem获取value, removeItem删除key, clear清除所有的key/value</li><li>web Storage不但可以用自身的setItem,getItem等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储及读取</li><li>sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历</li><li>storage只能存储字符串的数据，对于数组和对象可以用JSON来转换成字符串</li></ul></li></ol><h3 id="本地大容量存储WebSql，IndexDB"><a href="#本地大容量存储WebSql，IndexDB" class="headerlink" title="本地大容量存储WebSql，IndexDB"></a><strong>本地大容量存储WebSql，IndexDB</strong></h3><ol><li>WebSql: 关系型数据库，被W3C标准废弃</li><li>IndexDB: 非关系型数据库，大小 50MB 左右</li></ol><h3 id="浏览器缓存还有-应用缓存，PWA和往返缓存，-在这里就不描述了"><a href="#浏览器缓存还有-应用缓存，PWA和往返缓存，-在这里就不描述了" class="headerlink" title="浏览器缓存还有 应用缓存，PWA和往返缓存， 在这里就不描述了"></a><strong>浏览器缓存还有 应用缓存，PWA和往返缓存， 在这里就不描述了</strong></h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p><a href="https://segmentfault.com/a/1190000015809379#articleHeader6" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015809379#articleHeader6</a><br><a href="http://hjingren.cn/2017/04/26/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8sessionStorage%E4%B8%8ElocalStorage/" target="_blank" rel="noopener">http://hjingren.cn/2017/04/26/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8sessionStorage%E4%B8%8ElocalStorage/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sessionStorage-localStorage-cookie&quot;&gt;&lt;a href=&quot;#sessionStorage-localStorage-cookie&quot; class=&quot;headerlink&quot; title=&quot;sessionStorage, localSto
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>再读JavaScript权威指南(运算符)</title>
    <link href="http://yoursite.com/2018/09/16/JavaScript_Authoritative_Guide4/"/>
    <id>http://yoursite.com/2018/09/16/JavaScript_Authoritative_Guide4/</id>
    <published>2018-09-16T15:41:13.751Z</published>
    <updated>2018-09-27T08:45:32.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="再读JavaScript权威指南-第四章运算符"><a href="#再读JavaScript权威指南-第四章运算符" class="headerlink" title="再读JavaScript权威指南(第四章运算符)"></a>再读JavaScript权威指南(第四章运算符)</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a><strong>eval()</strong></h3><ol><li><p>eval()是一个函数，但是该语言的设计者和解析器的作则对其实施了更多的限制，使其看起来更像字符串</p></li><li><p>eval()只有一个参数，如果传入的不是字符串，他就会返回这个参数，如果是字符串，它会把字符串当作JavaScript代码进行编译</p></li><li><p>eval()最重要的是，它使用了调用它的变量的作用域，如果在最顶层的代码中调用eval()，他会作用于全局变量和全局函数</p></li><li><p>在严格模式下，eval执行的代码可以查询或更改局部变量，但不能够在局部作用域中定义新的变量或函数，严格模式中将”eval”作为保留字，这让eval更像是一个运算符</p></li></ol><h3 id="条件运算符-typeof运算符-delete运算符-void运算符-逗号运算符"><a href="#条件运算符-typeof运算符-delete运算符-void运算符-逗号运算符" class="headerlink" title="条件运算符(?:) typeof运算符 delete运算符 void运算符 逗号运算符(,)"></a><strong>条件运算符(?:) typeof运算符 delete运算符 void运算符 逗号运算符(,)</strong></h3><ol><li><p>条件运算符(?:)：JavaScript中唯一的一个三元运算符</p></li><li><p>typeof运算符：一元运算符</p></li><li><p>delete：一元操作符</p><ul><li>delete是删除不了通过var语句声明的变量，还有通过function语句定义的函数和函数参数也不能够删除</li><li>delete希望他的操作数是一个左值，如果不是左值，那么delete将不进行任何操作同时返回true</li><li>在es5严格模式中，如果delete操作数是非法的，比如变量、函数和函数参数，delete操作将抛出一个语法（SyntaxError）错误，只有操作一个属性访问表达式的时候它才会正常工作，还有删除不可配置的属性时或抛出一个类型错误，但在费严格模式下，这些delete都不会报错，只是简单地返回false   </li></ul></li><li><p>void运算符：一元运算符</p></li><li><p>逗号运算符(,)：二元运算符</p><ul><li>逗号运算符它的操作数可以使任意的类型，他首先计算左操作数，然后再计算右操作数，最后返回右操作数的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = 0, j = 1, k = 2;</span><br><span class="line"></span><br><span class="line">//计算结果是2，他和下面的代码基本上是等价的：</span><br><span class="line"></span><br><span class="line">i = 0; j = 1; k = 2;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="再读JavaScript权威指南-第五章语句"><a href="#再读JavaScript权威指南-第五章语句" class="headerlink" title="再读JavaScript权威指南(第五章语句)"></a>再读JavaScript权威指南(第五章语句)</h2><p>一个JavaScript语句无非是一个以分号分隔的语句集合，所以一旦掌握JavaScript语句，就可以编写JavaScript程序了</p><ol><li><p>表达式语句</p></li><li><p>复合语句和空语句</p></li><li><p>声明语句：var 和 function</p></li><li><p>条件语句:Javascript规定，if关键字和带圆括号的表达式之后必须跟随一条语句，但可以使用 <strong>语句块</strong> 将多条语句合并</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><ul><li>if 和 else的匹配规则是：else总是和最近的if语句匹配，为了让可读性更强应该使用 <strong>花括号</strong></li></ul></li><li><p>switch：switch中判断case值的相同使用的绝对等于（===）</p></li><li><p>循环语句：for、while、do/while、for/in</p><ul><li>for/in 只遍历可枚举的属性，也会把原型链上可枚举的属性遍历出来</li><li>如果for/in的循环体中删除了还未枚举的属性，那么这个属性不会再被枚举，如果再循环体中定义了对象的新属性，这些属性也不会被枚举到<br>document.documentElement.scrollTop</li></ul></li></ol><p>130197</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;再读JavaScript权威指南-第四章运算符&quot;&gt;&lt;a href=&quot;#再读JavaScript权威指南-第四章运算符&quot; class=&quot;headerlink&quot; title=&quot;再读JavaScript权威指南(第四章运算符)&quot;&gt;&lt;/a&gt;再读JavaScript权威指南
      
    
    </summary>
    
      <category term="JavaScript权威指南" scheme="http://yoursite.com/categories/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="JavaScript权威指南" scheme="http://yoursite.com/tags/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>BFC、margin塌陷问题</title>
    <link href="http://yoursite.com/2018/09/15/HTML_Important/"/>
    <id>http://yoursite.com/2018/09/15/HTML_Important/</id>
    <published>2018-09-15T06:23:44.094Z</published>
    <updated>2018-09-16T05:42:13.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFC、margin塌陷问题"><a href="#BFC、margin塌陷问题" class="headerlink" title="BFC、margin塌陷问题"></a><strong>BFC、margin塌陷问题</strong></h2><h3 id="块级元素、行级元素"><a href="#块级元素、行级元素" class="headerlink" title="块级元素、行级元素"></a><strong>块级元素、行级元素</strong></h3><ol><li><p>块级元素：独占一行，可以设置widh，可以设置height</p></li><li><p>行级元素：不可以设置widh，可以设置height，并且在垂直方向的 <strong>margin</strong> 会失效，<strong>padding-top</strong> 会失效</p></li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a><strong>BFC</strong></h2><ol><li><p>BFC（block ，format，context）叫做块级格式化上下文，可以简单理解为改变语法规则</p></li><li><p>如何 <strong>触发</strong> 一个盒子bfc：</p><ul><li>Position : absolute/fixed;  display : inline-block;  float : left/right         （ <strong>用于父子级，也可以用于兄弟结构之间</strong> ）</li><li>overflow : hidden;（ <strong>用于父子级的父级</strong> ）</li><li>可以解决margin塌陷问题，但是应该针对着使用，所以叫弥补不叫解决margin塌陷 </li></ul></li></ol><h3 id="margin塌陷问题"><a href="#margin塌陷问题" class="headerlink" title="margin塌陷问题"></a><strong>margin塌陷问题</strong></h3><ol><li><p>垂直方向的 margin 父子结构（或 兄弟结构 ）是结合到一起的，他俩会取 <strong>最大</strong> 的那个值</p></li><li><p>折叠的结果为：</p><ul><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li><li>两个外边距一正一负时，折叠结果是两者的 <strong>相加</strong> 的和。</li></ul></li><li><p>解决的方法有：<br>给他们加 <strong>border</strong>（不专业），还有一种叫 <strong>BFC</strong>（block ，format，context）叫做块级格式化上下文，可以简单理解为改变语法规则</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BFC、margin塌陷问题&quot;&gt;&lt;a href=&quot;#BFC、margin塌陷问题&quot; class=&quot;headerlink&quot; title=&quot;BFC、margin塌陷问题&quot;&gt;&lt;/a&gt;&lt;strong&gt;BFC、margin塌陷问题&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="html/css" scheme="http://yoursite.com/categories/html-css/"/>
    
    
      <category term="html/css" scheme="http://yoursite.com/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://yoursite.com/2018/09/14/Functional_Programming/"/>
    <id>http://yoursite.com/2018/09/14/Functional_Programming/</id>
    <published>2018-09-13T17:04:54.695Z</published>
    <updated>2018-09-17T09:43:34.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a><strong>纯函数</strong></h3><ol><li><p>纯函数是指不依赖，修改其作用域之外变量的函数（不会对外面的变量和函数产生影响的）</p></li><li><p>纯函数非常容易进行单元测试，因为不再需要考虑上下文环境，只需要考虑输入<br>和输出</p></li><li><p>纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行</p></li></ol><h3 id="函数记忆函数"><a href="#函数记忆函数" class="headerlink" title="函数记忆函数"></a><strong>函数记忆函数</strong></h3><ol><li><p>针对的是需要用到之前运算结果的，比如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var cache = &#123;&#125;;</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">    if (cache[n]) &#123;</span><br><span class="line">        return cache[n]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (n == 1 || n == 0) &#123;</span><br><span class="line">            cache[n] = 1</span><br><span class="line">            return cache[n]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cache[n] = n * factorial(n - 1)</span><br><span class="line">            return cache[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>记忆函数的封装：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function memory(fn)&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        var key = Array.prototype.join.call(arguments);</span><br><span class="line">        if(cache[key])&#123;</span><br><span class="line">            return cache[key];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cache[key] = fn.apply(this, arguments);</span><br><span class="line">            return cache[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a><strong>柯里化</strong></h3><ol><li><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p></li><li><p>前端使用柯理化的用途主要就应该是简化代码结构，提高系统的维护性，一个方法，只有一个参数，强制了功能的单一性，很自然就做到了功能内聚，降低耦合。</p></li><li><p>柯理化的优点就是降低代码的重复，提高代码的适应性</p></li><li><p><strong>调用形式</strong>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b,c)&#123;&#125; ; </span><br><span class="line">var newAdd = Curry(add);</span><br><span class="line">newAdd(1)(2)(3)</span><br></pre></td></tr></table></figure></li><li><p>柯里化函数的 <strong>封装实现</strong>：</p><ul><li><p>柯里化前奏-需要固定数量参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c, d)&#123;</span><br><span class="line">    return a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function FixedParamCurry(fn)&#123;</span><br><span class="line">    var _arg = Array.prototype.slice.call(arguments,1);</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        var newArg = _arg.concat(Array.prototype.slice.call(arguments,0));</span><br><span class="line">        return fn.apply(this, newArg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newAdd = FixedParamCurry(add, 1, 2);</span><br><span class="line">console.log(newAdd(2, 3))</span><br></pre></td></tr></table></figure></li><li><p>实现柯里化-期待固定数量参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Curry(fn, length)&#123;</span><br><span class="line">    var length = length || fn.length;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        if(arguments.length &lt; length)&#123;</span><br><span class="line">            var combined = [fn].concat(Array.prototype.slice.call(arguments, 0));</span><br><span class="line">            return Curry(FixedParamCurry.apply(this, combined), length - arguments.length);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return fn.apply(this, arguments)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用柯里化：比如在ajax中对于同一个地址参数不同的post的请求，就可以使用柯里化，<strong>流程剖析</strong>：</p><p><img src="/images/blog_images/Ajax_Curry.png" alt="image"></p></li></ul></li></ol><h3 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a><strong>惰性函数</strong></h3><ol><li><p>针对于优化频繁使用的函数</p></li><li><p>常用于，函数库的编写，单例模式之中</p></li><li><p>写一个 test 函数，这个函数返回首次调用时的 new Date().getTime()时间，注意是首次。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var test = function ()&#123;</span><br><span class="line">    var t;</span><br><span class="line">    t = new Date().getTime();</span><br><span class="line">    test = function ()&#123;</span><br><span class="line">        return t</span><br><span class="line">    &#125;</span><br><span class="line">    return test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>惰性函数应用：事件函数的封装 、 滚动条偏移量函数的封装 、 jQuery函数库的封装</p></li></ol><h3 id="函数组合应用"><a href="#函数组合应用" class="headerlink" title="函数组合应用"></a><strong>函数组合应用</strong></h3><ol><li><p>函数的组合应用（自右向左，自内向外依次执行），是一种高阶函数的思想</p></li><li><p>封装实现：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function compose()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    var len = args.length - 1;</span><br><span class="line">    return function (x)&#123;</span><br><span class="line">        var result = args[len](x);</span><br><span class="line">        while(len --)&#123;</span><br><span class="line">            result = args[len](result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 数组reduceRight的实现方法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function compose()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    return function (x)&#123;</span><br><span class="line">        return args.reduceRight(function (res, cb)&#123;</span><br><span class="line">            return cb(res);</span><br><span class="line">        &#125;, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">es6写法</span><br><span class="line"></span><br><span class="line">const compose = (...args) =&gt; x =&gt; args.reduceRight((res, cb) =&gt; cb(res), x)</span><br></pre></td></tr></table></figure><p> 从左向右依次执行的实现方法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function compose()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    return function (x)&#123;</span><br><span class="line">        return args.reduce(function (res, cb)&#123;</span><br><span class="line">            return cb(res);</span><br><span class="line">        &#125;, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Js必会数据处理之扁平化"><a href="#Js必会数据处理之扁平化" class="headerlink" title="Js必会数据处理之扁平化"></a><strong>Js必会数据处理之扁平化</strong></h3><ol><li><p>可以用在后台给出的数据来进行处理<br>主要用在两大方面一个是 <strong>数组</strong>（是一个降维，多维数组通过扁平化变为一维数组），一个是 <strong>对象</strong>（深度很深的对象经过扁平化编程深度为1的对象）</p></li><li><p>函数封装的实现</p><ul><li><p><strong>方法1</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.flatter = function ()&#123;</span><br><span class="line">    var resArr = [];</span><br><span class="line">    this.forEach(function (item)&#123;</span><br><span class="line">        Object.prototype.toString.call(item) == &apos;[object Array]&apos; ? resArr = resArr.concat(this.flatter()) : resArr.push(item)</span><br><span class="line">    &#125;) </span><br><span class="line">    return resArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.flatter = function ()&#123;</span><br><span class="line">    return this.reduce(function (prev, item)&#123;</span><br><span class="line">        return Object.prototype.toString.call(item) == &apos;[object Array]&apos; ? prev.concat(item.flatter()) : prev.push(item);</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h2&gt;&lt;h3 id=&quot;纯函数&quot;&gt;&lt;a href=&quot;#纯函数&quot; class=&quot;headerlink&quot; title=&quot;纯函数&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="函数式编程" scheme="http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>再读JavaScript权威指南（词法结构、类型、值、变量）</title>
    <link href="http://yoursite.com/2018/09/13/JavaScript_Authoritative_Guide2_3/"/>
    <id>http://yoursite.com/2018/09/13/JavaScript_Authoritative_Guide2_3/</id>
    <published>2018-09-12T17:16:43.710Z</published>
    <updated>2018-09-17T16:32:38.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-权威指南（第二章词法结构）"><a href="#JavaScript-权威指南（第二章词法结构）" class="headerlink" title="JavaScript 权威指南（第二章词法结构）"></a>JavaScript 权威指南（第二章词法结构）</h2><h3 id="JavaScript结尾分号的问题"><a href="#JavaScript结尾分号的问题" class="headerlink" title="JavaScript结尾分号的问题"></a><strong>JavaScript结尾分号的问题</strong></h3><ol><li><p>JavaScript 并不会在所有的换行处填补分号，只有在缺少分号就无法正确解析的时候，JavaScript 才会填补分号。换句话讲如果 <strong>当前语句</strong> 和 <strong>随后的的非空格字符</strong> 不能当一个整体来解析的话，JavaScript 就会在当前语句行的结束处填补分号。</p></li><li><p>有两个例外</p><ul><li><p>第一个例外是在涉及 <strong>return</strong>、<strong>break</strong> 和 <strong>continue</strong> 语句的场景中。如果这三个关键词后紧跟着换行，JavaScript则会在换行处填补分号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">return</span><br><span class="line">true;</span><br><span class="line"></span><br><span class="line">//JavaScript会解析成：</span><br><span class="line"> </span><br><span class="line"> return; true;</span><br><span class="line"></span><br><span class="line">//  而代码的本意是这样：</span><br><span class="line"></span><br><span class="line">return true;</span><br></pre></td></tr></table></figure></li><li><p>第二个例外是在涉及 <strong>++</strong>、<strong>–</strong> 运算符的时候，这些运算符可以作为表达式的前缀，也可作为表达式的后缀。如果做后缀，他和表达式应该在同一行，否则行尾将增加分号，同时 ++、– 将作为下一行代码的前缀操作符并与其一起解析，<strong>例如</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">++</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">//这段代码的解析为 “ x; ++y;” ,而不是 “ x++; y”</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="JavaScript-权威指南（第三章类型，值，变量）"><a href="#JavaScript-权威指南（第三章类型，值，变量）" class="headerlink" title="JavaScript 权威指南（第三章类型，值，变量）"></a>JavaScript 权威指南（第三章类型，值，变量）</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><ol><li><p>能够表示并操作的值的类型称做 <strong>数据类型</strong> ，变量是一个值的符号名称，可以通过名称来获得对值的引用</p></li><li><p>javaScript数据类型分为两类：<strong>原始类型</strong> 和 <strong>对象类型</strong> ，也可分为 <strong>可变类型</strong> 和 <strong>不可变类型</strong> ，null和undefined是两个特殊的原始值（是无法拥有方法的值），函数和数组是特殊的对象</p><ul><li>原始类型/不可变类型：数字，字符串，布尔值，null，undefined</li><li>对象类型/可变类型：对象</li></ul></li></ol><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a><strong>字符串类型</strong></h3><ol><li><p>在 <strong>es5</strong> 中字符串的直接量可以拆分成数行，每行必须以反斜线（\）结束</p></li><li><p><strong>JavaScript转义字符表</strong>：</p><p> <img src="/images/blog_images/Escape_Character1.png" alt="image"><br> <img src="/images/blog_images/Escape_Character2.png" alt="image"></p></li><li><p><strong>字符串方法</strong>：</p><p> <img src="/images/blog_images/String_Methods.png" alt="image"><br> <img src="/images/blog_images/String_Methods2.png" alt="image"></p><ul><li>在JavaScript中字符串是固定不变的，类似replace()和toUpperCase()的方法都返回新字符串，原字符串本身并没有变化</li></ul></li></ol><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a><strong>数字类型</strong></h3><ol><li><p>JavaScript支持 <strong>十进制</strong> ，<strong>十六进制</strong> ，对于八进制是有些支持，有些不支持，但在es6的严格模式下，八进制是禁止的</p></li><li><p>可以使用 <strong>指数计数法</strong> 来表示浮点型直接量，即在实数后面跟字母e或E，后面再跟<br>正负号，其后再加一个整型的整数</p></li><li><p>JavaScript的算术运算在溢出、下溢或被0整除时不报错，<strong>0/0 = NaN</strong>， <strong>Infinity/Infinity = NaN</strong>，Infinity和NaN在es3中可读写，在es5中只可读，在es3中 <strong>Number</strong> 的属性值也是只读的,</p></li><li>判断 <strong>NaN</strong> 和 <strong>infinity</strong> 的有两个函数：isNaN() 和 isInfinite()</li><li><p>关于 <strong>二进制浮点数精度不准</strong> 的解释：</p><ul><li>JavaScript采用了 <strong>IEEE-754</strong> 浮点数表示法（几乎现代所有编程语言所采用），这是一种<strong>二进制表示法</strong>，可以精确地表示分数，比如 1/2、1/81 和 /1024。遗憾的是，我们常用的分数（特别是在金融计算方面的）都是 <strong>十进制分数</strong> 1/10、1/100等。<strong>二进制浮点数</strong> 表示法不能够精确表示类似0.1这样简单的数字。</li><li>JavaScript中的数字具有足够的精度，并可以及其近似 <strong>0.1</strong>。但事实是，数字不能精确</li></ul></li></ol><h3 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a><strong>Math对象的属性</strong></h3><p><img src="/images/blog_images/Math_Methods.png" alt="image"></p><h3 id="日期与时间函数Date-简单的教程"><a href="#日期与时间函数Date-简单的教程" class="headerlink" title="日期与时间函数Date()简单的教程"></a><strong>日期与时间函数Date()简单的教程</strong></h3><p><img src="/images/blog_images/Date_Methods.png" alt="image"></p><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a><strong>RegExp</strong></h3><ol><li><p>RegExp对象定义了很多很有用的方法，字符串同样可以具有接收RegExp参数的方法，<strong>例如</strong>：</p><p> <img src="/images/blog_images/RegExp.png" alt="image"></p></li></ol><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a><strong>Boolean</strong></h3><ol><li><p>下面这些值会被转化成 <strong>false</strong>:                       <strong>undefined</strong>、<strong>null</strong>、<strong>0</strong>、<strong>-0</strong>、<strong>NaN</strong>、<strong>“”</strong></p></li><li><p>Boolean原型上有 <strong>toString()</strong> 方法(除了这个，还有一个方法是 <strong>valueOf()</strong>，再没有别的方法了)，可以使用这个方法将布尔值转换为字符串 <strong>“true”</strong> 或 <strong>“false”</strong></p></li><li><p>三个重要的布尔运算符：<strong>&amp;&amp;</strong> 、<strong>||</strong> 、<strong>!</strong></p></li></ol><h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a><strong>null 和 undefined</strong></h3><ol><li><p>null是JavaScript的 <strong>关键字</strong>，他表示一个特殊值，常用来描述 <strong>空值</strong>, <strong>typeof null 等于 “object”</strong>, 但他实际上不是一个对象， 通常认为 <strong>null</strong> 是它自有类型的唯一一个成员</p></li><li><p>undefined是预定义的 <strong>全局变量</strong>（他和null不一样，他不是关键字），它的值就是 <strong>“未定义”</strong>，在es3中undefined是 <strong>可读/写</strong> 的变量，可以给他赋任意值，但在es5中undefinde <strong>只读</strong>，使用typeof运算符得到的是 “undefined” ，是undefined类型 undefined使这个类型的唯一成员</p></li><li><p>null 和 undefined 相等于（====），但不严格等于（=====）</p></li><li><p>null 和 undefined 都不包括任何的 <strong>属性</strong> 和 <strong>方法</strong>，使用 “.” 和 [] 来存取这两个值的成员和方法都会产生一个类型错误</p></li><li><p>如果你想将他们赋值给 <strong>变量</strong> 或者 <strong>属性</strong>，或将他们作为 <strong>参数</strong> 传入函数，最佳的选择是使用 <strong>null</strong></p></li></ol><h3 id="全局对象-、包装对象、值的比较"><a href="#全局对象-、包装对象、值的比较" class="headerlink" title="全局对象 、包装对象、值的比较"></a><strong>全局对象 、包装对象、值的比较</strong></h3><ol><li><p>当JavaScript解析器启动时（或者任何一个Web浏览器家在新页面的时候），它将创建一个新的全局对象，并给他一组定义的初始属性：全局属性、全局对象、全局函数、构造函数</p></li><li><p>包装对象注意的两点：</p><ul><li><p>当一个字符串引用是一属性时，会被JavaScript将字符串通过new String()的方式转换成 <strong>临时对象</strong>，一旦引用结束，这个临时对象就会销毁</p></li><li><p>JavaScript会在必要时将包装对象转换成原始值（但不总是）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;xixi&apos;;</span><br><span class="line">var str1 = new String(str);</span><br><span class="line">console.log(str == str1)    //true</span><br></pre></td></tr></table></figure></li></ul></li><li><p>原始值的比较是 <strong>值</strong> 的比较，对象的比较是 <strong>引用</strong> 的比较</p></li></ol><h3 id="字符串到对象的转换：toSting-valueOf"><a href="#字符串到对象的转换：toSting-valueOf" class="headerlink" title="字符串到对象的转换：toSting(), valueOf()"></a><strong>字符串到对象的转换：toSting(), valueOf()</strong></h3><ol><li><p>以下数组类、函数类、日期类、RegExp类的 <strong>toString()</strong> 方法</p><p> <img src="/images/blog_images/Different_ToString.png" alt="image"></p></li><li><p><strong>valueof()</strong>:</p><p> 调用valueOf()函数时，如果对象存在任意的原始值（比如包装类对象），他就默认将对象转化为表示他的原始值，大对数的对象无法真正表示一个原始值，因此默认的valueOf()方法返回对象本身（如： 数组、函数、正则表达式），日期类定义的返回它的一个内部表示：1970年1月1日依赖的毫秒数</p></li><li><p>JavaScript从 <strong>对象到字符串的转换</strong> 经过以下步骤：</p><ul><li>如果对象具有toString()方法的话，则调用这个方法，如果返回的一个原始值，JavaScript会将它转化为字符串（如果本身不是字符串的话），并返回这个字符串结果</li><li>如果没有toString()方法，或者这个方法返回一个原始值，JavaScript就会调用valueOf()方法（前提是存在）如果返回的一个原始值，JavaScript会将它转化为字符串（如果本身不是字符串的话）</li><li>对象转换成数字的过程，JavaScript做了同样的事情，只是他首先会尝试valueOf()方法</li></ul></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><ol><li><p>编程语言分为 <strong>动态类型语言</strong> 和 <strong>静态类型</strong> 语言</p><ul><li>动态类型语言：是指在运行期间才去做数据类型的检查的语言，如JavaScript、Python、Ruby</li><li>静态编程语言：是指数据类型在编译期间检查的，如C/C++、C#、Java</li></ul></li><li><p>当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除，在非严格模式下，未声明的变量会变成全局变量，这个变量是可以配置的，可以删除他们</p></li></ol><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><ol><li><p>作用域链是一对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript查找变量的时候x时候，如果当前对象有x的值，则使用这个值，如果没有则从当前对象依次向上查找</p></li><li><p>当定义一个函数时，它实际上保存着一个作用域链，当调用这个函数式，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的作用域链上，同时创建一个新的更长的表示函数调用作用域的链</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p>《JavaScript权威指南》第六版  David Flanagan 著</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-权威指南（第二章词法结构）&quot;&gt;&lt;a href=&quot;#JavaScript-权威指南（第二章词法结构）&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 权威指南（第二章词法结构）&quot;&gt;&lt;/a&gt;JavaScript 权威指
      
    
    </summary>
    
      <category term="JavaScript权威指南" scheme="http://yoursite.com/categories/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="JavaScript权威指南" scheme="http://yoursite.com/tags/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（树）</title>
    <link href="http://yoursite.com/2018/09/12/Data_Structure/"/>
    <id>http://yoursite.com/2018/09/12/Data_Structure/</id>
    <published>2018-09-12T08:36:39.116Z</published>
    <updated>2018-10-12T08:02:29.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构（树）"><a href="#数据结构（树）" class="headerlink" title="数据结构（树）"></a>数据结构（树）</h2><h3 id="树（二叉树）"><a href="#树（二叉树）" class="headerlink" title="树（二叉树）"></a><strong>树（二叉树）</strong></h3><ol><li><p><strong>树</strong> 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合</p></li><li><p>树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有 <strong>N</strong> 个节点和 <strong>N-1</strong> 条边的一个有向无环图</p></li><li><p><strong>二叉树</strong> 是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“ <strong>左子树</strong> ”和“ <strong>右子树</strong> ”。</p><ul><li><p>完全二叉树：除了最后一层，所有层的节点数达到最大，与此同时，最后一层的所有节点都在最左侧</p></li><li><p>满二叉树：所有层的节点数达到最大</p></li><li><p>平衡二叉树：每一个节点的左右子树的高度差不超过1</p></li></ul></li><li><p>本章目标：</p><ul><li>理解和区分树的遍历方法</li><li>能够运用 <strong>递归</strong> 方法解决树的为前序遍历、中序遍历和后序遍历问题</li><li>能用运用 <strong>迭代</strong> 方法解决树的为前序遍历、中序遍历和后序遍历问题</li><li>能用运用 <strong>广度优先</strong> 搜索解决树的层序遍历问题 </li></ul></li><li><p>二叉树的结构图</p><p> <img src="/images/blog_images/Two_forked_tree.png" alt="image"></p><ul><li>这幅图中有如下概念：<ul><li>根节点：一棵树最顶部的节点</li><li>内部节点：在它上面还有其它内部节点或者叶节点的节点</li><li>叶节点：处于一棵树根部的节点</li><li>子树：由树中的内部节点和叶节点组成</li></ul></li><li>它也是二叉搜索树（左侧子节点的数字小于父节点，右侧子节点的数字大于父节点）</li></ul></li></ol><h3 id="二叉树的实现-介绍"><a href="#二叉树的实现-介绍" class="headerlink" title="二叉树的实现 - 介绍"></a><strong>二叉树的实现 - 介绍</strong></h3><ol><li><p>二叉树的表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">function BinarySearchTree() &#123;</span><br><span class="line">    var Node = function (key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.left = null;</span><br><span class="line">        this.right = null;</span><br><span class="line">    &#125;</span><br><span class="line">    var root = null;</span><br><span class="line">    var size = 0;</span><br><span class="line">    this.insert = function (key) &#123;      //插入元素</span><br><span class="line">        root = add(root, node);</span><br><span class="line">    &#125;</span><br><span class="line">    this.getNode = function () &#123;        //打印二叉搜索树</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    this.contain = function (key) &#123;     //查看是否存在元素</span><br><span class="line">        search(root, key)</span><br><span class="line">    &#125;</span><br><span class="line">    this.preOrderTraverse = function () &#123;       //前序遍历</span><br><span class="line">        preOrderTraverse(root);                 </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.inOrderTraverse = function () &#123;        //中序遍历</span><br><span class="line">        inOrderTraverse(root);                 </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.postOrderTraverse = function () &#123;      //后续遍历  可以应用在释放内存 </span><br><span class="line">        postOrderTraverse(root);                 </span><br><span class="line">    &#125;   </span><br><span class="line">    this.levelOrder = function()&#123;       //层序遍历</span><br><span class="line">        levelOrder(root)</span><br><span class="line">    &#125;</span><br><span class="line">    this.min = function()&#123;      //返回最小值</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            var node = root;</span><br><span class="line">            while(node.left)&#123;</span><br><span class="line">                node = node.left</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.max = function()&#123;      //返回最大值</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            var node = root;</span><br><span class="line">            while(node.right)&#123;</span><br><span class="line">                node = node.right</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.removeMin = function()&#123;      //删除最小值</span><br><span class="line">        removeMin(root);</span><br><span class="line">        return this.min();</span><br><span class="line">    &#125;</span><br><span class="line">    function removeMin(node)&#123;</span><br><span class="line">        if(node)&#123;</span><br><span class="line">            if(node.left == null)&#123;</span><br><span class="line">                size--;</span><br><span class="line">                node.right = null;</span><br><span class="line">                return node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            node.left = removeMin(node.left);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    this.removeMax = function()&#123;      //删除最大值</span><br><span class="line">        removeMax(root);</span><br><span class="line">        return this.max(root);</span><br><span class="line">    &#125;</span><br><span class="line">    function removeMax(node)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function add(root, node) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        return new Node(key);</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.key &lt; root.key) &#123;</span><br><span class="line">        root.left = add(root.left, node);</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.key &gt; root.key) &#123;</span><br><span class="line">        root.right = add(root.right, node);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>搜索元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function search(node, key) &#123;</span><br><span class="line">    if (!root) return false;</span><br><span class="line">    if (root.key === key) return true;</span><br><span class="line">    if (root.key &gt; key) return search(root.left, key);</span><br><span class="line">    if (root.key &lt; key) return search(root.right, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前序遍历： 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p><p> <strong>递归：</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">function preOrderTraverse(node, arr = [])&#123;</span><br><span class="line">    if(node)&#123;</span><br><span class="line">        arr.push(node.key);</span><br><span class="line">        preOrderTraverse(node.left, arr);</span><br><span class="line">        preOrderTraverse(node.right, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>非递归方法(利用栈)，比递归实现复杂，中序遍历和后续遍历的非递归实现更复杂，实际应用也不广</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this.preOrderTraverseNR = function () &#123;</span><br><span class="line">    var stack = [];</span><br><span class="line">    var result = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">        var node = stack.pop()</span><br><span class="line">        result.push(node);</span><br><span class="line">        if(node.right)&#123;</span><br><span class="line">            stack.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left)&#123;&#125;</span><br><span class="line">            stack.push(node.left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历： 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。（通常来说，对于<strong>二叉搜索树</strong>，我们可以通过中序遍历得到一个递增的有序序列）</p><p> <strong>递归：</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">function inOrderTraverse(node, arr = [])&#123;</span><br><span class="line">    if(node)&#123;</span><br><span class="line">        inOrderTraverse(node.left, arr);</span><br><span class="line">        arr.push(node.key);</span><br><span class="line">        inOrderTraverse(node.right, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历： 后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。（值得注意的是，当你<strong>删除树中的节点</strong>时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。）</p><p> <strong>递归：</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">function postOrderTraverse(node, arr = [])&#123;</span><br><span class="line">    if(node)&#123;</span><br><span class="line">        postOrderTraverse(node.left, arr);</span><br><span class="line">        postOrderTraverse(node.right, arr);</span><br><span class="line">        arr.push(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层序遍历（递归）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">/ \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var levelOrder = function(node, index = 0, stack = []) &#123;</span><br><span class="line">    if(node)&#123;</span><br><span class="line">        if(!stack[index])&#123;</span><br><span class="line">           stack[index] = []; </span><br><span class="line">        &#125; </span><br><span class="line">        stack[index].push(node.val);</span><br><span class="line">        levelOrder(node.left, index + 1, stack);</span><br><span class="line">        levelOrder(node.right, index + 1, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    return stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>另外，后序在数学表达中被广泛使用。 编写程序来 <strong>解析后缀表示法</strong> 更为容易。 这里是一个例子：</p><p> <img src="/images/blog_images/mathematical_expression.png" alt="image"></p><p> 您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。</p><p> 如果你想对这棵树进行后序遍历，使用 <strong>栈</strong> 来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p></li></ol><h3 id="层序遍历-介绍"><a href="#层序遍历-介绍" class="headerlink" title="层序遍历 - 介绍"></a><strong>层序遍历 - 介绍</strong></h3><ol><li><p>层序遍历就是逐层遍历树结构。</p></li><li><p><strong>广度优先搜索</strong> 是一种广泛运用在 <strong>树</strong> 或 <strong>图</strong> 这类数据结构中， <strong>遍历</strong> 或 <strong>搜索</strong> 的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。</p></li><li><p>当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。</p></li><li><p>通常，我们使用一个叫做 <strong>队列</strong> 的数据结构来帮助我们做广度优先搜索</p></li></ol><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p><a href="https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构（树）&quot;&gt;&lt;a href=&quot;#数据结构（树）&quot; class=&quot;headerlink&quot; title=&quot;数据结构（树）&quot;&gt;&lt;/a&gt;数据结构（树）&lt;/h2&gt;&lt;h3 id=&quot;树（二叉树）&quot;&gt;&lt;a href=&quot;#树（二叉树）&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>再读JavaScript权威指南（函数）</title>
    <link href="http://yoursite.com/2018/09/11/JavaScript_Authoritative_Guide8/"/>
    <id>http://yoursite.com/2018/09/11/JavaScript_Authoritative_Guide8/</id>
    <published>2018-09-11T02:11:08.608Z</published>
    <updated>2018-09-13T16:11:31.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-权威指南（第八章函数）"><a href="#JavaScript-权威指南（第八章函数）" class="headerlink" title="JavaScript 权威指南（第八章函数）"></a>JavaScript 权威指南（第八章函数）</h2><h3 id="顶级语句：函数声明"><a href="#顶级语句：函数声明" class="headerlink" title="顶级语句：函数声明"></a><strong>顶级语句：函数声明</strong></h3><ol><li><p>美元符号和下划线是除了字母和数字以外的两个合法的javaScript标识符</p></li><li><p>函数声明语句并非真正的语句，ECMAScript规范只是允许它们作为顶级域名。它们可以出现在全局代码里，或者内嵌在其他的函数中，但是他们不能够出现在<strong>循环、条件判断、或者try/cache/finnally/以及width</strong>语句中。注意，此限制仅用于语句声明的形式定义的函数。<strong>函数定义表达式可以出现在javaScript代码的任何地方</strong></p></li><li><p><strong>*补充：</strong></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a) &#123;</span><br><span class="line">    var b = 123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">c</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//虽然不允许在<span class="keyword">if</span>定义函数声明，但是现代的浏览器不报错，</span><br><span class="line">//而且在预编译过程中，c为undefined（老版本的IE可以存在c预编译为<span class="keyword">function</span> <span class="function"><span class="title">c</span></span>()&#123;&#125;）</span><br></pre></td></tr></table></figure><h3 id="函数表达式本身就是一个属性访问表达式"><a href="#函数表达式本身就是一个属性访问表达式" class="headerlink" title="函数表达式本身就是一个属性访问表达式"></a><strong>函数表达式本身就是一个属性访问表达式</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.m(x, y)</span><br></pre></td></tr></table></figure><ol><li>上面的代码是一个调用的表达式，它包括一个函数表达式o.m，以及两个是实参表达式x和y，函数表达式本身就是一个<strong>属性访问表达式</strong>，这意味着该函数被当做一个<strong>方法</strong>，而不是作为一个普通函数来调用。</li></ol><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><strong>arguments</strong></h3><ol start="2"><li><p>arguments数组对象的数组元素是函数形参所对应实参额别名，实参对象一数字为索引，并且形参名称可以认为是相同变量的不同命名。即两个的值是互通的，<strong>只要这其中一个改变那么另外一个就跟着改变</strong>，但是在es5的严格模式中这一特性就不存在了，而且在非严格模式中函数中的arguments是一个<strong>标识符</strong>，而在严格模式中它变成了一个<strong>保留字</strong>，严格模式中函数无法使用arguments作为形参或局部变量，也不能够给arguments赋值</p></li><li><p>arguments并不是一个<strong>关键字</strong>，但在调用每个函数时都会自动声明它</p></li><li><p><strong>*补充：</strong></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"use strict"</span></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(a)&#123;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(a);//1,如果没有严格模式这里的输出是2</span><br><span class="line">    console.log(arguments[0])//2</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(1);</span><br></pre></td></tr></table></figure><h3 id="8-7-函数属性、方法、构造函数"><a href="#8-7-函数属性、方法、构造函数" class="headerlink" title="8.7 函数属性、方法、构造函数"></a><strong>8.7 函数属性、方法、构造函数</strong></h3><ol><li><p>一个名为test函数，<strong>test.length</strong>和函数呢内<strong>argument.callee.length</strong>指的是函数形参的个数，<strong>argument.length</strong>指的是实参的个数</p></li><li><p>Call和apply的区别是传参形式不同，call是第一个参数之后的参数就是执行函数传入的实参，而apply的的第二个参数传入的<strong>真实数组</strong>或者<strong>类数组对象</strong>，对象里面的元素就是函数执行传入的实参</p></li><li><p>Call和apply的使用相当于如下代码，根据此可以封装一个call和apply</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f.call(o);</span><br><span class="line">f.apply(o);</span><br><span class="line"></span><br><span class="line">//每行的代码和下面代码的功能类似（假设对象中预先不存在名为m的属性）</span><br><span class="line"></span><br><span class="line">o.m = f;    //将m存储为临时的方法</span><br><span class="line">o.m();      //调用它不传入参数</span><br><span class="line">delete o.m; //将临时方法删除</span><br></pre></td></tr></table></figure><p><strong>*call的封装实现</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.newCall = function () &#123;</span><br><span class="line">            var ctx = arguments[0] || window;</span><br><span class="line">            ctx.fn = this;</span><br><span class="line">            var args = [];</span><br><span class="line">            for (var i = 1; i &lt;= arguments.length; i++) &#123;</span><br><span class="line">                args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class="line">            delete ctx.fn;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>*apply的封装实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.newApply = function (ctx, arr) &#123;</span><br><span class="line">    var ctx = ctx || window;</span><br><span class="line">    ctx.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    if (arr) &#123;</span><br><span class="line">        console.log(&apos;haha&apos;)</span><br><span class="line">        for (var i = 0; i &lt;= arr.length; i++) &#123;</span><br><span class="line">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var result = ctx.fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete ctx.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>在ECMAScript 5的严格模式中，<strong>call和apply的第一个实参都会变成this的值</strong>，哪怕传入的实参是原始值甚至是undefined和null。在es3和非严格模式中，<strong>传入的null和undefined都会被全局所代替</strong>，而其他原始值则会被相应的包装对象（wrapper bject）所代替</p></li><li><p>bind是es5新增的方法</p></li></ol><p>bind的封装实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.newBind = function (target) &#123;</span><br><span class="line">    target = target || window;</span><br><span class="line">    var self = this;</span><br><span class="line">    var arg = [].slice.call(arguments, 1);</span><br><span class="line">    var Temp = function () &#123; &#125;;</span><br><span class="line">    var F = function () &#123;</span><br><span class="line">        var _arg = [].slice.call(arguments, 0);</span><br><span class="line">        return self.apply(this instanceof Temp ? this : target, arg.concat(_arg));</span><br><span class="line">    &#125;</span><br><span class="line">    Temp.prototype = this.prototype;</span><br><span class="line">    F.prototype = new Temp(); //将F函数的的原型跟调用newBind 函数的原型一样（就是将函数F变得跟调用newBind 的函数一样）</span><br><span class="line"></span><br><span class="line">    return F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>和所有的javaScript对象一样，函数也有toString()方法，ECMAScript规范规定这个方法返回一个字符串，这字符串和函数声明语句的的语法相关。实际上，大多数（非全部）的toString()方法实现都返回函数的完整源码。<strong>内置函数往往返回一个类似”[native code]”的字符串作为函数体</strong></li></ol><p>*如下(使用的是浏览器自带的开发者工具)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; function test()&#123;var c = &apos;i&apos;&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; test.toString()</span><br><span class="line">&quot;function test()&#123;var c = &apos;i&apos;&#125;&quot;</span><br><span class="line">&gt; Object.toString()</span><br><span class="line">&quot;function Object() &#123; [native code] &#125;&quot;</span><br><span class="line">&gt; Date.toString()</span><br><span class="line">&quot;function Date() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure><ol start="7"><li>不管是通过函数定义的语句还是函数直接量的表达式，函数的定义都要使用function关键字。但是函数还可以<strong>通过Function()构造函数来定义</strong>，比如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);</span><br><span class="line"></span><br><span class="line">//这行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价</span><br><span class="line"></span><br><span class="line">var f = function (x,y)&#123; return x*y; &#125;</span><br></pre></td></tr></table></figure><p>注意：Function()构造函数并不需要通过传入实参以指定函数名。就想函数直接量一样，Function()构造函数创建一个匿名函数。还有用Function()构造函数创建的函数并不是使用<strong>词法作用域</strong>，相反，函数体代码的编译总是会到顶部函数执行。</p><p>我们可以将Function()构造函数认为是在全局作用域中执行的eval(),eval()可以在自己的私有作用域内定义新变量和函数，Function()构造函数在实际编程中很少会用到。</p><h3 id="8-8-函数式编程"><a href="#8-8-函数式编程" class="headerlink" title="8.8 函数式编程"></a><strong>8.8 函数式编程</strong></h3><ol><li><p>使用函数处理数组</p></li><li><p>高阶函数：所谓的高阶函数就是操作函数的函数，它接受一个或多个函数作为参数，并返回一个新函数</p></li><li><p>不完全函数：那一次完整的函数调用拆成对此函数调用，每次传入的参数都是完整参数的一部分，每一个拆分出的函数叫做不完全函数，每次函数调用叫做不完全调用，被称为柯里化</p></li><li><p>记忆：记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度换取更优的时间复杂度</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p>《JavaScript权威指南》第六版  David Flanagan 著</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-权威指南（第八章函数）&quot;&gt;&lt;a href=&quot;#JavaScript-权威指南（第八章函数）&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 权威指南（第八章函数）&quot;&gt;&lt;/a&gt;JavaScript 权威指南（第八章函
      
    
    </summary>
    
      <category term="JavaScript权威指南" scheme="http://yoursite.com/categories/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="JavaScript权威指南" scheme="http://yoursite.com/tags/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>从Event Loop谈JS的运行机制</title>
    <link href="http://yoursite.com/2018/09/10/Event-Loop/"/>
    <id>http://yoursite.com/2018/09/10/Event-Loop/</id>
    <published>2018-09-10T07:40:04.000Z</published>
    <updated>2018-09-10T08:41:48.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h2><blockquote><h3 id="javaScript引擎是单线程"><a href="#javaScript引擎是单线程" class="headerlink" title="javaScript引擎是单线程"></a><strong>javaScript引擎是单线程</strong></h3></blockquote><ul><li><p>我们都知道javaScript引擎是单线程，为什么不是多线程的呢？想下javaScript的主要作用是用户的互动和DOM的操作，假定javaScript有多个线程，一个线程在DOM节点上添加，同时另一个线程在这时删除这一个节点，这时浏览器应该以哪个线程为主呢？这就会导致很复杂的同步问题。</p></li><li><p>还有一个就是HTML5提出的Web Worker的标准，允许javaScript引擎创建多个子线程，利用多核cpu的计算能力，但是子线程是浏览器开的，完全由主线程控制，而且不能操作DOM，javaScript引擎线程与worker线程间是通过特定的方式通信的（postMessageAPI，需要通过序列化对象来与线程交互特定的数据）</p></li></ul><p><strong>对于Web Worker MDN的官方解释是：</strong></p><p> Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面，一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件，这个文件包含将在工作线程中运行的代码; workers运行在另一个全局上下文中,不同于当前的window。因此，使用window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误**</p><ul><li>所以针对大量计算问题非常耗时的工作时，请单独开一个Worker线程，不管这个线程里面发生什么样翻天覆地的变化都不会影响多javaScript主线程，只待计算结果出来之后，将结果通信给主线程，所以javaScript引擎是单线程的这一本质一点都没变（其实还有一个sharedWorker,这里就不做介绍了）</li></ul><blockquote><h3 id="javaScript运行机制"><a href="#javaScript运行机制" class="headerlink" title="javaScript运行机制"></a><strong>javaScript运行机制</strong></h3></blockquote><ul><li>js执行任务分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务都在主线程中执行，形成一个执行栈，主线程之外还有一个任务队列（task queue），任务队列是<strong>事件触发线程</strong>管理的，只要异步任务有运行结果时，就会在任务队列中放置一个事件</li><li>一旦执行栈中所有的同步任务执行完毕后，系统就才会去读取任务队列，将任务放入到执行栈中执行（<strong>任务队列是一个先进先出的数据结构</strong>）</li></ul><p>下图是主线程和任务队列的示意图（图片来自参考资料2中）<br><img src="/images/blog_images/js_event_loop.png" alt="image"></p><p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复</p><blockquote><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a><strong>事件循环机制</strong></h3></blockquote><p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href="https://vimeo.com/96425312" target="_blank" rel="noopener">Help, I’m stuck in an event-loop</a>》，图片来自参考资料2中）<br><img src="/images/blog_images/js_event_loop2.png" alt="image"></p><ul><li><p>上述循环机制的核心是：<strong>js引擎线程</strong>和<strong>事件触发线程</strong></p></li><li><p>主线程运行时会产生执行栈，栈中的调用某些api时，当满足触发条件后，会将事件放入到事件队列中去</p></li><li><p>但是对于定时器（<strong>setTimeout和setInterval</strong>）来说它是通过<strong>定时器引擎线程</strong>来控制回调函数在等待特定的时间后添加到事件队列中</p></li></ul><p>定时器要注意的一点就是设置的时间间隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">console.log(&apos;1&apos;);</span><br><span class="line">//执行结果是 先 “1” 后 “2”</span><br></pre></td></tr></table></figure><p>虽然上述的代码中设置的时间间隔是0，但是根据W3C的HTML标准中的规定定时器最小的时间间隔不得低于4ms，低于4ms的间间隔算为4ms，即使是按0ms来，还是会先执行“1”，因为事件队列中任务总是要等到主线程执行完了之后才执行</p><blockquote><h3 id="setTimeOut和setInterval在事件循环机制中的区别"><a href="#setTimeOut和setInterval在事件循环机制中的区别" class="headerlink" title="setTimeOut和setInterval在事件循环机制中的区别"></a><strong>setTimeOut和setInterval在事件循环机制中的区别</strong></h3></blockquote><ul><li><p>主线程设置一个定时器后，setInterval在每个一段时间都会执行一个回调函数（回调函数就会被定时器引擎线程放入到事件队列中去），但是当主线程执行时间很长（时间大于好几个setInterval设置的时间间隔），那么事件队列中就会存在有好几个setInterval的回调函数，在主线程执行完后去执行事件队列中的事件，那么堆叠着的定时器回调函数就会连续执行（累计效应），setTimeOut没有这样的问题</p></li><li><p>还有一种情况就是把浏览器最小化后，setInterval并不是不执行程序，回调函数还是会被放到事件队列中去，但是不会被执行，当浏览器打开以后，这些回调函数就会被一起全部执行</p></li><li><p>所以最好的方法就是用setTimeOut来模拟setInterval，或者用requestAnimationFrame</p></li><li><p><strong>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。</strong></p></li></ul><blockquote><h3 id="事件循环进阶：macrotask与microtask"><a href="#事件循环进阶：macrotask与microtask" class="headerlink" title="事件循环进阶：macrotask与microtask"></a><strong>事件循环进阶：macrotask与microtask</strong></h3></blockquote><ul><li>上面讲的事件循环机制在es5中的情况是够用了，但是es6中就会遇到一些问题了</li></ul><p>如下题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure><p>他执行的正确顺序是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p>这个知识点自己接触的较少，参考<a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html" target="_blank" rel="noopener">http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br><a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html" target="_blank" rel="noopener">http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从Event-Loop谈JS的运行机制&quot;&gt;&lt;a href=&quot;#从Event-Loop谈JS的运行机制&quot; class=&quot;headerlink&quot; title=&quot;从Event Loop谈JS的运行机制&quot;&gt;&lt;/a&gt;从Event Loop谈JS的运行机制&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="jsִ执行机制 时间循环机制" scheme="http://yoursite.com/tags/js%D6%B4%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>磨刀不误砍柴工</title>
    <link href="http://yoursite.com/2018/08/15/hello-world/"/>
    <id>http://yoursite.com/2018/08/15/hello-world/</id>
    <published>2018-08-15T08:36:36.822Z</published>
    <updated>2018-10-04T15:33:47.873Z</updated>
    
    <content type="html"><![CDATA[<p>本博客实际编写时间是2018-09-09，将以前记录在word中的笔记进行了整和，将其中重要的知识重新梳理写入博客，之后将在博客中记录的自己的成长过程</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="资源库收藏"><a href="#资源库收藏" class="headerlink" title="资源库收藏"></a>资源库收藏</h3><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">阿里矢量图库</a><br><a href="https://icomoon.io" target="_blank" rel="noopener">icomoon</a><br><a href="https://csstriggers.com/" target="_blank" rel="noopener">详细列出了哪些CSS属性在不同的渲染引擎中是否会触发重排或重绘</a></p><p>关于网络性能 </p><ol><li>网络传输性能优化<br> 1.1.浏览器缓存<br> 1.2.资源打包压缩: JS压缩, HTML压缩, 提取公共资源, 提取css并压缩, 将webpack开发环境修改为生产环境, 在服务器上开启Gzip传输压缩(不要对图片文件进行Gzip压缩)<br> 1.3.图片资源优化<br> 1.3.1.不要在HTML里缩放图像<br> 1.3.2.使用雪碧图（CSS Sprite）<br> 1.3.3.使用字体图标（iconfont）<br> 1.3.4.使用WebP<br> 1.4.网络传输性能检测工具——Page Speed<br> 1.5.使用CDN<br>2.页面渲染性能优化<br> 2.1.浏览器渲染过程（Webkit）<br> 2.2.DOM渲染层与GPU硬件加速<br> 2.3.重排与重绘<br> 2.4.优化策略<br>3.JS阻塞性能</li></ol><ul><li><a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></li><li><a href="http://imweb.io/topic/5b6fd3c13cb5a02f33c013bd" target="_blank" rel="noopener">网站性能优化实战——从12.67s到1.06s的故事</a></li><li><a href="http://www.dailichun.com/2017/03/22/ajaxCrossDomainSolution.html" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a></li></ul><p><a href="https://www.cnblogs.com/xianyulaodi/p/5755079.html" target="_blank" rel="noopener">雅虎军规</a></p><p><a href="https://segmentfault.com/a/1190000015809379#articleHeader0" target="_blank" rel="noopener">web缓存</a><br><a href="http://hjingren.cn/2017/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/#%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">征服前端面试</a><br><a href="https://segmentfault.com/a/1190000015597029#articleHeader7" target="_blank" rel="noopener">跨域</a></p><p><a href="https://tech.youzan.com/tag/front-end/" target="_blank" rel="noopener">有赞技术团队博客</a><br><a href="http://fex.baidu.com/" target="_blank" rel="noopener">百度web前端研发部博客</a><br><a href="https://fed.renren.com" target="_blank" rel="noopener">人人网前端博客</a><br><a href="https://tech.meituan.com/archives" target="_blank" rel="noopener">美团技术团队</a></p><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><p>《Webkit技术内幕》：有关浏览器内核的<br>《大型网站性能监测、分析与优化》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本博客实际编写时间是2018-09-09，将以前记录在word中的笔记进行了整和，将其中重要的知识重新梳理写入博客，之后将在博客中记录的自己的成长过程&lt;/p&gt;
&lt;h2 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
</feed>
