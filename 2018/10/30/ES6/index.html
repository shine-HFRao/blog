<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>ES6知识点整理 | HFRao</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="JavaScript," />
  

  <meta name="description" content="声明let和const ES6具有了块级作用域概念，块级作用域：只在它当前的代码段（花括号或括号）之间有效  let和const共同的特点：  不存在变量提升；（变量一定要先声明再使用，在变量声明之前使用就会报错） 通过let和const定义的变量具有块级作用域的概念（暂时性死区），即只在当前作用域有效 不允许重复声明（Let个const声明一个变量以后不能被重复声明var，let和const都不">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6知识点整理">
<meta property="og:url" content="http://yoursite.com/2018/10/30/ES6/index.html">
<meta property="og:site_name" content="HFRao">
<meta property="og:description" content="声明let和const ES6具有了块级作用域概念，块级作用域：只在它当前的代码段（花括号或括号）之间有效  let和const共同的特点：  不存在变量提升；（变量一定要先声明再使用，在变量声明之前使用就会报错） 通过let和const定义的变量具有块级作用域的概念（暂时性死区），即只在当前作用域有效 不允许重复声明（Let个const声明一个变量以后不能被重复声明var，let和const都不">
<meta property="og:locale" content="chinese">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/1.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/2.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/3.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/4.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/5.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/6.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/7.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/8.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/9.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/10.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/11.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/12.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/13.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/14.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/18.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/19.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/15.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/16.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/17.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/20.png">
<meta property="og:image" content="http://yoursite.com/images/blog_images/ES6/21.png">
<meta property="og:updated_time" content="2018-12-02T03:29:36.522Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6知识点整理">
<meta name="twitter:description" content="声明let和const ES6具有了块级作用域概念，块级作用域：只在它当前的代码段（花括号或括号）之间有效  let和const共同的特点：  不存在变量提升；（变量一定要先声明再使用，在变量声明之前使用就会报错） 通过let和const定义的变量具有块级作用域的概念（暂时性死区），即只在当前作用域有效 不允许重复声明（Let个const声明一个变量以后不能被重复声明var，let和const都不">
<meta name="twitter:image" content="http://yoursite.com/images/blog_images/ES6/1.png">

  

  
    <link rel="icon" href="/book.svg">
  

  <link href="/css/styles.css?v=c114cben" rel="stylesheet">


  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#声明let和const"><span class="toc-text">声明let和const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的解构赋值"><span class="toc-text">变量的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的扩展"><span class="toc-text">字符串的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的扩展"><span class="toc-text">函数的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组的扩展"><span class="toc-text">数组的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的扩展"><span class="toc-text">对象的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class类"><span class="toc-text">class类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6中提供的迭代器Iterator"><span class="toc-text">ES6中提供的迭代器Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise对象"><span class="toc-text">Promise对象</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-ES6" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">ES6知识点整理</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.10.30</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>HFRao</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://www.forsigner.com/2018/10/30/ES6/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="声明let和const"><a href="#声明let和const" class="headerlink" title="声明let和const"></a><strong>声明let和const</strong></h2><ol>
<li><p>ES6具有了块级作用域概念，块级作用域：只在它当前的代码段（花括号或括号）之间有效</p>
</li>
<li><p>let和const共同的特点：</p>
<ul>
<li>不存在变量提升；（变量一定要先声明再使用，在变量声明之前使用就会报错）</li>
<li>通过let和const定义的变量具有块级作用域的概念（暂时性死区），即只在当前作用域有效</li>
<li>不允许重复声明（Let个const声明一个变量以后不能被重复声明var，let和const都不可以）</li>
</ul>
</li>
<li><p>const声明的变量是一个不可以改变的量，原始值改变不了，引用值的引用不可改变但是引用值本身的内容是可以改变的</p>
</li>
</ol>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a><strong>变量的解构赋值</strong></h2><ol>
<li><p><strong>数组的结构赋值</strong>（有序）<br> 实质：模式匹配</p>
<ul>
<li>let [a, b, c] = [1, 2, 3];</li>
<li>let [a, [b, [c]]] = [1, [2, [3]]];</li>
<li>解构失败：let [a, b] = [2] 输出a是2，b是undefined;</li>
<li>不完全解构：let [a, b] = [1, 2, 3] 输出a是1, b是2;</li>
<li>这样会报错：let [a] = 1,因为右边的值不具备这样迭代器的接口</li>
<li>默认值：let [a = 10] = [20]; 先走对应匹配的模式（判断是否绝对等于undefined ）    就是20，如果模式没有就回来找自己的默认值也就是10<ul>
<li><strong>例如</strong>：let [a = 10] = [null]; 输出a = null; let [a = 10] = [undefined];输出a = 10(a跟对应的值是空或undefined取默认值，即绝对等于undefined)</li>
</ul>
</li>
<li>还有一点就是：惰性取值,比如：let[x = fn()] = [2]; 输出x是等于2，但是fn是不执行的，只有等于fn()的时    候才执行</li>
<li>个别例子：let[x=y, y=2] = []; 输出想x, y 会报错 ，因为y在定义之前被调用了</li>
</ul>
</li>
<li><p><strong>对象的结构赋值</strong>（无序）</p>
<ul>
<li>对象的结构赋值是无序的,以下都可以：<br>  let { foo, add } = { foo: 123, add: 234 };<br>  let { foo, add } = { add: 234, foo: 123 };</li>
<li>判断是否绝对等于undefined ：<br>  let { bar } = { foo: 123, bar: null } 输出bar = null<br>  let { bar } = { foo: 123 } 输出bar = undefined<br>  let { bar } = { foo: 123, bar: undefined } 输出bar = undefined</li>
<li>默认值：<br>  let {x=3} = {} 输出x = 3,跟数组的结构赋值是一样的</li>
<li>典型例子：<br>  let {foo: bar} = {foo :123} 输出bar = 123, foo是报错（未定义）<br>  let {aa, bb} = {aa:123, bb:234} 的实质是 let { aa:aa, bb:bb } = { aa:     123,     bb: 234 } 这种key跟value相同的时候写一个也是一种简写，前面的    那个aa只是代表的一个模式，是根据模式进行的匹配，不具有真正的意义</li>
</ul>
</li>
<li><p><strong>当然对象解构赋值和数组的解构赋值有时会混在一起使用</strong>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">        p: [</span><br><span class="line">            &quot;hello&quot;,</span><br><span class="line">            &#123; y : 123 &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">let &#123;p:p, p:[s,&#123;y&#125;]&#125; = obj</span><br><span class="line"></span><br><span class="line">console.log(x);         //hello</span><br><span class="line">console.log(y);         //123</span><br><span class="line">console.log(p);         //[&quot;hello&quot;, 123]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象和数组的解构赋值还存在包装类，内置对象中，如下</strong>：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c, d] = &apos;love&apos;;</span><br><span class="line">    a   //&quot;l&quot;</span><br><span class="line">    b   //&quot;0&quot;</span><br><span class="line">    c   //&quot;v&quot;</span><br><span class="line">    d   //&quot;e&quot;</span><br><span class="line"></span><br><span class="line">let&#123;length: len&#125; = &apos;123&apos;;</span><br><span class="line">    len //3</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let&#123;pow, ceil, floor&#125; = Math</span><br><span class="line">let&#123;toString&#125; = 123;</span><br><span class="line">let&#123;toString: s&#125; = false;</span><br><span class="line">console.log(toString == Number.prototype.toString);//true</span><br><span class="line">console.log(s == Boolean.prototype.toString);//true</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解构赋值可以应用在函数中，也可以应用在变量之间的转换, import导入</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [[1, 2], [3, 4]].map(function([a, b])&#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;)</span><br><span class="line">    arr         //[3, 7]</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">console.log(a, b);  //2,1</span><br></pre></td></tr></table></figure>
<ul>
<li>还有就是在vuex中用的比较多：import {vuex, mapState, mapMutations} from ‘vuex’</li>
</ul>
</li>
</ol>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a><strong>字符串的扩展</strong></h2><ol>
<li><p><strong>模版字符串（读反撇号），又叫增强字符串</strong></p>
<ul>
<li>可以添加插值语法${}，更好的处理了字符串拼接的问题，更规范，语义化好，但注意插值语法中的变量在字符串之后改变了是不会影响字符串的改变的,{}会将不是字符串的转变成字符串比如一个{}就会转变成[object Object]，即调用toString方法     </li>
<li>模版字符串可以自由的进行换行等操作，不需要转义字符</li>
<li>在字符串中添加变量、常量、方法（表达式）</li>
<li>如果要在模版字符串中用字符串反撇号或者字符串${}要使用\转义字符</li>
<li><strong>优点</strong>：<br>  (1)更标准的字符串，更好的处理了字符串拼接的问题<br>  (2)语义化更好<br>  (3)防止注入 XSS</li>
</ul>
</li>
<li><p><strong>标签模版，标签模版的实质—–函数调用的特殊形式</strong></p>
<ul>
<li><p>会按照模版的进行分开放到一个数组中作为第一个参数，然后将模版的内容依次作为后面的参数,如下面的几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alert`12345`;</span><br><span class="line"></span><br><span class="line">function show(name)&#123;</span><br><span class="line">    console.log(arguments[0]);          //[&apos;hello&apos;, &apos;, welcome to&apos;, &apos;&apos;]</span><br><span class="line">    console.log(arguments[1]);          //&apos;xiaozhang&apos;</span><br><span class="line">    console.log(arguments[2]);          //&apos;qingdao&apos;</span><br><span class="line">&#125;</span><br><span class="line">show`xiaoming`;</span><br><span class="line">var name = &apos;xiaozhang&apos;, place = &apos;qingdao&apos;;</span><br><span class="line">show`hello$&#123;name&#125;, welcome to$&#123;place&#125;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>重要应用——过滤HTML字符串<br><img src="/images/blog_images/ES6/1.png" alt="image"><br><img src="/images/blog_images/ES6/2.png" alt="image"></p>
</li>
</ul>
</li>
<li><p><strong>字符串包装类对象新的方法</strong>：includes(), startsWith(), endsWith() repeat(数字)</p>
</li>
</ol>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a><strong>函数的扩展</strong></h2><ol>
<li><p>函数参数可以使用默认值，传参时可以结合解构赋值的形式，如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(&#123;x, y=5&#125;)&#123;</span><br><span class="line">        console.log(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">test(&#123;x:1, y:4&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>要注意的是函数参数中使用这种ES6语法时，x和y都是使用let定义的，即不可以重复声明</li>
</ul>
</li>
<li>函数中的参数还可以使用REST参数（扩展运算符） <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(...arg)&#123;</span><br><span class="line">        console.log(arg)    //[1,3,4]</span><br><span class="line">    &#125;</span><br><span class="line">test(1,3,4)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a><strong>箭头函数</strong></h2><p>箭头函数有以下特点：</p>
<p>(1) 不能通过new操作符来执行</p>
<p>(2) 函数中没有arguments（虽然没有arguments，但可以通过…arg来获得参数列表的）</p>
<p>(3) 函数没有原型</p>
<p>(4) 函数中的this绑定取决于离箭头函数最近的非箭头函数的父级作用域，并且this的绑定是不可改变的</p>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a><strong>数组的扩展</strong></h2><ol>
<li><p>数组的扩展除了上述所说的数组的解构赋值，数组中还可以使用REST参数（扩展运算符）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var newArr = [...arr1, ...arr2, ...arr3];</span><br><span class="line"></span><br><span class="line">let [x, ...y] = [1];</span><br><span class="line">console.log(x,y)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将字符串进行包装成对象，然后被转换成数组（扩展运算符 可以在特定的环境下把类数组转化为数组）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var strArr = [...&apos;xiao&apos;];</span><br><span class="line">console.log(strArr)     //[&apos;x&apos;, &apos;i&apos;, &apos;a&apos;, &apos;o&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组还新增了许多API</p>
<p> (1) Array.of()构造数组，参数依次是数组的值</p>
<p> (2) Array .from( ) 将类数组转化为数组,如果参数是数组则返回这个数组本身，from还可以穿第二个参数<br> <img src="/images/blog_images/ES6/3.png" alt="image"><br> <img src="/images/blog_images/ES6/4.png" alt="image"><br> 回调函数类似于map方法<br> <img src="/images/blog_images/ES6/5.png" alt="image"><br> <img src="/images/blog_images/ES6/6.png" alt="image"></p>
<p> (3) Array.prototype.copyWidthin(): 是按照一定的格式进行重写，改变原数组</p>
<p> (4) Array.prototype.fill() ,第一个单数是要填补的内容，第二个和第二个分别是起始位置和中止位置</p>
<p> (5) Array.prototype.entries()</p>
<p> (6) Array.prototype.keys()</p>
<p> (7) Array.prototype.values()</p>
<p> (8) Array.prototype.includes(): includes()返回的是一个Boolean值，查看数组中是否有这个值，跟indexof的区别是indexof找不到NaN 而includes可以</p>
<p> (9) Array.prototype.find(): Find()找到满足条件的第一个数</p>
<p> (10) Array.prototype.findIndex(): FindIndex()找到满足条件的第一个数的下标（超出时返回的是-1）</p>
</li>
</ol>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a><strong>对象的扩展</strong></h2><ol>
<li><p>属性的简洁表示法以及属性名表达式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = &apos;123&apos;;</span><br><span class="line">var obj = &#123;foo: foo&#125;    //可以简写为 </span><br><span class="line">var obj = &#123;foo&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="/images/blog_images/ES6/7.png" alt="image"></p>
</li>
<li><p>属性名表达式：<br> <img src="/images/blog_images/ES6/8.png" alt="image"><br> <img src="/images/blog_images/ES6/9.png" alt="image"> <img src="/images/blog_images/ES6/10.png" alt="image"></p>
</li>
<li><p>对象还新增了许多API</p>
<ul>
<li><p>Object.is()</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.is(&apos;foo&apos;, &apos;foo&apos;))    //true</span><br><span class="line"></span><br><span class="line">console.log(Object.is(NaN, NaN))    //true</span><br><span class="line">console.log(NaN === NaN)       //false</span><br><span class="line"></span><br><span class="line">console.log(Object.is(+0, -0))      //false</span><br><span class="line">console.log(+0 === -0)      //true</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.assign() 将若干个对象的可枚举属性放到一个对象当中去（当参数中只有一个obj是返回的就是和原来的一模一样的，就是是一个地址），返回的就是obj的地址<br><img src="/images/blog_images/ES6/11.png" alt="image"> <img src="/images/blog_images/ES6/12.png" alt="image"><br>还有如果只有一个参数且参数为数字、字符串等原始值时，（第一个参数null跟undefined都不可以，它们转化不成对象）<br><img src="/images/blog_images/ES6/13.png" alt="image"> <img src="/images/blog_images/ES6/14.png" alt="image"></p>
</li>
<li><p>Object.keys()  Object.values()  Object.entries()</p>
<ul>
<li>下面返回的都是迭代器对象<br><img src="/images/blog_images/ES6/18.png" alt="image"><br><img src="/images/blog_images/ES6/19.png" alt="image"></li>
</ul>
</li>
</ul>
</li>
<li><p>扩展运算符也可以用在对象上<br> <img src="/images/blog_images/ES6/15.png" alt="image"> <img src="/images/blog_images/ES6/16.png" alt="image"></p>
<ul>
<li>下面就是运用对象扩展运算符到Object.assign<br><img src="/images/blog_images/ES6/17.png" alt="image"></li>
</ul>
</li>
</ol>
<h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a><strong>class类</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 用class类的函数不存在函数提升</span><br><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//相当于</span><br><span class="line"></span><br><span class="line">class Person1 &#123;     //新的语法糖 （糖衣语法）</span><br><span class="line">    constructor(name, age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this,age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Person1)//function</span><br><span class="line">Person1()       //报错，用class声明的构造函数必须用new操作符进行运算</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;       //class里面默认执行严格模式,严格模式this不会指向window的要么没有（undefined）要么指向对象</span><br><span class="line">    constructor(name, age=0)&#123;       //constructor没写也会自动添加上，相当于初始化this</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.weight = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food = 1)&#123;      //相当于定义原型上的方法</span><br><span class="line">        this.weight += food</span><br><span class="line">    &#125;			</span><br><span class="line">    drink(water = .5)&#123;</span><br><span class="line">        this.weight += water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const a =function ()&#123;&#125;  //叫函数表达式</span><br><span class="line"></span><br><span class="line">//相当于</span><br><span class="line"></span><br><span class="line">const b = class &#123;   //叫class表达式</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function ()&#123;&#125;)()</span><br><span class="line"></span><br><span class="line">//相当于 </span><br><span class="line"></span><br><span class="line">var a = new class&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(&apos;xm&apos;)     //立即执行class,返回一个对象</span><br></pre></td></tr></table></figure>
<ul>
<li>this指向的问题：</li>
</ul>
<p><img src="/images/blog_images/ES6/20.png" alt="image"> <img src="/images/blog_images/ES6/21.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var age = 18;</span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.age = 11;</span><br><span class="line">        this.print = (name = &apos;haha&apos;) =&gt;&#123;</span><br><span class="line">            console.log(this.age);//11 箭头函数具有绑定作用域的功能，箭头函数里面没有this，会绑定最近有this的父级</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = &#123;//对象里边是不存在作用域的</span><br><span class="line">    age: 19,</span><br><span class="line">    func: () =&gt;&#123;</span><br><span class="line">        console.log(this.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new Person();</span><br><span class="line">console.log(a.print());</span><br><span class="line">b.func(); //18</span><br></pre></td></tr></table></figure>
<ul>
<li>静态属性和静态方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.func = function ()&#123;&#125;</span><br><span class="line">Person.name = &apos;haah&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>class的继承:原型和实例都会继承下来(通过Super)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = 1;</span><br><span class="line">        this.weight = 100;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food)&#123;</span><br><span class="line">        this.weight ++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person extends Animal&#123;    //Person没有this(子类都没有this)</span><br><span class="line">    constructor(name, sex = &apos;male&apos;)&#123;    //constructor和super在没有的情况下都是会默认调用的，但你写了constructor没写super函数会报错</span><br><span class="line">        </span><br><span class="line">        //使用this之前一定要调用super方法 super相当于Animal.call(this)</span><br><span class="line">        </span><br><span class="line">        super(name)//调用父类的构造方法来产生this =&gt;&#123;name, age, weight&#125; this</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food)&#123;</span><br><span class="line">        Super.eat();</span><br><span class="line">        this.weight ++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//当super为对象时，super =&gt; Animal.prototype（即代表父类的原型对象，但是调用的环境是当前的环境，即this指向的是子类）当super作为函数，代表调用父类的构造函数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(B.__proto__)</span><br><span class="line">console.log(B.__proto__ === A);//true</span><br><span class="line">console.log(B.__proto__.prototype === A.prototype);//true</span><br></pre></td></tr></table></figure>
<h2 id="ES6中提供的迭代器Iterator"><a href="#ES6中提供的迭代器Iterator" class="headerlink" title="ES6中提供的迭代器Iterator"></a><strong>ES6中提供的迭代器Iterator</strong></h2><ol>
<li>迭代器是一个对象，专门为可迭代的对象提供接口，这个方法用来遍历数据（数据的共同特点是有序的）</li>
<li><p>特点：</p>
<p> （1）每个迭代器对象都有next方法，每次执行next方法返回一个结果对象{value,done},value代表每次迭代的数据，done代表迭代是否结束Boolean值</p>
<p> （2）每个迭代器有一个专用指针，迭代开始时指向数据结构的第一个值，每次调用next方法指针向下移动一位</p>
<p> （3）支持for of循环，每次遍历都是调用迭代器对象的next方法、还可以被…运算符遍历</p>
</li>
<li><p>模拟一个数组的迭代器</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createIterator(arr = []) &#123;</span><br><span class="line">        let currentIndex = 0;</span><br><span class="line">        return &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                if (arr.length - 1 &lt; currentIndex) &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: undefined,</span><br><span class="line">                        done: false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: arr[currentIndex++],</span><br><span class="line">                        done: true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有默认的Iterator接口的有：Array Map Set String arguments NodeLists entries keys values, entries keys values会返回一个迭代器对象<br> （1）我们来看看数组中迭代接口来手动遍历数组，看看他是怎么工作的：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myArray = [ 1, 2, 3 ];</span><br><span class="line">var it = myArray[Symbol.iterator]();</span><br><span class="line">it.next();  // &#123; value:1, done:false &#125;</span><br><span class="line">it.next();  // &#123; value:2, done:false &#125;</span><br><span class="line">it.next();  // &#123; value:3, done:false &#125;</span><br><span class="line">it.next();  // &#123; done:true &#125;</span><br></pre></td></tr></table></figure>
</code></pre><p> (2)虽然对象没有迭代器，但你可以给任何想遍历的对象定义 @@iterator，举例来说：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    b: 3</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty( myObject, Symbol.iterator, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    value: function() &#123;</span><br><span class="line">        var o = this;</span><br><span class="line">        var idx = 0;</span><br><span class="line">        var ks = Object.keys( o );</span><br><span class="line">        return &#123;</span><br><span class="line">            next: function() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    value: o[ks[idx++]],</span><br><span class="line">                    done: (idx &gt; ks.length)</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br><span class="line">// 手动遍历 myObject</span><br><span class="line">var it = myObject[Symbol.iterator]();</span><br><span class="line">it.next(); // &#123; value:2, done:false &#125;</span><br><span class="line">it.next(); // &#123; value:3, done:false &#125;</span><br><span class="line">it.next(); // &#123; value:undefined, done:true &#125;</span><br><span class="line">// 用 for..of 遍历 myObject</span><br><span class="line">for (var v of myObject) &#123;</span><br><span class="line">      console.log( v );</span><br><span class="line">&#125;</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的迭代器都有symbol.iterator属性，必须通过[]形式访问来返回默认的迭代器,数组中的迭代器是默认指向下一个索引，返回的是索引值和values返回的一样<br>Map Set会把邻接链表转换成一个单向链表，指针每次指向一个节点，指针下移。支持双字节的输出，在for of遍历时如果有一个不可拆分的双字节，会将这个双字节输出（比如一个表情是双字节，就能够输出表情）</p>
</li>
<li><p><strong>生成器 Generator</strong><br> （1）用于生成迭代器，生成器是一个函数 有* yeild</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function *createItervator()&#123; //生成器不能够通过new操作符来执行</span><br><span class="line">    yield 1; //yield每一步就会暂停一次，如果有return就不可以再next了</span><br><span class="line">    yield 2; //（即就不会执行下面的yield了，next执行后的返回的对象中done变为true）</span><br><span class="line">    yield 3; //yield必须在生成器的函数中,yield是没有返回值的（即undefined）</span><br><span class="line">&#125;</span><br><span class="line">var i = createItervator();</span><br><span class="line">i.next() //括号中可以添加参数作为上一次迭代的返回值</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function *show(arr, string)&#123;</span><br><span class="line">    yield *arr; //这里可以继续迭代</span><br><span class="line">    yield *string; //这里可以继续迭代</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a><strong>Promise对象</strong></h2><ol>
<li><p><strong>Promise</strong> :<br> (1)promise是一种异步编程的解决方案，所谓的promise简单的说就是一个容器，它里面存着未来会结束的事件。从语法上说，promise是一个对象，从他哪里可以获取异步操作的消息</p>
<p> (2)Promise对象有两个特点</p>
<p> ① Promise对象有三种状态pending，resolved，rejected，只有异步操作的结果会决定promise对象的状态，其他的操作都无效，这也是应征了promise单词承诺的意思<br> ② 一旦状态改变，状态就不会再改变了，而且状态只可能由pending变成resolved或pending变成rejected</p>
<p> (3)有了promise对象，就可以将异步操作以同步的操作流程表达出来，避免了层层嵌套的回调函数（回调地狱v型代码）（将多层次的代码转变成两层）</p>
<p> (4)Promise也有一些缺点，首先promise一旦建立就会立即执行，中途无法取消，其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
</li>
<li><p><strong>再来说说Promise的API</strong><br> <strong>静态方法</strong></p>
<ul>
<li><p>ES6中static的静态方法现在只支持方法，还不支持属性<br>(1)Promise.all([p1, p2, p3])</p>
<blockquote>
<p>多个promise对象的集合,如果p1,p2,p3的状态都是resolved状态的话，会返回一个新的promise对象状态是resolved状态，且对应的值是p1，p2，p3对应值组成的数组，只要检查到有一个状态是rejected的话，返回一个状态为rejected的新的对象，对应的值是第一个被检查到状态为rejected对象的对应的值</p>
</blockquote>
<p>(2)Promise.race([p1, p2, p3])</p>
<blockquote>
<p>谁的状态先变了我就用谁的(谁先返回的就用谁的)，一般用于做测试，测试那个请求更快，返回的也是一个新的对象</p>
</blockquote>
<p>(3)Promise.resolve(1) 返回一个状态为resolved的对象<br>(4)Promise.reject(2) 返回一个状态为rejected的对象</p>
<p><strong>实例方法</strong><br>(5)Promise.prototype.then 可接受成功和失败两个回调函数</p>
<blockquote>
<p>执行then函数，如果所传入的函数没有返回一个Promise实例对象，那么then函数会默认返回一个新的状态为resolved的Promise实例对象（对象中对应的值就是传进then参数函数执行返回的值），如果返回一个Promise实例对象则then函数会返回这个对象<br>(6)promise.prototype.catch 接受失败的回调函数</p>
</blockquote>
<blockquote>
<p>Promise.reject(3).catch(err =&gt; console.log(err));//抓取失败时候的回调函数，会返回一个新的promise对象</p>
<pre><code>相当于  .then(null, err =&gt; console.log(err))  
</code></pre><p>我们平常会看到如下：成功就用then，失败就用catch：<br>Promise.reject(3).then(data =&gt; console.log(data)).catch(err =&gt; console.log(err));</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p><strong>自己封装一个Promise</strong></p>
<p> <strong>ES6写法</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">class myPromise&#123;</span><br><span class="line">        constructor(fn)&#123;</span><br><span class="line">            if(typeof fn !== &quot;function&quot;)&#123;</span><br><span class="line">                throw TypeError(`$&#123;fn&#125; is not a function`)</span><br><span class="line">            &#125;</span><br><span class="line">            this.status = &quot;pending&quot;;</span><br><span class="line">            this.data = undefined;</span><br><span class="line">            this.resolveCBArr = [];</span><br><span class="line">            this.rejectCBArr = [];</span><br><span class="line">            let resolved = (suc) =&gt; &#123;</span><br><span class="line">                if(this.status == &quot;pending&quot;)&#123;</span><br><span class="line">                    setTimeout(() =&gt; &#123;</span><br><span class="line">                        this.status = &quot;resolved&quot;;</span><br><span class="line">                        this.data = suc;</span><br><span class="line">                        this.resolveCBArr &amp;&amp; this.resolveCBArr.forEach(fn =&gt; fn());</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            let rejected = (err) =&gt; &#123;</span><br><span class="line">                if(this.status == &quot;pending&quot;)&#123;</span><br><span class="line">                    setTimeout(() =&gt; &#123;</span><br><span class="line">                        this.status = &quot;rejected&quot;;</span><br><span class="line">                        this.data = err;</span><br><span class="line">                        this.rejectCBArr &amp;&amp; this.rejectCBArr.forEach(fn =&gt; fn());</span><br><span class="line">                        //其实这里还有一步就是数组中执行后的函数进行unshift</span><br><span class="line">                    &#125;, 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fn(resolved, rejected);</span><br><span class="line">        &#125;</span><br><span class="line">        static resolve(suc) &#123;</span><br><span class="line">            return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class="line">                resolved(suc);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        static reject(err) &#123;</span><br><span class="line">            return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class="line">                rejected(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        then(resolveFn, rejectFn) &#123;</span><br><span class="line">            if(this.status == &quot;resolved&quot;)&#123;</span><br><span class="line">                let res = resolveFn(this.data);</span><br><span class="line">                if(res instanceof myPromise)&#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class="line">                        resolved(res);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(this.status == &quot;rejected&quot;)&#123;</span><br><span class="line">                let res = rejected(this.data);</span><br><span class="line">                if(res instanceof myPromise)&#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class="line">                        resolved(res);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(this.status == &quot;pending&quot;)&#123;       </span><br><span class="line">                console.log(&quot;pending&quot;);         </span><br><span class="line">                return new myPromise((resolved, rejected) =&gt;&#123;   </span><br><span class="line">                    this.resolveCBArr.push( ((resolveFn) =&gt; &#123;   </span><br><span class="line">                        return () =&gt; &#123;</span><br><span class="line">                            let res = resolveFn(this.data);</span><br><span class="line">                            if(res instanceof myPromise)&#123;</span><br><span class="line">                                res.then(resolved, rejected);</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                resolved(res);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)(resolveFn) )</span><br><span class="line"></span><br><span class="line">                    this.rejectCBArr.push( ((rejectFn) =&gt; &#123;</span><br><span class="line">                        return () =&gt; &#123;</span><br><span class="line">                            let res = rejectFn(this.data);</span><br><span class="line">                            if(res instanceof myPromise)&#123;</span><br><span class="line">                                res.then(resolved, rejected);</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                resolved(res);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;)(rejectFn) )</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> (1) ES6写法的好处就是可以利用箭头函数中this的特点，很方便的使用this，而在ES5中则要通过额外的变量（比如self）来保存this</p>
<p> (2) 当resolved和rejected被异步执行时，.then的方法真相是的实例对象的状态还没改变时，这里需要用到一个方法就是将then参数中的两个函数暂时存储到实例对象属性中，待状态改变后，执行这个函数，因为考虑到会有多个一个实例对象会有then的调用所以避免覆盖，将他们用数组来存储，到时通过forEach来遍历执行</p>
<p> (3) 还有就是不管是状态是啥都会返回一个新的Promise实例对象，在状态为pending时，这里用到的一点就是将状态改变后要执行的函数集中的放在返回的新Promise实例对象中，看代码，当函数执行后的返回值是一个Promise实例对象时，通过执行then操作然后将resolved和rejected作为参数传入then函数中，将状态传给外层新的Promise实例/对象，如果返回值不是一个Promise实例对象，则直接执行resolved</p>
<p> (4) 因为Promise是处理异步任务的，而且是微任务，所以执行的顺序是在主执行栈执行完后执行，这里实现异步执行用setTimeout实现</p>
</li>
</ol>
<!-- ## **ES6模块化**
1. export导出， import...from导入 -->

    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/10/20/object /">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/11/08/web_cache /">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>





   
      <div class="git"></div>
   
</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2018/10/30/ES6/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
