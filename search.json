[{"title":"再读JavaScript权威指南（词法结构、类型、值、变量）","url":"http://yoursite.com/2018/09/13/JavaScript_Authoritative_Guide2_3/","content":"<h2 id=\"JavaScript-权威指南（第二章词法结构）\"><a href=\"#JavaScript-权威指南（第二章词法结构）\" class=\"headerlink\" title=\"JavaScript 权威指南（第二章词法结构）\"></a>JavaScript 权威指南（第二章词法结构）</h2><h3 id=\"JavaScript结尾分号的问题\"><a href=\"#JavaScript结尾分号的问题\" class=\"headerlink\" title=\"JavaScript结尾分号的问题\"></a><strong>JavaScript结尾分号的问题</strong></h3><ol>\n<li><p>JavaScript 并不会在所有的换行处填补分号，只有在缺少分号就无法正确解析的时候，JavaScript 才会填补分号。换句话讲如果 <strong>当前语句</strong> 和 <strong>随后的的非空格字符</strong> 不能当一个整体来解析的话，JavaScript 就会在当前语句行的结束处填补分号。</p>\n</li>\n<li><p>有两个例外</p>\n<ul>\n<li><p>第一个例外是在涉及 <strong>return</strong>、<strong>break</strong> 和 <strong>continue</strong> 语句的场景中。如果这三个关键词后紧跟着换行，JavaScript则会在换行处填补分号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return</span><br><span class=\"line\">true;</span><br><span class=\"line\"></span><br><span class=\"line\">//JavaScript会解析成：</span><br><span class=\"line\"> </span><br><span class=\"line\"> return; true;</span><br><span class=\"line\"></span><br><span class=\"line\">//  而代码的本意是这样：</span><br><span class=\"line\"></span><br><span class=\"line\">return true;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个例外是在涉及 <strong>++</strong>、<strong>–</strong> 运算符的时候，这些运算符可以作为表达式的前缀，也可作为表达式的后缀。如果做后缀，他和表达式应该在同一行，否则行尾将增加分号，同时 ++、– 将作为下一行代码的前缀操作符并与其一起解析，<strong>例如</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x</span><br><span class=\"line\">++</span><br><span class=\"line\">y</span><br><span class=\"line\"></span><br><span class=\"line\">//这段代码的解析为 “ x; ++y;” ,而不是 “ x++; y”</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JavaScript-权威指南（第三章类型，值，变量）\"><a href=\"#JavaScript-权威指南（第三章类型，值，变量）\" class=\"headerlink\" title=\"JavaScript 权威指南（第三章类型，值，变量）\"></a>JavaScript 权威指南（第三章类型，值，变量）</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a><strong>数据类型</strong></h3><ol>\n<li><p>能够表示并操作的值的类型称做 <strong>数据类型</strong> ，变量是一个值的符号名称，可以通过名称来获得对值的引用</p>\n</li>\n<li><p>javaScript数据类型分为两类：<strong>原始类型</strong> 和 <strong>对象类型</strong> ，也可分为 <strong>可变类型</strong> 和 <strong>不可变类型</strong> ，null和undefined是两个特殊的原始值（是无法拥有方法的值），函数和数组是特殊的对象</p>\n<ul>\n<li>原始类型/不可变类型：数字，字符串，布尔值，null，undefined</li>\n<li>对象类型/可变类型：对象</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a><strong>字符串类型</strong></h3><ol>\n<li><p>在 <strong>es5</strong> 中字符串的直接量可以拆分成数行，每行必须以反斜线（\\）结束</p>\n</li>\n<li><p><strong>JavaScript转义字符表</strong>：</p>\n<p> <img src=\"/images/blog_images/Escape_Character1.png\" alt=\"image\"><br> <img src=\"/images/blog_images/Escape_Character2.png\" alt=\"image\"></p>\n</li>\n<li><p><strong>字符串方法</strong>：</p>\n<p> <img src=\"/images/blog_images/String_Methods.png\" alt=\"image\"><br> <img src=\"/images/blog_images/String_Methods2.png\" alt=\"image\"></p>\n<ul>\n<li>在JavaScript中字符串是固定不变的，类似replace()和toUpperCase()的方法都返回新字符串，原字符串本身并没有变化</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数字类型\"><a href=\"#数字类型\" class=\"headerlink\" title=\"数字类型\"></a><strong>数字类型</strong></h3><ol>\n<li><p>JavaScript支持 <strong>十进制</strong> ，<strong>十六进制</strong> ，对于八进制是有些支持，有些不支持，但在es6的严格模式下，八进制是禁止的</p>\n</li>\n<li><p>可以使用 <strong>指数计数法</strong> 来表示浮点型直接量，即在实数后面跟字母e或E，后面再跟<br>正负号，其后再加一个整型的整数</p>\n</li>\n<li><p>JavaScript的算术运算在溢出、下溢或被0整除时不报错，<strong>0/0 = NaN</strong>， <strong>Infinity/Infinity = NaN</strong>，Infinity和NaN在es3中可读写，在es5中只可读，在es3中 <strong>Number</strong> 的属性值也是只读的,</p>\n</li>\n<li>判断 <strong>NaN</strong> 和 <strong>infinity</strong> 的有两个函数：isNaN() 和 isInfinite()</li>\n<li><p>关于 <strong>二进制浮点数精度不准</strong> 的解释：</p>\n<ul>\n<li>JavaScript采用了 <strong>IEEE-754</strong> 浮点数表示法（几乎现代所有编程语言所采用），这是一种<strong>二进制表示法</strong>，可以精确地表示分数，比如 1/2、1/81 和 /1024。遗憾的是，我们常用的分数（特别是在金融计算方面的）都是 <strong>十进制分数</strong> 1/10、1/100等。<strong>二进制浮点数</strong> 表示法不能够精确表示类似0.1这样简单的数字。</li>\n<li>JavaScript中的数字具有足够的精度，并可以及其近似 <strong>0.1</strong>。但事实是，数字不能精确</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Math对象的属性\"><a href=\"#Math对象的属性\" class=\"headerlink\" title=\"Math对象的属性\"></a><strong>Math对象的属性</strong></h3><p><img src=\"/images/blog_images/Math_Methods.png\" alt=\"image\"></p>\n<h3 id=\"日期与时间函数Date-简单的教程\"><a href=\"#日期与时间函数Date-简单的教程\" class=\"headerlink\" title=\"日期与时间函数Date()简单的教程\"></a><strong>日期与时间函数Date()简单的教程</strong></h3><p><img src=\"/images/blog_images/Date_Methods.png\" alt=\"image\"></p>\n<h3 id=\"RegExp\"><a href=\"#RegExp\" class=\"headerlink\" title=\"RegExp\"></a><strong>RegExp</strong></h3><ol>\n<li><p>RegExp对象定义了很多很有用的方法，字符串同样可以具有接收RegExp参数的方法，<strong>例如</strong>：</p>\n<p> <img src=\"/images/blog_images/RegExp.png\" alt=\"image\"></p>\n</li>\n</ol>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a><strong>Boolean</strong></h3><ol>\n<li><p>下面这些值会被转化成 <strong>false</strong>:                       <strong>undefined</strong>、<strong>null</strong>、<strong>0</strong>、<strong>-0</strong>、<strong>NaN</strong>、<strong>“”</strong></p>\n</li>\n<li><p>Boolean原型上有 <strong>toString()</strong> 方法(除了这个，还有一个方法是 <strong>valueOf()</strong>，再没有别的方法了)，可以使用这个方法将布尔值转换为字符串 <strong>“true”</strong> 或 <strong>“false”</strong></p>\n</li>\n<li><p>三个重要的布尔运算符：<strong>&amp;&amp;</strong> 、<strong>||</strong> 、<strong>!</strong></p>\n</li>\n</ol>\n<h3 id=\"null-和-undefined\"><a href=\"#null-和-undefined\" class=\"headerlink\" title=\"null 和 undefined\"></a><strong>null 和 undefined</strong></h3><ol>\n<li><p>null是JavaScript的 <strong>关键字</strong>，他表示一个特殊值，常用来描述 <strong>空值</strong>, <strong>typeof null 等于 “object”</strong>, 但他实际上不是一个对象， 通常认为 <strong>null</strong> 是它自有类型的唯一一个成员</p>\n</li>\n<li><p>undefined是预定义的 <strong>全局变量</strong>（他和null不一样，他不是关键字），它的值就是 <strong>“未定义”</strong>，在es3中undefined是 <strong>可读/写</strong> 的变量，可以给他赋任意值，但在es5中undefinde <strong>只读</strong>，使用typeof运算符得到的是 “undefined” ，是undefined类型 undefined使这个类型的唯一成员</p>\n</li>\n<li><p>null 和 undefined 相等于（====），但不严格等于（=====）</p>\n</li>\n<li><p>null 和 undefined 都不包括任何的 <strong>属性</strong> 和 <strong>方法</strong>，使用 “.” 和 [] 来存取这两个值的成员和方法都会产生一个类型错误</p>\n</li>\n<li><p>如果你想将他们赋值给 <strong>变量</strong> 或者 <strong>属性</strong>，或将他们作为 <strong>参数</strong> 传入函数，最佳的选择是使用 <strong>null</strong></p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p>《JavaScript权威指南》第六版  David Flanagan 著</p>\n","categories":["JavaScript权威指南"],"tags":["JavaScript权威指南"]},{"title":"数据结构（树）","url":"http://yoursite.com/2018/09/12/Data_Structure/","content":"<h2 id=\"数据结构（树）\"><a href=\"#数据结构（树）\" class=\"headerlink\" title=\"数据结构（树）\"></a>数据结构（树）</h2><h3 id=\"树（二叉树）\"><a href=\"#树（二叉树）\" class=\"headerlink\" title=\"树（二叉树）\"></a><strong>树（二叉树）</strong></h3><ol>\n<li><p><strong>树</strong> 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合</p>\n</li>\n<li><p>树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有 <strong>N</strong> 个节点和 <strong>N-1</strong> 条边的一个有向无环图</p>\n</li>\n<li><p><strong>二叉树</strong> 是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“ <strong>左子树</strong> ”和“ <strong>右子树</strong> ”。</p>\n</li>\n<li><p>本章目标：</p>\n<ul>\n<li>理解和区分树的遍历方法</li>\n<li>能够运用 <strong>递归</strong> 方法解决树的为前序遍历、中序遍历和后序遍历问题</li>\n<li>能用运用 <strong>迭代</strong> 方法解决树的为前序遍历、中序遍历和后序遍历问题</li>\n<li>能用运用 <strong>广度优先</strong> 搜索解决树的层序遍历问题 </li>\n</ul>\n</li>\n<li><p>二叉树的结构图</p>\n<p> <img src=\"/images/blog_images/Two_forked_tree.png\" alt=\"image\"></p>\n<ul>\n<li>这幅图中有如下概念：<ul>\n<li>根节点：一棵树最顶部的节点</li>\n<li>内部节点：在它上面还有其它内部节点或者叶节点的节点</li>\n<li>叶节点：处于一棵树根部的节点</li>\n<li>子树：由树中的内部节点和叶节点组成</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"树的遍历-介绍\"><a href=\"#树的遍历-介绍\" class=\"headerlink\" title=\"树的遍历 - 介绍\"></a><strong>树的遍历 - 介绍</strong></h3><ol>\n<li><p>前序遍历： 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p>\n<p> <strong>递归：</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var preorderTraversal = function(root, stack = []) &#123;</span><br><span class=\"line\">    if (root) &#123;</span><br><span class=\"line\">        stack.push(root.val);</span><br><span class=\"line\">        preorderTraversal(root.left, stack);</span><br><span class=\"line\">        preorderTraversal(root.right, stack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return stack;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>中序遍历： 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。（通常来说，对于<strong>二叉搜索树</strong>，我们可以通过中序遍历得到一个递增的有序序列）</p>\n<p> <strong>递归：</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var inorderTraversal = function(root, stack = []) &#123;</span><br><span class=\"line\">    if(root) &#123;</span><br><span class=\"line\">        inorderTraversal(root.left, stack);</span><br><span class=\"line\">        stack.push(root.val);</span><br><span class=\"line\">        inorderTraversal(root.right, stack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return stack;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>后序遍历： 后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。（值得注意的是，当你<strong>删除树中的节点</strong>时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。）</p>\n<p> <strong>递归：</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var postorderTraversal = function(root, stack = []) &#123;</span><br><span class=\"line\">    if(root) &#123;</span><br><span class=\"line\">        postorderTraversal(root.left, stack);</span><br><span class=\"line\">        postorderTraversal(root.right, stack);</span><br><span class=\"line\">        stack.push(root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return stack;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外，后序在数学表达中被广泛使用。 编写程序来 <strong>解析后缀表示法</strong> 更为容易。 这里是一个例子：</p>\n<p> <img src=\"/images/blog_images/mathematical_expression.png\" alt=\"image\"></p>\n<p> 您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。</p>\n<p> 如果你想对这棵树进行后序遍历，使用 <strong>栈</strong> 来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p>\n</li>\n</ol>\n<h3 id=\"层序遍历-介绍\"><a href=\"#层序遍历-介绍\" class=\"headerlink\" title=\"层序遍历 - 介绍\"></a><strong>层序遍历 - 介绍</strong></h3><ol>\n<li><p>层序遍历就是逐层遍历树结构。</p>\n</li>\n<li><p><strong>广度优先搜索</strong> 是一种广泛运用在 <strong>树</strong> 或 <strong>图</strong> 这类数据结构中， <strong>遍历</strong> 或 <strong>搜索</strong> 的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。</p>\n</li>\n<li><p>当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。</p>\n</li>\n<li><p>通常，我们使用一个叫做 <strong>队列</strong> 的数据结构来帮助我们做广度优先搜索</p>\n</li>\n<li><p><strong>二叉树的层次遍历（递归）</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">/ \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[][]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var levelOrder = function(root, index = 0, stack = []) &#123;</span><br><span class=\"line\">    if(root)&#123;</span><br><span class=\"line\">        if(!stack[index])&#123;</span><br><span class=\"line\">           stack[index] = []; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        stack[index].push(root.val);</span><br><span class=\"line\">        levelOrder(root.left, index + 1, stack);</span><br><span class=\"line\">        levelOrder(root.right, index + 1, stack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return stack;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p><a href=\"https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/</a></p>\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"再读JavaScript权威指南（函数）","url":"http://yoursite.com/2018/09/11/JavaScript_Authoritative_Guide8/","content":"<h2 id=\"JavaScript-权威指南（第八章函数）\"><a href=\"#JavaScript-权威指南（第八章函数）\" class=\"headerlink\" title=\"JavaScript 权威指南（第八章函数）\"></a>JavaScript 权威指南（第八章函数）</h2><h3 id=\"顶级语句：函数声明\"><a href=\"#顶级语句：函数声明\" class=\"headerlink\" title=\"顶级语句：函数声明\"></a><strong>顶级语句：函数声明</strong></h3><ol>\n<li><p>美元符号和下划线是除了字母和数字以外的两个合法的javaScript标识符</p>\n</li>\n<li><p>函数声明语句并非真正的语句，ECMAScript规范只是允许它们作为顶级域名。它们可以出现在全局代码里，或者内嵌在其他的函数中，但是他们不能够出现在<strong>循环、条件判断、或者try/cache/finnally/以及width</strong>语句中。注意，此限制仅用于语句声明的形式定义的函数。<strong>函数定义表达式可以出现在javaScript代码的任何地方</strong></p>\n</li>\n<li><p><strong>*补充：</strong></p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(a) &#123;</span><br><span class=\"line\">    var b = 123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">c</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//虽然不允许在<span class=\"keyword\">if</span>定义函数声明，但是现代的浏览器不报错，</span><br><span class=\"line\">//而且在预编译过程中，c为undefined（老版本的IE可以存在c预编译为<span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">c</span></span>()&#123;&#125;）</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数表达式本身就是一个属性访问表达式\"><a href=\"#函数表达式本身就是一个属性访问表达式\" class=\"headerlink\" title=\"函数表达式本身就是一个属性访问表达式\"></a><strong>函数表达式本身就是一个属性访问表达式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o.m(x, y)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>上面的代码是一个调用的表达式，它包括一个函数表达式o.m，以及两个是实参表达式x和y，函数表达式本身就是一个<strong>属性访问表达式</strong>，这意味着该函数被当做一个<strong>方法</strong>，而不是作为一个普通函数来调用。</li>\n</ol>\n<h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a><strong>arguments</strong></h3><ol start=\"2\">\n<li><p>arguments数组对象的数组元素是函数形参所对应实参额别名，实参对象一数字为索引，并且形参名称可以认为是相同变量的不同命名。即两个的值是互通的，<strong>只要这其中一个改变那么另外一个就跟着改变</strong>，但是在es5的严格模式中这一特性就不存在了，而且在非严格模式中函数中的arguments是一个<strong>标识符</strong>，而在严格模式中它变成了一个<strong>保留字</strong>，严格模式中函数无法使用arguments作为形参或局部变量，也不能够给arguments赋值</p>\n</li>\n<li><p>arguments并不是一个<strong>关键字</strong>，但在调用每个函数时都会自动声明它</p>\n</li>\n<li><p><strong>*补充：</strong></p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"use strict\"</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"built_in\">test</span>(a)&#123;</span><br><span class=\"line\">    arguments[0] = 2;</span><br><span class=\"line\">    console.log(a);//1,如果没有严格模式这里的输出是2</span><br><span class=\"line\">    console.log(arguments[0])//2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">test</span>(1);</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-7-函数属性、方法、构造函数\"><a href=\"#8-7-函数属性、方法、构造函数\" class=\"headerlink\" title=\"8.7 函数属性、方法、构造函数\"></a><strong>8.7 函数属性、方法、构造函数</strong></h3><ol>\n<li><p>一个名为test函数，<strong>test.length</strong>和函数呢内<strong>argument.callee.length</strong>指的是函数形参的个数，<strong>argument.length</strong>指的是实参的个数</p>\n</li>\n<li><p>Call和apply的区别是传参形式不同，call是第一个参数之后的参数就是执行函数传入的实参，而apply的的第二个参数传入的<strong>真实数组</strong>或者<strong>类数组对象</strong>，对象里面的元素就是函数执行传入的实参</p>\n</li>\n<li><p>Call和apply的使用相当于如下代码，根据此可以封装一个call和apply</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.call(o);</span><br><span class=\"line\">f.apply(o);</span><br><span class=\"line\"></span><br><span class=\"line\">//每行的代码和下面代码的功能类似（假设对象中预先不存在名为m的属性）</span><br><span class=\"line\"></span><br><span class=\"line\">o.m = f;    //将m存储为临时的方法</span><br><span class=\"line\">o.m();      //调用它不传入参数</span><br><span class=\"line\">delete o.m; //将临时方法删除</span><br></pre></td></tr></table></figure>\n<p><strong>*call的封装实现</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newCall = function () &#123;</span><br><span class=\"line\">            var ctx = arguments[0] || window;</span><br><span class=\"line\">            ctx.fn = this;</span><br><span class=\"line\">            var args = [];</span><br><span class=\"line\">            for (var i = 1; i &lt;= arguments.length; i++) &#123;</span><br><span class=\"line\">                args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class=\"line\">            delete ctx.fn;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>*apply的封装实现：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newApply = function (ctx, arr) &#123;</span><br><span class=\"line\">    var ctx = ctx || window;</span><br><span class=\"line\">    ctx.fn = this;</span><br><span class=\"line\">    var args = [];</span><br><span class=\"line\">    if (arr) &#123;</span><br><span class=\"line\">        console.log(&apos;haha&apos;)</span><br><span class=\"line\">        for (var i = 0; i &lt;= arr.length; i++) &#123;</span><br><span class=\"line\">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        var result = ctx.fn();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete ctx.fn;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>在ECMAScript 5的严格模式中，<strong>call和apply的第一个实参都会变成this的值</strong>，哪怕传入的实参是原始值甚至是undefined和null。在es3和非严格模式中，<strong>传入的null和undefined都会被全局所代替</strong>，而其他原始值则会被相应的包装对象（wrapper bject）所代替</p>\n</li>\n<li><p>bind是es5新增的方法</p>\n</li>\n</ol>\n<p>bind的封装实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newBind = function (target) &#123;</span><br><span class=\"line\">    target = target || window;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    var arg = [].slice.call(arguments, 1);</span><br><span class=\"line\">    var Temp = function () &#123; &#125;;</span><br><span class=\"line\">    var F = function () &#123;</span><br><span class=\"line\">        var _arg = [].slice.call(arguments, 0);</span><br><span class=\"line\">        return self.apply(this instanceof Temp ? this : target, arg.concat(_arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Temp.prototype = this.prototype;</span><br><span class=\"line\">    F.prototype = new Temp(); //将F函数的的原型跟调用newBind 函数的原型一样（就是将函数F变得跟调用newBind 的函数一样）</span><br><span class=\"line\"></span><br><span class=\"line\">    return F;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>和所有的javaScript对象一样，函数也有toString()方法，ECMAScript规范规定这个方法返回一个字符串，这字符串和函数声明语句的的语法相关。实际上，大多数（非全部）的toString()方法实现都返回函数的完整源码。<strong>内置函数往往返回一个类似”[native code]”的字符串作为函数体</strong></li>\n</ol>\n<p>*如下(使用的是浏览器自带的开发者工具)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; function test()&#123;var c = &apos;i&apos;&#125;</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; test.toString()</span><br><span class=\"line\">&quot;function test()&#123;var c = &apos;i&apos;&#125;&quot;</span><br><span class=\"line\">&gt; Object.toString()</span><br><span class=\"line\">&quot;function Object() &#123; [native code] &#125;&quot;</span><br><span class=\"line\">&gt; Date.toString()</span><br><span class=\"line\">&quot;function Date() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>不管是通过函数定义的语句还是函数直接量的表达式，函数的定义都要使用function关键字。但是函数还可以<strong>通过Function()构造函数来定义</strong>，比如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//这行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价</span><br><span class=\"line\"></span><br><span class=\"line\">var f = function (x,y)&#123; return x*y; &#125;</span><br></pre></td></tr></table></figure>\n<p>注意：Function()构造函数并不需要通过传入实参以指定函数名。就想函数直接量一样，Function()构造函数创建一个匿名函数。还有用Function()构造函数创建的函数并不是使用<strong>词法作用域</strong>，相反，函数体代码的编译总是会到顶部函数执行。</p>\n<p>我们可以将Function()构造函数认为是在全局作用域中执行的eval(),eval()可以在自己的私有作用域内定义新变量和函数，Function()构造函数在实际编程中很少会用到。</p>\n<h3 id=\"8-8-函数式编程\"><a href=\"#8-8-函数式编程\" class=\"headerlink\" title=\"8.8 函数式编程\"></a><strong>8.8 函数式编程</strong></h3><ol>\n<li><p>使用函数处理数组</p>\n</li>\n<li><p>高阶函数：所谓的高阶函数就是操作函数的函数，它接受一个或多个函数作为参数，并返回一个新函数</p>\n</li>\n<li><p>不完全函数：那一次完整的函数调用拆成对此函数调用，每次传入的参数都是完整参数的一部分，每一个拆分出的函数叫做不完全函数，每次函数调用叫做不完全调用，被称为柯里化</p>\n</li>\n<li><p>记忆：记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度换取更优的时间复杂度</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p>《JavaScript权威指南》第六版  David Flanagan 著</p>\n","categories":["javascript"],"tags":["javascript"]},{"title":"从Event Loop谈JS的运行机制","url":"http://yoursite.com/2018/09/10/Event-Loop/","content":"<h2 id=\"从Event-Loop谈JS的运行机制\"><a href=\"#从Event-Loop谈JS的运行机制\" class=\"headerlink\" title=\"从Event Loop谈JS的运行机制\"></a>从Event Loop谈JS的运行机制</h2><blockquote>\n<h3 id=\"javaScript引擎是单线程\"><a href=\"#javaScript引擎是单线程\" class=\"headerlink\" title=\"javaScript引擎是单线程\"></a><strong>javaScript引擎是单线程</strong></h3></blockquote>\n<ul>\n<li><p>我们都知道javaScript引擎是单线程，为什么不是多线程的呢？想下javaScript的主要作用是用户的互动和DOM的操作，假定javaScript有多个线程，一个线程在DOM节点上添加，同时另一个线程在这时删除这一个节点，这时浏览器应该以哪个线程为主呢？这就会导致很复杂的同步问题。</p>\n</li>\n<li><p>还有一个就是HTML5提出的Web Worker的标准，允许javaScript引擎创建多个子线程，利用多核cpu的计算能力，但是子线程是浏览器开的，完全由主线程控制，而且不能操作DOM，javaScript引擎线程与worker线程间是通过特定的方式通信的（postMessageAPI，需要通过序列化对象来与线程交互特定的数据）</p>\n</li>\n</ul>\n<p><strong>对于Web Worker MDN的官方解释是：</strong></p>\n<p> Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面，一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件，这个文件包含将在工作线程中运行的代码; workers运行在另一个全局上下文中,不同于当前的window。因此，使用window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误**</p>\n<ul>\n<li>所以针对大量计算问题非常耗时的工作时，请单独开一个Worker线程，不管这个线程里面发生什么样翻天覆地的变化都不会影响多javaScript主线程，只待计算结果出来之后，将结果通信给主线程，所以javaScript引擎是单线程的这一本质一点都没变（其实还有一个sharedWorker,这里就不做介绍了）</li>\n</ul>\n<blockquote>\n<h3 id=\"javaScript运行机制\"><a href=\"#javaScript运行机制\" class=\"headerlink\" title=\"javaScript运行机制\"></a><strong>javaScript运行机制</strong></h3></blockquote>\n<ul>\n<li>js执行任务分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务都在主线程中执行，形成一个执行栈，主线程之外还有一个任务队列（task queue），任务队列是<strong>事件触发线程</strong>管理的，只要异步任务有运行结果时，就会在任务队列中放置一个事件</li>\n<li>一旦执行栈中所有的同步任务执行完毕后，系统就才会去读取任务队列，将任务放入到执行栈中执行（<strong>任务队列是一个先进先出的数据结构</strong>）</li>\n</ul>\n<p>下图是主线程和任务队列的示意图（图片来自参考资料2中）<br><img src=\"/images/blog_images/js_event_loop.png\" alt=\"image\"></p>\n<p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复</p>\n<blockquote>\n<h3 id=\"事件循环机制\"><a href=\"#事件循环机制\" class=\"headerlink\" title=\"事件循环机制\"></a><strong>事件循环机制</strong></h3></blockquote>\n<p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href=\"https://vimeo.com/96425312\" target=\"_blank\" rel=\"noopener\">Help, I’m stuck in an event-loop</a>》，图片来自参考资料2中）<br><img src=\"/images/blog_images/js_event_loop2.png\" alt=\"image\"></p>\n<ul>\n<li><p>上述循环机制的核心是：<strong>js引擎线程</strong>和<strong>事件触发线程</strong></p>\n</li>\n<li><p>主线程运行时会产生执行栈，栈中的调用某些api时，当满足触发条件后，会将事件放入到事件队列中去</p>\n</li>\n<li><p>但是对于定时器（<strong>setTimeout和setInterval</strong>）来说它是通过<strong>定时器引擎线程</strong>来控制回调函数在等待特定的时间后添加到事件队列中</p>\n</li>\n</ul>\n<p>定时器要注意的一点就是设置的时间间隔：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(&apos;2&apos;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;1&apos;);</span><br><span class=\"line\">//执行结果是 先 “1” 后 “2”</span><br></pre></td></tr></table></figure>\n<p>虽然上述的代码中设置的时间间隔是0，但是根据W3C的HTML标准中的规定定时器最小的时间间隔不得低于4ms，低于4ms的间间隔算为4ms，即使是按0ms来，还是会先执行“1”，因为事件队列中任务总是要等到主线程执行完了之后才执行</p>\n<blockquote>\n<h3 id=\"setTimeOut和setInterval在事件循环机制中的区别\"><a href=\"#setTimeOut和setInterval在事件循环机制中的区别\" class=\"headerlink\" title=\"setTimeOut和setInterval在事件循环机制中的区别\"></a><strong>setTimeOut和setInterval在事件循环机制中的区别</strong></h3></blockquote>\n<ul>\n<li><p>主线程设置一个定时器后，setInterval在每个一段时间都会执行一个回调函数（回调函数就会被定时器引擎线程放入到事件队列中去），但是当主线程执行时间很长（时间大于好几个setInterval设置的时间间隔），那么事件队列中就会存在有好几个setInterval的回调函数，在主线程执行完后去执行事件队列中的事件，那么堆叠着的定时器回调函数就会连续执行（累计效应），setTimeOut没有这样的问题</p>\n</li>\n<li><p>还有一种情况就是把浏览器最小化后，setInterval并不是不执行程序，回调函数还是会被放到事件队列中去，但是不会被执行，当浏览器打开以后，这些回调函数就会被一起全部执行</p>\n</li>\n<li><p>所以最好的方法就是用setTimeOut来模拟setInterval，或者用requestAnimationFrame</p>\n</li>\n<li><p><strong>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。</strong></p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"事件循环进阶：macrotask与microtask\"><a href=\"#事件循环进阶：macrotask与microtask\" class=\"headerlink\" title=\"事件循环进阶：macrotask与microtask\"></a><strong>事件循环进阶：macrotask与microtask</strong></h3></blockquote>\n<ul>\n<li>上面讲的事件循环机制在es5中的情况是够用了，但是es6中就会遇到一些问题了</li>\n</ul>\n<p>如下题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&apos;setTimeout&apos;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function() &#123;</span><br><span class=\"line\">    console.log(&apos;promise1&apos;);</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&apos;promise2&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure>\n<p>他执行的正确顺序是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br></pre></td></tr></table></figure>\n<p>这个知识点自己接触的较少，参考<a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br><a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html</a></p>\n","categories":["javascript"],"tags":["jsִ执行机制 时间循环机制"]},{"title":"磨刀不误砍柴工","url":"http://yoursite.com/2018/08/15/hello-world/","content":"<p>本博客实际编写时间是2018-09-09，将以前记录在word中的笔记进行了整和，将其中重要的知识重新梳理写入博客，之后将在博客中记录的自己的成长过程</p>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"资源库收藏\"><a href=\"#资源库收藏\" class=\"headerlink\" title=\"资源库收藏\"></a>资源库收藏</h3><p><a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">阿里矢量图库</a><br><a href=\"https://icomoon.io\" target=\"_blank\" rel=\"noopener\">icomoon</a><br><a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">详细列出了哪些CSS属性在不同的渲染引擎中是否会触发重排或重绘</a><br>关于网络性能<br>    <a href=\"http://imweb.io/topic/5b6fd3c13cb5a02f33c013bd\" target=\"_blank\" rel=\"noopener\">http://imweb.io/topic/5b6fd3c13cb5a02f33c013bd</a><br>    <a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"><span class=\"comment\">### 推荐书籍</span></span><br><span class=\"line\"></span><br><span class=\"line\">    《Webkit技术内幕》：有关浏览器内核的</span><br><span class=\"line\">    《大型网站性能监测、分析与优化》</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br></pre></td></tr></table></figure>","categories":["javascript"],"tags":["html"]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]