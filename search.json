[{"title":"从关键渲染路径看性能优化","url":"http://yoursite.com/2018/11/15/critical_rander /","content":"<h2 id=\"什么是关键渲染路径\"><a href=\"#什么是关键渲染路径\" class=\"headerlink\" title=\"什么是关键渲染路径\"></a><strong>什么是关键渲染路径</strong></h2><ol>\n<li><p>浏览器在收到HTML、CSS 和 JavaScript ，将他们进行处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤。优化性能其实就是了解这些步骤中发生了什么 - 即关键渲染路径。<strong>通过优化关键渲染路径，我们可以显著缩短首次渲染页面的时间</strong></p>\n</li>\n<li><p>浏览器在收到html文件后，html解析器会将html文件解析成domTree，在遇到外链css文件时，开启网络请求线程去异步下载css文件，css文件下载完成后，css解析器会对其进行解析成为cssTree</p>\n<h3 id=\"domTree和cssTree的形成\"><a href=\"#domTree和cssTree的形成\" class=\"headerlink\" title=\"domTree和cssTree的形成\"></a><strong>domTree和cssTree的形成</strong></h3><p> <img src=\"/images/blog_images/critical_rander/1.jpg\" alt=\"image\"><br> (1). <strong>转换</strong>： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</p>\n<p> (2). <strong>令牌化</strong>： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“<html>”、“<body>”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</body></html></p>\n<p> (3). <strong>词法分析</strong>： 发出的令牌转换成定义其属性和规则的“对象”。</p>\n<p> (4). <strong>DOM构建</strong>： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。<br> <strong>总的来就是字节 → 字符 → 令牌 → 节点 → 对象模型</strong><br> <img src=\"/images/blog_images/critical_rander/2.jpg\" alt=\"image\"></p>\n</li>\n</ol>\n<pre><code>当然生成cssTree也是一样的过程，最终的cssTree如图：\n![image](/images/blog_images/critical_rander/2.jpg)\n(1). 注意的一点就是寝室浏览器提供的一组默认样式，下载过来的样式只是替换这些默认样式\n</code></pre><h3 id=\"domTree和cssTree结合生成渲染树\"><a href=\"#domTree和cssTree结合生成渲染树\" class=\"headerlink\" title=\"domTree和cssTree结合生成渲染树\"></a><strong>domTree和cssTree结合生成渲染树</strong></h3><pre><code>(1) cssTree是阻塞渲染的，在domTree完成之后，他会等待cssTree构建完毕才会执行两个相结合，形成renderTree\n![image](/images/blog_images/critical_rander/2.jpg)\n(2) 请注意 visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分\n</code></pre><h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a><strong>布局</strong></h3><pre><code>(1) 渲染树完成之后就是布局阶段，布局阶段就是根据渲染树中各个节点计算好的样式来确定节点在浏览器视口中的位置和大小，这一过程也被称为“自动重排”\n(2) 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的 **绝对像素**\n</code></pre><h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a><strong>渲染</strong></h3><pre><code>(1) 渲染是最后的阶段，将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”\n</code></pre><h3 id=\"步骤概括\"><a href=\"#步骤概括\" class=\"headerlink\" title=\"步骤概括\"></a><strong>步骤概括</strong></h3><pre><code>下面简要概述了浏览器完成的步骤：\n\n    - 处理 HTML 标记并构建 DOM 树。\n\n    - 处理 CSS 标记并构建 CSSOM 树。\n\n    - 将 DOM 与 CSSOM 合并成一个渲染树。\n\n    - 根据渲染树来布局，以计算每个节点的几何信息。\n\n    - 将各个节点绘制到屏幕上。\n**_优化关键渲染路径_就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间**。 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。如果 DOM 或 CSSOM 被修改，您只能再执行一遍以上所有步骤，以确定哪些像素需要在屏幕上进行重新渲染。\n</code></pre><h2 id=\"优化关键渲染路径\"><a href=\"#优化关键渲染路径\" class=\"headerlink\" title=\"优化关键渲染路径\"></a><strong>优化关键渲染路径</strong></h2><pre><code>### **css阻塞及优化**\n1. css是被视为阻塞渲染的资源，但对于有媒体类型和媒体查询的样式link，不适合媒体类型和查询的设备是不会阻塞渲染的(但仍然会下载资源)，例如：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link href=&quot;style.css&quot;    rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt;</span><br><span class=\"line\">&lt;link href=&quot;portrait.css&quot; rel=&quot;stylesheet&quot; media=&quot;orientation:portrait&quot;&gt;</span><br><span class=\"line\">&lt;link href=&quot;print.css&quot;    rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n## **js阻塞及优化**\n1. html在解析的过程中遇到js（会修改dom）会停止解析，执行js脚本，而且因为JavaScript 允许我们修改网页的方方面面：内容、样式以及它如何响应用户交互，所以防止与css样式的冲突，js会等到cssTree解析完成才执行，然后执行dom解析，从而延迟页面的渲染时间，可以总结为：\n    - 脚本在文档中的位置很重要。\n    - 当浏览器遇到一个 script 标记时（**不管是内联脚本还是外联脚本**），DOM 构建将暂停，直至脚本完成执行。\n    - JavaScript 可以查询和修改 DOM 与 CSSOM。\n    - JavaScript 执行将暂停，直至 CSSOM 就绪。\n2. 解决方法就是将js脚本标记为异步，异步加载的方法有如下几种\n\n    - script标签设置defer，可以使外联脚本也可以是内敛脚本，这个脚本是等到dom树构建完毕才按顺序执行（**现在的浏览器都支持了**）\n    &gt; 如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。 所以这意味着什么呢？HTML 文档解析不受影响，等 DOM 构建完成之后 defer 脚本执行，但脚本执行之前需要等待 CSSOM 构建完成。在 DOM、CSSOM 构建完毕，defer 脚本执行完成之后，DOMContentLoaded 事件触发。\n\n    - script标签设置async，只能是外部脚本，这个脚本加载完就执行，（**IE10及以上， 如果将脚本设置为async，会有一个区别，DCL的触发不需要等待async的脚本被执行**）\n    &gt; 如果 script 标签中包含 async，则 HTML 文档构建不受影响，解析完毕后，DOMContentLoaded 触发，而不需要等待 async 脚本执行、样式表加载等等(前提是js在html解析后才加载完成，如果在html解析过程中还是为停下来执行脚本)。\n\n    - 还有一种就是通过脚本创建script标签，插入到dom中\n\n\n3. 监测页面渲染树构建的事件有onreadystatechange，还有可以在构建各个阶段通过document.readystate来查看状态，document.readystate一共有三种状态\n    - Loading：这是整个过程的起始时间戳，浏览器即将开始解析第一批收到的 HTML 文档字节。\n\n    - Interactive：表示浏览器完成对所有 HTML 的解析并且 DOM 构建完成的时间点。\n\n    - Complete：顾名思义，所有处理完成，并且网页上的所有资源（图像等）都已下载完毕，也就是说，加载转环已停止旋转。\n\n\n4. 还有两个很重要的事件就是document的 **load** 和 **domContentLoaded**事件：\n\n    - domContentLoaded表示当所有普通（既不是defer也不是async）与defer的脚本被执行，并且已经没有任何阻塞脚本的样式时，这意味着现在我们可以构建渲染树了。如果没有阻塞解析器的 JavaScript，则 DOMContentLoaded 将在 domInteractive 后立即触发。**DOMContentLoaded只在addEventListener上有效果**\n\n    - 另外需要提一下的是，我们在 jQuery 中经常使用的 $(document).ready(function() { // ...代码... }); 其实监听的就是 DOMContentLoaded 事件，而 $(document).load(function() { // ...代码... }); 监听的是 load 事件。\n\n5. 优化方法:\n    - 对于并非首次渲染所需要的javascript，可以使用 async 属性\n\n    - CSS 是构建渲染树的必备元素，首次构建网页时，JavaScript 常常受阻于 CSS。确保将任何非必需的 CSS 都标记为非关键资源（例如打印和其他媒体查询），并应确保尽可能减少关键 CSS 的数量，以及尽可能缩短传送时间。\n\n    - 尽早在 HTML 文档内指定所有 CSS 资源，以便浏览器尽早发现 &lt;link&gt; 标记并尽早发出 CSS 请求。\n\n    - 一个样式表可以使用 CSS import (@import) 指令从另一样式表文件导入规则。不过，应避免使用这些指令，因为它们会在关键路径中增加往返次数：只有在收到并解析完带有 @import 规则的 CSS 样式表之后，才会发现导入的 CSS 资源。\n\n6. 优化关键渲染路径的常规步骤如下：\n\n    - 对关键路径进行分析和特性描述：资源数、字节数、长度。\n\n    - 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。\n\n    - 优化关键字节数以缩短下载时间（往返次数）。\n\n    - 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。\n</code></pre><h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><p><a href=\"https://zhuanlan.zhihu.com/p/25876048\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25876048</a><br>[<a href=\"https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html]\" target=\"_blank\" rel=\"noopener\">https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html]</a>  (<a href=\"https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html\" target=\"_blank\" rel=\"noopener\">https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html</a>)<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/page-speed-rules-and-recommendations#javascript_2\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/page-speed-rules-and-recommendations#javascript_2</a></p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"web缓存","url":"http://yoursite.com/2018/11/08/web_cache /","content":"<h3 id=\"web缓存\"><a href=\"#web缓存\" class=\"headerlink\" title=\"web缓存\"></a><strong>web缓存</strong></h3><ol>\n<li><p>从网络性能优化方面，利用缓存机制是一种很常用的优化网页性能的方法，根据自己网页的情况，制作出一个适合的缓存机制能够极大的提高页面的加载资源的速度，从而使网页能够更快的在用户面前展示</p>\n</li>\n<li><p>web缓存分类：<br> <img src=\"/images/blog_images/web_cache/web_cache1.jpg\" alt=\"image\"></p>\n<h2 id=\"HTTP缓存\"><a href=\"#HTTP缓存\" class=\"headerlink\" title=\"HTTP缓存\"></a>HTTP缓存</h2><ul>\n<li><p>先但从上面图中的http缓存开始看，http缓存分为强缓存和协商缓存，来详细的介绍介绍<br>  <strong>强缓存</strong></p>\n<ul>\n<li><strong>(http1.0)Pragma</strong>：<blockquote>\n<p>(1) 上面的图片没有涉及到的一点就是Pragma这个http1.0 时代的产物（还有expires），虽然现在这个两个字段已经过时，但部分网站还是会携带他们，因为他们可以向下兼容，例如<a href=\"https://ke.qq.com/\" target=\"_blank\" rel=\"noopener\">腾讯课堂</a><br>(2) 当该字段值为no-cache的时候，不会对资源进行缓存，记住一点：<strong>Pragma的优先级是高于Cache-Control</strong></p>\n</blockquote>\n</li>\n<li><p><strong>(http1.0)Expires</strong></p>\n<blockquote>\n<p>(1) 对于http而言用来开启缓存的就是使用expires，服务器给设置的expires如：Expires: Fri, 11 Jun 2021 11:33:01 GMT，这个时间是服务器的时间，但是当浏览器访问该服务器的时候，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了<br>(2) 记住一点，如果Pragma头部和Expires头部同时存在，则起作用的会是Pragma，有兴趣的同学可以自己试一下</p>\n</blockquote>\n</li>\n<li><p><strong>(http1.1)Cache-Control</strong></p>\n<blockquote>\n<p>(1) 针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题, Cache-Control中的Max-Age使用的是客户端本地时间的计算，因此不会有这个问题<br>(2) Cache-Control的字段的主要值有：no-store、no-cache、max-age、public、private。Cache-Control也是一个通用首部字段，这意味着它能分别在请求报文和响应报文中使用。在RFC中规范了 Cache-Control 的格式为：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;Cache-Control&quot; &quot;:&quot; cache-directive</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>(3) 作为请求首部时，cache-directive 的可选值有：<br>  <img src=\"/images/blog_images/web_cache/web_cache2.jpg\" alt=\"image\"><br>(4) 作为响应首部时，cache-directive 的可选值有：<br>  <img src=\"/images/blog_images/web_cache/web_cache3.jpg\" alt=\"image\"><br>(5) Cache-Control 允许自由组合可选值，例如：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=3600, must-revalidate</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。 当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用<br>(3) <strong>优先级从高到低分别是 Pragma -&gt; Cache-Control -&gt; Expires</strong> </p>\n</blockquote>\n<p><strong>协商缓存</strong></p>\n</li>\n<li><p><strong>(http1.0)Last-Modified和If-Modified-Since</strong></p>\n<blockquote>\n<p>(1) 服务器通过将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上（Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT），客户端和服务端请求响应的过程看如下图就很清楚了<br>  <img src=\"/images/blog_images/web_cache/web_cache4.jpg\" alt=\"image\"><br>  至于传递标记起来的最终修改时间的请求报文首部字段一共有两个<br>  ① If-Modified-Since: Last-Modified-value（大部分用这个字段）<br>  该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。<br>  当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。<br>  ② If-Unmodified-Since: Last-Modified-value<br>  该值告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。 Last-Modified 存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源），还有一个缺陷就是只能精确到1s，1秒之内的资源的变化他察觉不到。</p>\n</blockquote>\n<blockquote>\n</blockquote>\n</li>\n<li><p><strong>(http1.1)If-None-Match和IETag</strong></p>\n<blockquote>\n<p>(1) 为了解决上述Last-Modified可能存在的不准确的问题（还有1s之内多次修改的情况），Http1.1还推出了 ETag 实体首部字段。 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志）就像指纹一样，在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端(Etag: “5d8c72a5edda8d6a:3239”)，当客户端再访问该服务器的时候就会将该唯一标识符以If-None-Match：”5d8c72a5edda8d6a:3239”（大部分用这个字段）来发送给服务器，如果相同返回304，不相同则获取新的资源<br>(2) 当然还有少数运用 If-Match: ETag-value字段，告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。</p>\n</blockquote>\n</li>\n<li><p>缓存头部优劣势对比图：<br>  <img src=\"/images/blog_images/web_cache/web_cache4.jpg\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>针对于缓存的刷新行为</p>\n<ul>\n<li>我们可以把刷新/访问界面的手段分成三类：<ul>\n<li>在URI输入栏中输入然后回车/通过书签访问</li>\n<li>F5/点击工具栏中的刷新按钮/右键菜单重新加载</li>\n<li>Ctl+F5</li>\n</ul>\n</li>\n<li><p>在浏览器中，有时候你会发现通过不同的手段访问/刷新界面页面的呈现速度是不一样的，比如我们第一次访问网站时，在响应头重设置一下的响应头：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=31104000</span><br><span class=\"line\">Expires: Thu, 20 Jul 2017 02:18:41 GMT</span><br><span class=\"line\">Last-Modified: Fri, 15 Jul 2016 04:11:51 GMT</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>在URI输入栏中输入然后回车</strong>: 我们可以看到返回响应码是 200 OK (from cache)，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容</p>\n</li>\n<li><p><strong>F5/点击工具栏中的刷新按钮/右键菜单重新加载</strong>: F5的作用和直接在URI输入栏中输入然后回车是不一样的，F5会让浏览器无论如何都发一个HTTP Request给Server，即使先前的响应中有Expires头部所以，当我在当前网页中按F5的时候，浏览器会发送一个HTTP Request给Server，但是包含这样的Headers:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0</span><br><span class=\"line\">If-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT</span><br></pre></td></tr></table></figure>\n<p>其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送</p>\n</li>\n<li><p><strong>Ctl+F5</strong>:Ctrl+F5要的是彻底的从Server拿一份新的资源过来，所以不光要发送HTTP request给Server，而且这个请求里面连If-Modified-Since/If-None-Match都没有，这样就逼着Server不能返回304，而是把整个资源原原本本地返回一份.实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTP Headers。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。在Chrome 51 中会包含两个头部信息， 作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Pragma: no-cache</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缓存实践<br> 综上对各种HTTP缓存控制头部的对比以及用户可能出现的浏览器刷新行为的讨论，当我们在一个项目上做http缓存的应用时，我们实际上还是会把上述提及的大多数首部字段均使用上。</p>\n<h2 id=\"数据缓存\"><a href=\"#数据缓存\" class=\"headerlink\" title=\"数据缓存\"></a>数据缓存</h2></li>\n<li>针对数据缓存可以看我的这篇文章<a href=\"https://shine-hfrao.github.io/2018/09/17/Browser_Cache/\" target=\"_blank\" rel=\"noopener\">数据缓存sessionStorage, localStorage, cookie</a></li>\n</ol>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><strong>参考资料</strong></h3><ol>\n<li><a href=\"https://github.com/amandakelake/blog/issues/43\" target=\"_blank\" rel=\"noopener\">https://github.com/amandakelake/blog/issues/43</a></li>\n<li><a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">http://imweb.io/topic/5795dcb6fb312541492eda8c</a></li>\n<li><a href=\"http://www.dailichun.com/2018/03/12/whenyouenteraurl.html\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#_2\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#_2</a></li>\n</ol>\n","categories":["网络"],"tags":["网络"]},{"title":"ES6知识点整理","url":"http://yoursite.com/2018/10/30/ES6/","content":"<h2 id=\"声明let和const\"><a href=\"#声明let和const\" class=\"headerlink\" title=\"声明let和const\"></a><strong>声明let和const</strong></h2><ol>\n<li><p>ES6具有了块级作用域概念，块级作用域：只在它当前的代码段（花括号或括号）之间有效</p>\n</li>\n<li><p>let和const共同的特点：</p>\n<ul>\n<li>不存在变量提升；（变量一定要先声明再使用，在变量声明之前使用就会报错）</li>\n<li>通过let和const定义的变量具有块级作用域的概念（暂时性死区），即只在当前作用域有效</li>\n<li>不允许重复声明（Let个const声明一个变量以后不能被重复声明var，let和const都不可以）</li>\n</ul>\n</li>\n<li><p>const声明的变量是一个不可以改变的量，原始值改变不了，引用值的引用不可改变但是引用值本身的内容是可以改变的</p>\n</li>\n</ol>\n<h2 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a><strong>变量的解构赋值</strong></h2><ol>\n<li><p><strong>数组的结构赋值</strong>（有序）<br> 实质：模式匹配</p>\n<ul>\n<li>let [a, b, c] = [1, 2, 3];</li>\n<li>let [a, [b, [c]]] = [1, [2, [3]]];</li>\n<li>解构失败：let [a, b] = [2] 输出a是2，b是undefined;</li>\n<li>不完全解构：let [a, b] = [1, 2, 3] 输出a是1, b是2;</li>\n<li>这样会报错：let [a] = 1,因为右边的值不具备这样迭代器的接口</li>\n<li>默认值：let [a = 10] = [20]; 先走对应匹配的模式（判断是否绝对等于undefined ）    就是20，如果模式没有就回来找自己的默认值也就是10<ul>\n<li><strong>例如</strong>：let [a = 10] = [null]; 输出a = null; let [a = 10] = [undefined];输出a = 10(a跟对应的值是空或undefined取默认值，即绝对等于undefined)</li>\n</ul>\n</li>\n<li>还有一点就是：惰性取值,比如：let[x = fn()] = [2]; 输出x是等于2，但是fn是不执行的，只有等于fn()的时    候才执行</li>\n<li>个别例子：let[x=y, y=2] = []; 输出想x, y 会报错 ，因为y在定义之前被调用了</li>\n</ul>\n</li>\n<li><p><strong>对象的结构赋值</strong>（无序）</p>\n<ul>\n<li>对象的结构赋值是无序的,以下都可以：<br>  let { foo, add } = { foo: 123, add: 234 };<br>  let { foo, add } = { add: 234, foo: 123 };</li>\n<li>判断是否绝对等于undefined ：<br>  let { bar } = { foo: 123, bar: null } 输出bar = null<br>  let { bar } = { foo: 123 } 输出bar = undefined<br>  let { bar } = { foo: 123, bar: undefined } 输出bar = undefined</li>\n<li>默认值：<br>  let {x=3} = {} 输出x = 3,跟数组的结构赋值是一样的</li>\n<li>典型例子：<br>  let {foo: bar} = {foo :123} 输出bar = 123, foo是报错（未定义）<br>  let {aa, bb} = {aa:123, bb:234} 的实质是 let { aa:aa, bb:bb } = { aa:     123,     bb: 234 } 这种key跟value相同的时候写一个也是一种简写，前面的    那个aa只是代表的一个模式，是根据模式进行的匹配，不具有真正的意义</li>\n</ul>\n</li>\n<li><p><strong>当然对象解构赋值和数组的解构赋值有时会混在一起使用</strong>:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">        p: [</span><br><span class=\"line\">            &quot;hello&quot;,</span><br><span class=\"line\">            &#123; y : 123 &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">let &#123;p:p, p:[s,&#123;y&#125;]&#125; = obj</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(x);         //hello</span><br><span class=\"line\">console.log(y);         //123</span><br><span class=\"line\">console.log(p);         //[&quot;hello&quot;, 123]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>对象和数组的解构赋值还存在包装类，内置对象中，如下</strong>：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a, b, c, d] = &apos;love&apos;;</span><br><span class=\"line\">    a   //&quot;l&quot;</span><br><span class=\"line\">    b   //&quot;0&quot;</span><br><span class=\"line\">    c   //&quot;v&quot;</span><br><span class=\"line\">    d   //&quot;e&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let&#123;length: len&#125; = &apos;123&apos;;</span><br><span class=\"line\">    len //3</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let&#123;pow, ceil, floor&#125; = Math</span><br><span class=\"line\">let&#123;toString&#125; = 123;</span><br><span class=\"line\">let&#123;toString: s&#125; = false;</span><br><span class=\"line\">console.log(toString == Number.prototype.toString);//true</span><br><span class=\"line\">console.log(s == Boolean.prototype.toString);//true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>解构赋值可以应用在函数中，也可以应用在变量之间的转换, import导入</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [[1, 2], [3, 4]].map(function([a, b])&#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    arr         //[3, 7]</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1;</span><br><span class=\"line\">let b = 2;</span><br><span class=\"line\">[a, b] = [b, a];</span><br><span class=\"line\">console.log(a, b);  //2,1</span><br></pre></td></tr></table></figure>\n<ul>\n<li>还有就是在vuex中用的比较多：import {vuex, mapState, mapMutations} from ‘vuex’</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"字符串的扩展\"><a href=\"#字符串的扩展\" class=\"headerlink\" title=\"字符串的扩展\"></a><strong>字符串的扩展</strong></h2><ol>\n<li><p><strong>模版字符串（读反撇号），又叫增强字符串</strong></p>\n<ul>\n<li>可以添加插值语法${}，更好的处理了字符串拼接的问题，更规范，语义化好，但注意插值语法中的变量在字符串之后改变了是不会影响字符串的改变的,{}会将不是字符串的转变成字符串比如一个{}就会转变成[object Object]，即调用toString方法     </li>\n<li>模版字符串可以自由的进行换行等操作，不需要转义字符</li>\n<li>在字符串中添加变量、常量、方法（表达式）</li>\n<li>如果要在模版字符串中用字符串反撇号或者字符串${}要使用\\转义字符</li>\n<li><strong>优点</strong>：<br>  (1)更标准的字符串，更好的处理了字符串拼接的问题<br>  (2)语义化更好<br>  (3)防止注入 XSS</li>\n</ul>\n</li>\n<li><p><strong>标签模版，标签模版的实质—–函数调用的特殊形式</strong></p>\n<ul>\n<li><p>会按照模版的进行分开放到一个数组中作为第一个参数，然后将模版的内容依次作为后面的参数,如下面的几个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert`12345`;</span><br><span class=\"line\"></span><br><span class=\"line\">function show(name)&#123;</span><br><span class=\"line\">    console.log(arguments[0]);          //[&apos;hello&apos;, &apos;, welcome to&apos;, &apos;&apos;]</span><br><span class=\"line\">    console.log(arguments[1]);          //&apos;xiaozhang&apos;</span><br><span class=\"line\">    console.log(arguments[2]);          //&apos;qingdao&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">show`xiaoming`;</span><br><span class=\"line\">var name = &apos;xiaozhang&apos;, place = &apos;qingdao&apos;;</span><br><span class=\"line\">show`hello$&#123;name&#125;, welcome to$&#123;place&#125;`</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重要应用——过滤HTML字符串<br><img src=\"/images/blog_images/ES6/1.png\" alt=\"image\"><br><img src=\"/images/blog_images/ES6/2.png\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li><p><strong>字符串包装类对象新的方法</strong>：includes(), startsWith(), endsWith() repeat(数字)</p>\n</li>\n</ol>\n<h2 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a><strong>函数的扩展</strong></h2><ol>\n<li><p>函数参数可以使用默认值，传参时可以结合解构赋值的形式，如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(&#123;x, y=5&#125;)&#123;</span><br><span class=\"line\">        console.log(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">test(&#123;x:1, y:4&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>要注意的是函数参数中使用这种ES6语法时，x和y都是使用let定义的，即不可以重复声明</li>\n</ul>\n</li>\n<li>函数中的参数还可以使用REST参数（扩展运算符） <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(...arg)&#123;</span><br><span class=\"line\">        console.log(arg)    //[1,3,4]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">test(1,3,4)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a><strong>箭头函数</strong></h2><p>箭头函数有以下特点：</p>\n<p>(1) 不能通过new操作符来执行</p>\n<p>(2) 函数中没有arguments（虽然没有arguments，但可以通过…arg来获得参数列表的）</p>\n<p>(3) 函数没有原型</p>\n<p>(4) 函数中的this绑定取决于离箭头函数最近的非箭头函数的父级作用域，并且this的绑定是不可改变的</p>\n<h2 id=\"数组的扩展\"><a href=\"#数组的扩展\" class=\"headerlink\" title=\"数组的扩展\"></a><strong>数组的扩展</strong></h2><ol>\n<li><p>数组的扩展除了上述所说的数组的解构赋值，数组中还可以使用REST参数（扩展运算符）</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newArr = [...arr1, ...arr2, ...arr3];</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, ...y] = [1];</span><br><span class=\"line\">console.log(x,y)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将字符串进行包装成对象，然后被转换成数组（扩展运算符 可以在特定的环境下把类数组转化为数组）</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var strArr = [...&apos;xiao&apos;];</span><br><span class=\"line\">console.log(strArr)     //[&apos;x&apos;, &apos;i&apos;, &apos;a&apos;, &apos;o&apos;]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组还新增了许多API</p>\n<p> (1) Array.of()构造数组，参数依次是数组的值</p>\n<p> (2) Array .from( ) 将类数组转化为数组,如果参数是数组则返回这个数组本身，from还可以穿第二个参数<br> <img src=\"/images/blog_images/ES6/3.png\" alt=\"image\"><br> <img src=\"/images/blog_images/ES6/4.png\" alt=\"image\"><br> 回调函数类似于map方法<br> <img src=\"/images/blog_images/ES6/5.png\" alt=\"image\"><br> <img src=\"/images/blog_images/ES6/6.png\" alt=\"image\"></p>\n<p> (3) Array.prototype.copyWidthin(): 是按照一定的格式进行重写，改变原数组</p>\n<p> (4) Array.prototype.fill() ,第一个单数是要填补的内容，第二个和第二个分别是起始位置和中止位置</p>\n<p> (5) Array.prototype.entries()</p>\n<p> (6) Array.prototype.keys()</p>\n<p> (7) Array.prototype.values()</p>\n<p> (8) Array.prototype.includes(): includes()返回的是一个Boolean值，查看数组中是否有这个值，跟indexof的区别是indexof找不到NaN 而includes可以</p>\n<p> (9) Array.prototype.find(): Find()找到满足条件的第一个数</p>\n<p> (10) Array.prototype.findIndex(): FindIndex()找到满足条件的第一个数的下标（超出时返回的是-1）</p>\n</li>\n</ol>\n<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a><strong>对象的扩展</strong></h2><ol>\n<li><p>属性的简洁表示法以及属性名表达式</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = &apos;123&apos;;</span><br><span class=\"line\">var obj = &#123;foo: foo&#125;    //可以简写为 </span><br><span class=\"line\">var obj = &#123;foo&#125;</span><br></pre></td></tr></table></figure>\n<p> <img src=\"/images/blog_images/ES6/7.png\" alt=\"image\"></p>\n</li>\n<li><p>属性名表达式：<br> <img src=\"/images/blog_images/ES6/8.png\" alt=\"image\"><br> <img src=\"/images/blog_images/ES6/9.png\" alt=\"image\"> <img src=\"/images/blog_images/ES6/10.png\" alt=\"image\"></p>\n</li>\n<li><p>对象还新增了许多API</p>\n<ul>\n<li><p>Object.is()</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.is(&apos;foo&apos;, &apos;foo&apos;))    //true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Object.is(NaN, NaN))    //true</span><br><span class=\"line\">console.log(NaN === NaN)       //false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Object.is(+0, -0))      //false</span><br><span class=\"line\">console.log(+0 === -0)      //true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object.assign() 将若干个对象的可枚举属性放到一个对象当中去（当参数中只有一个obj是返回的就是和原来的一模一样的，就是是一个地址），返回的就是obj的地址<br><img src=\"/images/blog_images/ES6/11.png\" alt=\"image\"> <img src=\"/images/blog_images/ES6/12.png\" alt=\"image\"><br>还有如果只有一个参数且参数为数字、字符串等原始值时，（第一个参数null跟undefined都不可以，它们转化不成对象）<br><img src=\"/images/blog_images/ES6/13.png\" alt=\"image\"> <img src=\"/images/blog_images/ES6/14.png\" alt=\"image\"></p>\n</li>\n<li><p>Object.keys()  Object.values()  Object.entries()</p>\n<ul>\n<li>下面返回的都是迭代器对象<br><img src=\"/images/blog_images/ES6/18.png\" alt=\"image\"><br><img src=\"/images/blog_images/ES6/19.png\" alt=\"image\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>扩展运算符也可以用在对象上<br> <img src=\"/images/blog_images/ES6/15.png\" alt=\"image\"> <img src=\"/images/blog_images/ES6/16.png\" alt=\"image\"></p>\n<ul>\n<li>下面就是运用对象扩展运算符到Object.assign<br><img src=\"/images/blog_images/ES6/17.png\" alt=\"image\"></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"class类\"><a href=\"#class类\" class=\"headerlink\" title=\"class类\"></a><strong>class类</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用class类的函数不存在函数提升</span><br><span class=\"line\">function Person(name, age)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//相当于</span><br><span class=\"line\"></span><br><span class=\"line\">class Person1 &#123;     //新的语法糖 （糖衣语法）</span><br><span class=\"line\">    constructor(name, age)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this,age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(typeof Person1)//function</span><br><span class=\"line\">Person1()       //报错，用class声明的构造函数必须用new操作符进行运算</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal&#123;       //class里面默认执行严格模式,严格模式this不会指向window的要么没有（undefined）要么指向对象</span><br><span class=\"line\">    constructor(name, age=0)&#123;       //constructor没写也会自动添加上，相当于初始化this</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.weight = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat(food = 1)&#123;      //相当于定义原型上的方法</span><br><span class=\"line\">        this.weight += food</span><br><span class=\"line\">    &#125;\t\t\t</span><br><span class=\"line\">    drink(water = .5)&#123;</span><br><span class=\"line\">        this.weight += water</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a =function ()&#123;&#125;  //叫函数表达式</span><br><span class=\"line\"></span><br><span class=\"line\">//相当于</span><br><span class=\"line\"></span><br><span class=\"line\">const b = class &#123;   //叫class表达式</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function ()&#123;&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">//相当于 </span><br><span class=\"line\"></span><br><span class=\"line\">var a = new class&#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(&apos;xm&apos;)     //立即执行class,返回一个对象</span><br></pre></td></tr></table></figure>\n<ul>\n<li>this指向的问题：</li>\n</ul>\n<p><img src=\"/images/blog_images/ES6/20.png\" alt=\"image\"> <img src=\"/images/blog_images/ES6/21.png\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var age = 18;</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        this.age = 11;</span><br><span class=\"line\">        this.print = (name = &apos;haha&apos;) =&gt;&#123;</span><br><span class=\"line\">            console.log(this.age);//11 箭头函数具有绑定作用域的功能，箭头函数里面没有this，会绑定最近有this的父级</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = &#123;//对象里边是不存在作用域的</span><br><span class=\"line\">    age: 19,</span><br><span class=\"line\">    func: () =&gt;&#123;</span><br><span class=\"line\">        console.log(this.age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = new Person();</span><br><span class=\"line\">console.log(a.print());</span><br><span class=\"line\">b.func(); //18</span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态属性和静态方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.func = function ()&#123;&#125;</span><br><span class=\"line\">Person.name = &apos;haah&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>class的继承:原型和实例都会继承下来(通过Super)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = 1;</span><br><span class=\"line\">        this.weight = 100;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat(food)&#123;</span><br><span class=\"line\">        this.weight ++; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person extends Animal&#123;    //Person没有this(子类都没有this)</span><br><span class=\"line\">    constructor(name, sex = &apos;male&apos;)&#123;    //constructor和super在没有的情况下都是会默认调用的，但你写了constructor没写super函数会报错</span><br><span class=\"line\">        </span><br><span class=\"line\">        //使用this之前一定要调用super方法 super相当于Animal.call(this)</span><br><span class=\"line\">        </span><br><span class=\"line\">        super(name)//调用父类的构造方法来产生this =&gt;&#123;name, age, weight&#125; this</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat(food)&#123;</span><br><span class=\"line\">        Super.eat();</span><br><span class=\"line\">        this.weight ++; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//当super为对象时，super =&gt; Animal.prototype（即代表父类的原型对象，但是调用的环境是当前的环境，即this指向的是子类）当super作为函数，代表调用父类的构造函数</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class B extends A&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(B.__proto__)</span><br><span class=\"line\">console.log(B.__proto__ === A);//true</span><br><span class=\"line\">console.log(B.__proto__.prototype === A.prototype);//true</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES6中提供的迭代器Iterator\"><a href=\"#ES6中提供的迭代器Iterator\" class=\"headerlink\" title=\"ES6中提供的迭代器Iterator\"></a><strong>ES6中提供的迭代器Iterator</strong></h2><ol>\n<li>迭代器是一个对象，专门为可迭代的对象提供接口，这个方法用来遍历数据（数据的共同特点是有序的）</li>\n<li><p>特点：</p>\n<p> （1）每个迭代器对象都有next方法，每次执行next方法返回一个结果对象{value,done},value代表每次迭代的数据，done代表迭代是否结束Boolean值</p>\n<p> （2）每个迭代器有一个专用指针，迭代开始时指向数据结构的第一个值，每次调用next方法指针向下移动一位</p>\n<p> （3）支持for of循环，每次遍历都是调用迭代器对象的next方法、还可以被…运算符遍历</p>\n</li>\n<li><p>模拟一个数组的迭代器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createIterator(arr = []) &#123;</span><br><span class=\"line\">        let currentIndex = 0;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            next() &#123;</span><br><span class=\"line\">                if (arr.length - 1 &lt; currentIndex) &#123;</span><br><span class=\"line\">                    return &#123;</span><br><span class=\"line\">                        value: undefined,</span><br><span class=\"line\">                        done: false</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return &#123;</span><br><span class=\"line\">                        value: arr[currentIndex++],</span><br><span class=\"line\">                        done: true</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有默认的Iterator接口的有：Array Map Set String arguments NodeLists entries keys values, entries keys values会返回一个迭代器对象<br> （1）我们来看看数组中迭代接口来手动遍历数组，看看他是怎么工作的：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myArray = [ 1, 2, 3 ];</span><br><span class=\"line\">var it = myArray[Symbol.iterator]();</span><br><span class=\"line\">it.next();  // &#123; value:1, done:false &#125;</span><br><span class=\"line\">it.next();  // &#123; value:2, done:false &#125;</span><br><span class=\"line\">it.next();  // &#123; value:3, done:false &#125;</span><br><span class=\"line\">it.next();  // &#123; done:true &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p> (2)虽然对象没有迭代器，但你可以给任何想遍历的对象定义 @@iterator，举例来说：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    b: 3</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Object.defineProperty( myObject, Symbol.iterator, &#123;</span><br><span class=\"line\">    enumerable: false,</span><br><span class=\"line\">    writable: false,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    value: function() &#123;</span><br><span class=\"line\">        var o = this;</span><br><span class=\"line\">        var idx = 0;</span><br><span class=\"line\">        var ks = Object.keys( o );</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            next: function() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    value: o[ks[idx++]],</span><br><span class=\"line\">                    done: (idx &gt; ks.length)</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\">// 手动遍历 myObject</span><br><span class=\"line\">var it = myObject[Symbol.iterator]();</span><br><span class=\"line\">it.next(); // &#123; value:2, done:false &#125;</span><br><span class=\"line\">it.next(); // &#123; value:3, done:false &#125;</span><br><span class=\"line\">it.next(); // &#123; value:undefined, done:true &#125;</span><br><span class=\"line\">// 用 for..of 遍历 myObject</span><br><span class=\"line\">for (var v of myObject) &#123;</span><br><span class=\"line\">      console.log( v );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// 3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所有的迭代器都有symbol.iterator属性，必须通过[]形式访问来返回默认的迭代器,数组中的迭代器是默认指向下一个索引，返回的是索引值和values返回的一样<br>Map Set会把邻接链表转换成一个单向链表，指针每次指向一个节点，指针下移。支持双字节的输出，在for of遍历时如果有一个不可拆分的双字节，会将这个双字节输出（比如一个表情是双字节，就能够输出表情）</p>\n</li>\n<li><p><strong>生成器 Generator</strong><br> （1）用于生成迭代器，生成器是一个函数 有* yeild</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *createItervator()&#123; //生成器不能够通过new操作符来执行</span><br><span class=\"line\">    yield 1; //yield每一步就会暂停一次，如果有return就不可以再next了</span><br><span class=\"line\">    yield 2; //（即就不会执行下面的yield了，next执行后的返回的对象中done变为true）</span><br><span class=\"line\">    yield 3; //yield必须在生成器的函数中,yield是没有返回值的（即undefined）</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var i = createItervator();</span><br><span class=\"line\">i.next() //括号中可以添加参数作为上一次迭代的返回值</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *show(arr, string)&#123;</span><br><span class=\"line\">    yield *arr; //这里可以继续迭代</span><br><span class=\"line\">    yield *string; //这里可以继续迭代</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a><strong>Promise对象</strong></h2><ol>\n<li><p><strong>Promise</strong> :<br> (1)promise是一种异步编程的解决方案，所谓的promise简单的说就是一个容器，它里面存着未来会结束的事件。从语法上说，promise是一个对象，从他哪里可以获取异步操作的消息</p>\n<p> (2)Promise对象有两个特点</p>\n<p> ① Promise对象有三种状态pending，resolved，rejected，只有异步操作的结果会决定promise对象的状态，其他的操作都无效，这也是应征了promise单词承诺的意思<br> ② 一旦状态改变，状态就不会再改变了，而且状态只可能由pending变成resolved或pending变成rejected</p>\n<p> (3)有了promise对象，就可以将异步操作以同步的操作流程表达出来，避免了层层嵌套的回调函数（回调地狱v型代码）（将多层次的代码转变成两层）</p>\n<p> (4)Promise也有一些缺点，首先promise一旦建立就会立即执行，中途无法取消，其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n</li>\n<li><p><strong>再来说说Promise的API</strong><br> <strong>静态方法</strong></p>\n<ul>\n<li><p>ES6中static的静态方法现在只支持方法，还不支持属性<br>(1)Promise.all([p1, p2, p3])</p>\n<blockquote>\n<p>多个promise对象的集合,如果p1,p2,p3的状态都是resolved状态的话，会返回一个新的promise对象状态是resolved状态，且对应的值是p1，p2，p3对应值组成的数组，只要检查到有一个状态是rejected的话，返回一个状态为rejected的新的对象，对应的值是第一个被检查到状态为rejected对象的对应的值</p>\n</blockquote>\n<p>(2)Promise.race([p1, p2, p3])</p>\n<blockquote>\n<p>谁的状态先变了我就用谁的(谁先返回的就用谁的)，一般用于做测试，测试那个请求更快，返回的也是一个新的对象</p>\n</blockquote>\n<p>(3)Promise.resolve(1) 返回一个状态为resolved的对象<br>(4)Promise.reject(2) 返回一个状态为rejected的对象</p>\n<p><strong>实例方法</strong><br>(5)Promise.prototype.then 可接受成功和失败两个回调函数</p>\n<blockquote>\n<p>执行then函数，如果所传入的函数没有返回一个Promise实例对象，那么then函数会默认返回一个新的状态为resolved的Promise实例对象（对象中对应的值就是传进then参数函数执行返回的值），如果返回一个Promise实例对象则then函数会返回这个对象<br>(6)promise.prototype.catch 接受失败的回调函数</p>\n</blockquote>\n<blockquote>\n<p>Promise.reject(3).catch(err =&gt; console.log(err));//抓取失败时候的回调函数，会返回一个新的promise对象</p>\n<pre><code>相当于  .then(null, err =&gt; console.log(err))  \n</code></pre><p>我们平常会看到如下：成功就用then，失败就用catch：<br>Promise.reject(3).then(data =&gt; console.log(data)).catch(err =&gt; console.log(err));</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p><strong>自己封装一个Promise</strong></p>\n<p> <strong>ES6写法</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class myPromise&#123;</span><br><span class=\"line\">        constructor(fn)&#123;</span><br><span class=\"line\">            if(typeof fn !== &quot;function&quot;)&#123;</span><br><span class=\"line\">                throw TypeError(`$&#123;fn&#125; is not a function`)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            this.status = &quot;pending&quot;;</span><br><span class=\"line\">            this.data = undefined;</span><br><span class=\"line\">            this.resolveCBArr = [];</span><br><span class=\"line\">            this.rejectCBArr = [];</span><br><span class=\"line\">            let resolved = (suc) =&gt; &#123;</span><br><span class=\"line\">                if(this.status == &quot;pending&quot;)&#123;</span><br><span class=\"line\">                    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                        this.status = &quot;resolved&quot;;</span><br><span class=\"line\">                        this.data = suc;</span><br><span class=\"line\">                        this.resolveCBArr &amp;&amp; this.resolveCBArr.forEach(fn =&gt; fn());</span><br><span class=\"line\">                    &#125;, 0);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            let rejected = (err) =&gt; &#123;</span><br><span class=\"line\">                if(this.status == &quot;pending&quot;)&#123;</span><br><span class=\"line\">                    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                        this.status = &quot;rejected&quot;;</span><br><span class=\"line\">                        this.data = err;</span><br><span class=\"line\">                        this.rejectCBArr &amp;&amp; this.rejectCBArr.forEach(fn =&gt; fn());</span><br><span class=\"line\">                        //其实这里还有一步就是数组中执行后的函数进行unshift</span><br><span class=\"line\">                    &#125;, 0)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fn(resolved, rejected);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static resolve(suc) &#123;</span><br><span class=\"line\">            return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class=\"line\">                resolved(suc);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static reject(err) &#123;</span><br><span class=\"line\">            return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class=\"line\">                rejected(err);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        then(resolveFn, rejectFn) &#123;</span><br><span class=\"line\">            if(this.status == &quot;resolved&quot;)&#123;</span><br><span class=\"line\">                let res = resolveFn(this.data);</span><br><span class=\"line\">                if(res instanceof myPromise)&#123;</span><br><span class=\"line\">                    return res;</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class=\"line\">                        resolved(res);</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(this.status == &quot;rejected&quot;)&#123;</span><br><span class=\"line\">                let res = rejected(this.data);</span><br><span class=\"line\">                if(res instanceof myPromise)&#123;</span><br><span class=\"line\">                    return res;</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    return new myPromise((resolved, rejected) =&gt; &#123;</span><br><span class=\"line\">                        resolved(res);</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(this.status == &quot;pending&quot;)&#123;       </span><br><span class=\"line\">                console.log(&quot;pending&quot;);         </span><br><span class=\"line\">                return new myPromise((resolved, rejected) =&gt;&#123;   </span><br><span class=\"line\">                    this.resolveCBArr.push( ((resolveFn) =&gt; &#123;   </span><br><span class=\"line\">                        return () =&gt; &#123;</span><br><span class=\"line\">                            let res = resolveFn(this.data);</span><br><span class=\"line\">                            if(res instanceof myPromise)&#123;</span><br><span class=\"line\">                                res.then(resolved, rejected);</span><br><span class=\"line\">                            &#125;else&#123;</span><br><span class=\"line\">                                resolved(res);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;)(resolveFn) )</span><br><span class=\"line\"></span><br><span class=\"line\">                    this.rejectCBArr.push( ((rejectFn) =&gt; &#123;</span><br><span class=\"line\">                        return () =&gt; &#123;</span><br><span class=\"line\">                            let res = rejectFn(this.data);</span><br><span class=\"line\">                            if(res instanceof myPromise)&#123;</span><br><span class=\"line\">                                res.then(resolved, rejected);</span><br><span class=\"line\">                            &#125;else&#123;</span><br><span class=\"line\">                                resolved(res);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;)(rejectFn) )</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p> (1) ES6写法的好处就是可以利用箭头函数中this的特点，很方便的使用this，而在ES5中则要通过额外的变量（比如self）来保存this</p>\n<p> (2) 当resolved和rejected被异步执行时，.then的方法真相是的实例对象的状态还没改变时，这里需要用到一个方法就是将then参数中的两个函数暂时存储到实例对象属性中，待状态改变后，执行这个函数，因为考虑到会有多个一个实例对象会有then的调用所以避免覆盖，将他们用数组来存储，到时通过forEach来遍历执行</p>\n<p> (3) 还有就是不管是状态是啥都会返回一个新的Promise实例对象，在状态为pending时，这里用到的一点就是将状态改变后要执行的函数集中的放在返回的新Promise实例对象中，看代码，当函数执行后的返回值是一个Promise实例对象时，通过执行then操作然后将resolved和rejected作为参数传入then函数中，将状态传给外层新的Promise实例/对象，如果返回值不是一个Promise实例对象，则直接执行resolved</p>\n<p> (4) 因为Promise是处理异步任务的，而且是微任务，所以执行的顺序是在主执行栈执行完后执行，这里实现异步执行用setTimeout实现</p>\n</li>\n</ol>\n<!-- ## **ES6模块化**\n1. export导出， import...from导入 -->\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"对象的全面解析","url":"http://yoursite.com/2018/10/20/object /","content":"<h2 id=\"javascript的主要类型\"><a href=\"#javascript的主要类型\" class=\"headerlink\" title=\"javascript的主要类型\"></a><strong>javascript的主要类型</strong></h2><ol>\n<li>在 JavaScript 中一共有六种主要类型<ul>\n<li>简单基本类型（原始值）：<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>symbol（es6新增）</li>\n</ul>\n</li>\n<li>对象类型（引用值）：<ul>\n<li>object</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a><strong>对象类型</strong></h2><ol>\n<li><p>构造对象的两种形式：通过字面量（文字形式）和构造函数（构造形式），构造数组的除了字面量和构造函数外还有一个就是通过es6的Array.of()来构造数组，参数依次是数组的值。</p>\n</li>\n<li><p>null在typeof null 时会返回字符串 “object”，这是一个bug，历史遗留问题，其实null是原始值（简单基本类型）</p>\n</li>\n<li><p>实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为 <strong>复杂基本类型</strong>。<strong>函数</strong> 就是对象的一个子类型，它本质上跟普通对象一样只是可以调用，称为可调用对象，另外 <strong>数组</strong> 也是对象的一种类型</p>\n</li>\n<li><p>JavaScript 中还有一些对象子类型，通常被称为内置函数：</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"包装类对象\"><a href=\"#包装类对象\" class=\"headerlink\" title=\"包装类对象\"></a><strong>包装类对象</strong></h2><ol>\n<li>在必要的情况下引擎会把字符串和数字的字面量转换成响应的Number和String对象。null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</li>\n</ol>\n<h2 id=\"对象的访问\"><a href=\"#对象的访问\" class=\"headerlink\" title=\"对象的访问\"></a><strong>对象的访问</strong></h2><ol>\n<li><p>对象访问有两种形式一种是. 操作符另一种是 [] 操作符，.a 语法通常被称为“属性访问”，[“a”] 语法通常被称为“键访问”,这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。</p>\n</li>\n<li><p>[]操作符的好处就是：ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名，比如字符串的拼接</p>\n</li>\n<li><p>在对象中，属性名永远都是字符串，如果不是字符串那么它将被被转换成字符串</p>\n</li>\n</ol>\n<h2 id=\"对象的属性和方法\"><a href=\"#对象的属性和方法\" class=\"headerlink\" title=\"对象的属性和方法\"></a><strong>对象的属性和方法</strong></h2><ol>\n<li><p>一般人会把对一个对象属性的访问称为“属性访问”，如果这个属性是一个函数就会被称为方法访问，所有就会很容易认为这个函数是属于这个对象的，其实在函数调用时与其他函数有区别的就是函数执行时内部的this指向的区别，这个this确实是由函数的调用位置来决定的，但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为this是在运行时进行动态绑定的，所以函数永远不会“属于”一个对象，属性访问返回的函数和其他的函数没有任何区别（除了可能发生的隐式绑定this）</p>\n</li>\n<li><p>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——它们只是对于相同函数对象的多个引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">    foo: function() &#123;</span><br><span class=\"line\">        console.log( &quot;foo&quot; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var someFoo = myObject.foo;</span><br><span class=\"line\">someFoo; // function foo()&#123;..&#125;</span><br><span class=\"line\">myObject.foo; // function foo()&#123;..&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"对象属性的特性（属性描述符）\"><a href=\"#对象属性的特性（属性描述符）\" class=\"headerlink\" title=\"对象属性的特性（属性描述符）\"></a><strong>对象属性的特性（属性描述符）</strong></h2><ol>\n<li><p>从 ES5 开始，所有的属性都具备了属性描述符,如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class=\"line\">    value: 2,</span><br><span class=\"line\">    writable: true,             </span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    enumerable: true</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\">myObject.a; // 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>writable 决定是否可以修改属性的值</strong>, 设置为false后属性值不可修改，如果修改的话在非严格模式下不会报错也不会产生效果，在严格模式下会报错</li>\n<li><strong>Configurable只要属性是可配置的</strong>，就可以使用 defineProperty(..) 方法来修改属性描述符，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。<strong>要注意有一个小小的例外</strong>：即便属性是 configurable:false，我们还是可以把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，configurable:false 还会禁止删除这个属性,严格模式下会报错</li>\n<li><strong>Enumerable</strong>设置属性是否可枚举，比如说for in循环</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"如何设置对象不可变\"><a href=\"#如何设置对象不可变\" class=\"headerlink\" title=\"如何设置对象不可变\"></a><strong>如何设置对象不可变</strong></h2><ol>\n<li><p>结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）</p>\n</li>\n<li><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(对象)：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">    a:2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Object.preventExtensions( myObject );</span><br><span class=\"line\">myObject.b = 3;</span><br><span class=\"line\">myObject.b; // undefined</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</li>\n</ul>\n</li>\n<li><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false</p>\n</li>\n<li><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。</p>\n</li>\n</ol>\n<h2 id=\"对象中的-set-get\"><a href=\"#对象中的-set-get\" class=\"headerlink\" title=\"对象中的[[set]][[get]]\"></a><strong>对象中的[[set]][[get]]</strong></h2><ol>\n<li><p>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。</p>\n</li>\n<li><p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会忽略它们的 value 和writable 特性，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性</p>\n</li>\n<li><p>思考如下代码：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">// 给 a 定义一个 getter</span><br><span class=\"line\">    get a() &#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    Object.defineProperty(</span><br><span class=\"line\">        myObject, // 目标对象</span><br><span class=\"line\">        &quot;b&quot;, // 属性名</span><br><span class=\"line\">        118 ｜ 第 3 章</span><br><span class=\"line\">        &#123;   // 描述符</span><br><span class=\"line\">            // 给 b 设置一个 getter</span><br><span class=\"line\">            get: function()&#123; return this.a * 2 &#125;,</span><br><span class=\"line\">            // 确保 b 会出现在对象的属性列表中</span><br><span class=\"line\">            enumerable: true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">myObject.a; // 2</span><br><span class=\"line\">myObject.b; // 4</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不管是对象文字语法中的 get a() { .. }，还是 defineProperty(..) 中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"判断属性是否存在对象中\"><a href=\"#判断属性是否存在对象中\" class=\"headerlink\" title=\"判断属性是否存在对象中\"></a><strong>判断属性是否存在对象中</strong></h2><ol>\n<li><p>in操作符</p>\n</li>\n<li><p>对象.hasOwnProperty(属性) </p>\n</li>\n<li><p>对象.propertyIsEnumerable(属性) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true</p>\n</li>\n<li><p>Object.keys(对象) 会返回一个数组，包含所有可枚举属性，只会查找对象直接包含的属性</p>\n</li>\n<li><p>Object.getOwnPropertyNames(对象)会返回一个数组，包含所有属性，无论它们是否可枚举，只会查找对象直接包含的属性</p>\n</li>\n</ol>\n<h2 id=\"对象的枚举遍历\"><a href=\"#对象的枚举遍历\" class=\"headerlink\" title=\"对象的枚举遍历\"></a><strong>对象的枚举遍历</strong></h2><ol>\n<li><p>for in最适用于对象,遍历数组一般采用的就是for循环，但是遍历数组是按照索引有顺序的进行遍历的，但是对于对象来说顺序是不确定的，在不同的javascript引擎中可能不一样</p>\n</li>\n<li><p>在ES6中引入了一个新的for of循环，他会向被访问的对象请求一个迭代对象，然后调用迭代对象中的next方法来遍历所有返回值,但是对象没有迭代器接口，但我们可以自己定义(<a href=\"\">详细的迭代器解析</a>)，或则通过ES6中的新方法Object.keys(),Object.values(),Object.entries()</p>\n</li>\n</ol>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"有关原生函数封装的库","url":"http://yoursite.com/2018/10/14/Tools/","content":"<h3 id=\"浅度克隆\"><a href=\"#浅度克隆\" class=\"headerlink\" title=\"浅度克隆\"></a><strong>浅度克隆</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;abc&apos;,</span><br><span class=\"line\">    age : 123,</span><br><span class=\"line\">    sex : &apos;male&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj1 = &#123;&#125;</span><br><span class=\"line\"> function clone(origin,target)&#123;</span><br><span class=\"line\">    var target = target || &#123;&#125;;</span><br><span class=\"line\">    for(var propo in obj)&#123;</span><br><span class=\"line\">        target[propo] = origin[propo];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return target;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"深度克隆\"><a href=\"#深度克隆\" class=\"headerlink\" title=\"深度克隆\"></a><strong>深度克隆</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deepClone(target, origin) &#123;</span><br><span class=\"line\">    var target = target || &#123;&#125;;</span><br><span class=\"line\">    var arrStr = &apos;[object Array]&apos;;</span><br><span class=\"line\">    var toStr = Object.prototype.toString;</span><br><span class=\"line\">    if (origin != null) &#123;            //注意 undefined == null 返回的是true, 此处排除这两个的干扰 ，因为们俩都不是对象，也没有包装类</span><br><span class=\"line\">        for (var prop in origin) &#123;</span><br><span class=\"line\">            var ori = origin[prop];</span><br><span class=\"line\">            var tar = target[prop];</span><br><span class=\"line\">            if (ori !== &apos;null&apos; &amp;&amp; typeof(ori) == &apos;object&apos;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                console.log(toStr.call(ori) == arrStr);</span><br><span class=\"line\">                tar = (toStr.call(ori) == arrStr) ? [] : &#123;&#125;;</span><br><span class=\"line\">                target[prop] = deepClone(tar, ori)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                target[prop] = ori;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义数组push-模拟Array原型链上的push方法\"><a href=\"#自定义数组push-模拟Array原型链上的push方法\" class=\"headerlink\" title=\"自定义数组push,模拟Array原型链上的push方法 \"></a><strong>自定义数组push,模拟Array原型链上的push方法 </strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [];</span><br><span class=\"line\">Array.prototype.push = function () &#123;</span><br><span class=\"line\">    for(var i = 0; i &lt; arguments.length; i ++) &#123;</span><br><span class=\"line\">        this[this.length] = arguments[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自己设置的type返回值类型\"><a href=\"#自己设置的type返回值类型\" class=\"headerlink\" title=\"自己设置的type返回值类型\"></a><strong>自己设置的type返回值类型</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function type(target) &#123;</span><br><span class=\"line\">    var ret = typeof (target);</span><br><span class=\"line\">    var template = &#123;</span><br><span class=\"line\">        &apos;[object Array]&apos;: &apos;array&apos;,</span><br><span class=\"line\">        &apos;[object Object]&apos;: &apos;object&apos;,</span><br><span class=\"line\">        &apos;[object Number]&apos;: &apos;number-object&apos;,</span><br><span class=\"line\">        &apos;[object Boolean]&apos;: &apos;boolean-object&apos;,</span><br><span class=\"line\">        &apos;[object String]&apos;: &apos;string-object&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (target === null) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;else if(ret == &apos;object&apos;) &#123;</span><br><span class=\"line\">        var str = Object.prototype.toString.call(target);</span><br><span class=\"line\">        return template[str];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母\"><a href=\"#一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母\" class=\"headerlink\" title=\"一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母\"></a><strong>一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;dsXazhdkasxhdlkasjzdlksajdlksajlkdaXs&apos;;</span><br><span class=\"line\">function singleStr(str) &#123;</span><br><span class=\"line\">    var temp = &#123;&#125;,</span><br><span class=\"line\">        oldArr = str.split(&apos;&apos;),</span><br><span class=\"line\">        newArr = [],</span><br><span class=\"line\">        newStr = &apos;&apos;,</span><br><span class=\"line\">        temp = oldArr.unique();</span><br><span class=\"line\">    for (var prop in temp) &#123;</span><br><span class=\"line\">        if (temp[prop] == 1) &#123;</span><br><span class=\"line\">            newArr.push(prop);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    newStr = newArr[0];</span><br><span class=\"line\">    return newStr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Array.prototype.unique = function () &#123;</span><br><span class=\"line\">    var temp = &#123;&#125;,</span><br><span class=\"line\">        len = this.length;</span><br><span class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if (!temp[this[i]]) &#123;</span><br><span class=\"line\">            temp[this[i]] = 1;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            temp[this[i]] += 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母-别人编写\"><a href=\"#一个字符串-a-z-组成，请找出该字符串第一个只出现一次的字母-别人编写\" class=\"headerlink\" title=\"一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母(别人编写)\"></a><strong>一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母(别人编写)</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;mdsaahjzsjkjkjkjkvlkllopoopopopop&apos; ;</span><br><span class=\"line\">console.log(firstSingle(str));</span><br><span class=\"line\">function firstSingle(str)&#123;</span><br><span class=\"line\">    var obj = &#123;&#125;;</span><br><span class=\"line\">    for(var i = 0; i &lt; str.length; i ++)&#123;</span><br><span class=\"line\">        if(!obj[str[i]])&#123;</span><br><span class=\"line\">            obj[str[i]] = true;               </span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            str = deleteLetter(str,str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return str[0];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function deleteLetter(str,char) &#123;</span><br><span class=\"line\">    var reg = new RegExp(char, &apos;g&apos;);</span><br><span class=\"line\">    for(var i = 0; i &lt; str.length;)&#123;</span><br><span class=\"line\">        if(str[i] === char)&#123;</span><br><span class=\"line\">            str = str.replace(reg, &apos;&apos;);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            i ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"圣杯模式\"><a href=\"#圣杯模式\" class=\"headerlink\" title=\"圣杯模式\"></a><strong>圣杯模式</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inherit(Target,Origin) &#123;</span><br><span class=\"line\">    function F() &#123;&#125;;</span><br><span class=\"line\">    F.prototype = Origin.prototype;</span><br><span class=\"line\">    Target.prototype = new F();</span><br><span class=\"line\">    Target.prototype.constuctor = Target;</span><br><span class=\"line\">    Target.prototype.uber = Origin.prototype; //就是来知道真正继承的是谁</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">father.prototype.lastName = &apos;xiao&apos;;</span><br><span class=\"line\">function Father() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">function Son() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inhert(Son,Father);</span><br><span class=\"line\">var father = new Father();</span><br><span class=\"line\">var son = new Son();</span><br></pre></td></tr></table></figure>\n<h3 id=\"雅虎（圣杯模式）\"><a href=\"#雅虎（圣杯模式）\" class=\"headerlink\" title=\"雅虎（圣杯模式）\"></a><strong>雅虎（圣杯模式）</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var inherit = (function()&#123;</span><br><span class=\"line\">    var F = function () &#123;&#125;;//私有化变量</span><br><span class=\"line\">    return function (Target,Origin) &#123;</span><br><span class=\"line\">        F.prototype = Origin.prototype;</span><br><span class=\"line\">        Target.prototype = new F();</span><br><span class=\"line\">        Target.prototype.constuctor = Target;</span><br><span class=\"line\">        Target.prototype.uber = Origin.prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装兼容性方法，求滚动条滚动距离getScrollOffset\"><a href=\"#封装兼容性方法，求滚动条滚动距离getScrollOffset\" class=\"headerlink\" title=\"封装兼容性方法，求滚动条滚动距离getScrollOffset()\"></a><strong>封装兼容性方法，求滚动条滚动距离getScrollOffset()</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getScrollOffset() &#123;</span><br><span class=\"line\">    if(window.pageXOffset)&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            x : window.pageXOffset,</span><br><span class=\"line\">            y : window.pageYOffset</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            x : document.body.scrollLeft + document.documentElement.scrollLeft,</span><br><span class=\"line\">            y : document.body.scrollTop + document.documentElement.scrollTop</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装兼容性方法，返回浏览器视口尺寸getViewportOffset\"><a href=\"#封装兼容性方法，返回浏览器视口尺寸getViewportOffset\" class=\"headerlink\" title=\"封装兼容性方法，返回浏览器视口尺寸getViewportOffset() \"></a><strong>封装兼容性方法，返回浏览器视口尺寸getViewportOffset() </strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getViewportOffset() &#123;</span><br><span class=\"line\">    if(window.innerWidth)&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            w : window.innerWidth,</span><br><span class=\"line\">            h : window.innerHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        if(document.compatMode === &apos;BackCompat&apos;)&#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                w: document.body.clientWidth,</span><br><span class=\"line\">                h: document.body.clientHeight </span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return&#123;</span><br><span class=\"line\">                w: document.documentElement.clientWidth,</span><br><span class=\"line\">                h: document.documentElement.clientHeight</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装兼容方法getStyle-elem-prop\"><a href=\"#封装兼容方法getStyle-elem-prop\" class=\"headerlink\" title=\"封装兼容方法getStyle(elem,prop)\"></a><strong>封装兼容方法getStyle(elem,prop)</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getStyle(elem,prop) &#123;</span><br><span class=\"line\">    if(window.getComputedStyle)&#123;</span><br><span class=\"line\">        return window.getComputedStyle(elem,null)[prop];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return elem.currentStyle[prop];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装兼容性的addEvent-elem-type-handle-方法\"><a href=\"#封装兼容性的addEvent-elem-type-handle-方法\" class=\"headerlink\" title=\"封装兼容性的addEvent(elem,type,handle)方法\"></a><strong>封装兼容性的addEvent(elem,type,handle)方法</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addEvent(elem,type,handle)&#123;</span><br><span class=\"line\">    if(elem.addEventListener)&#123;</span><br><span class=\"line\">        elem.addEventListener(type,handle,false);</span><br><span class=\"line\">    &#125;else if(elem.attachEvent)&#123;</span><br><span class=\"line\">        elem.attachEvent(&apos;on&apos; + type,function()&#123;</span><br><span class=\"line\">            handle.call(elem);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        elem[&apos;on&apos;+ type] = handle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装兼容性的removeEvent-elem-type-handle-方法\"><a href=\"#封装兼容性的removeEvent-elem-type-handle-方法\" class=\"headerlink\" title=\"封装兼容性的removeEvent(elem,type,handle)方法\"></a><strong>封装兼容性的removeEvent(elem,type,handle)方法</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function removeEvent(elem, type, handle) &#123;</span><br><span class=\"line\">    if (elem.removeEventListener) &#123;</span><br><span class=\"line\">        elem.removeEventListener(type, handle, false);</span><br><span class=\"line\">    &#125; else if (elem.detachEvent) &#123;</span><br><span class=\"line\">        elem.detachEvent(&apos;on&apos; + type, function () &#123;</span><br><span class=\"line\">            handle.call(elem);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        elem[&apos;on&apos; + type] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装取消冒泡的函数stopBubble-event\"><a href=\"#封装取消冒泡的函数stopBubble-event\" class=\"headerlink\" title=\"封装取消冒泡的函数stopBubble(event)\"></a><strong>封装取消冒泡的函数stopBubble(event)</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function stopBubble(event) &#123;</span><br><span class=\"line\">    if(event.stopPropagation)&#123;</span><br><span class=\"line\">        event.stopPropagation();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.cancelBubble = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装阻止默认事件的函数cancelHandle\"><a href=\"#封装阻止默认事件的函数cancelHandle\" class=\"headerlink\" title=\"封装阻止默认事件的函数cancelHandle()\"></a><strong>封装阻止默认事件的函数cancelHandle()</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function cancelHandle(event) &#123;</span><br><span class=\"line\">    if(event.preventDefault)&#123;</span><br><span class=\"line\">        event.preventDefault();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"将目标节点内部的节点顺序逆序。\"><a href=\"#将目标节点内部的节点顺序逆序。\" class=\"headerlink\" title=\"将目标节点内部的节点顺序逆序。\"></a><strong>将目标节点内部的节点顺序逆序。</strong></h3><ul>\n<li>eg: <div><p></p><a></a></div>  —&gt;  <div><a></a><p></p></div><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element.prototype.reverseElement = function () &#123;</span><br><span class=\"line\">    var len = this.childNodes.length,</span><br><span class=\"line\">        child,</span><br><span class=\"line\">        first = this.firstChild;</span><br><span class=\"line\">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        child = this.lastChild;</span><br><span class=\"line\">        this.insertBefore(child, first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"封装remove-函数，使得child-remove-可以销毁自身。\"><a href=\"#封装remove-函数，使得child-remove-可以销毁自身。\" class=\"headerlink\" title=\"封装remove()函数，使得child.remove()可以销毁自身。\"></a><strong>封装remove()函数，使得child.remove()可以销毁自身。</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element.prototype.remove = function () &#123;</span><br><span class=\"line\">    var parent = this.parentNode;</span><br><span class=\"line\">    parent.removeChild(this);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装函数InsertAfter-功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。\"><a href=\"#封装函数InsertAfter-功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。\" class=\"headerlink\" title=\"封装函数InsertAfter();功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。\"></a><strong>封装函数InsertAfter();功能类似insertBefore，直接在原型链上编程，可以忽略老版本的浏览器。</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element.protoType.insertAfter = function (targetNode, afterNode) &#123;</span><br><span class=\"line\">    var nextSib = afterNode.nextElementSibling;</span><br><span class=\"line\">    if (this.children.length &lt;= 1 || !nextSib) &#123;</span><br><span class=\"line\">        this.appendChild(targetNode);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.insertBefore(targetNode, nextSibling);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"缓冲移动运动\"><a href=\"#缓冲移动运动\" class=\"headerlink\" title=\"缓冲移动运动\"></a><strong>缓冲移动运动</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function move(obj, target) &#123;</span><br><span class=\"line\">    clearInterval(timer);</span><br><span class=\"line\">    var speed;</span><br><span class=\"line\">    timer = setInterval(function () &#123;</span><br><span class=\"line\">        speed = (target - obj.offsetLeft) / 7;</span><br><span class=\"line\">        speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);</span><br><span class=\"line\">        if (obj.offsetLeft === target) &#123;</span><br><span class=\"line\">            clearInterval(timer);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            obj.style.left = obj.offsetLeft + speed + &apos;px&apos;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, 30)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"透明度缓存\"><a href=\"#透明度缓存\" class=\"headerlink\" title=\"透明度缓存\"></a><strong>透明度缓存</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function move(obj, target) &#123;</span><br><span class=\"line\">    clearInterval(timer);</span><br><span class=\"line\">    var speed,opa;</span><br><span class=\"line\">    timer = setInterval(function () &#123;</span><br><span class=\"line\">        opa = parseFloat(getstyle(obj, false)[prop]) * 100;</span><br><span class=\"line\">        speed = (target - opa) / 7;</span><br><span class=\"line\">        speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);</span><br><span class=\"line\">        if (target === opa) &#123;</span><br><span class=\"line\">            clearInterval(timer);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            obj.style.opacity = (speed + opa) / 100;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, 30)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"foreach源码\"><a href=\"#foreach源码\" class=\"headerlink\" title=\"foreach源码\"></a><strong>foreach源码</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myForEach = function (func, context) &#123;</span><br><span class=\"line\">     var len = this.length;</span><br><span class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        func.call(context, this[i], i, this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter源码\"><a href=\"#filter源码\" class=\"headerlink\" title=\"filter源码\"></a><strong>filter源码</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myFilter = function (func, context) &#123;</span><br><span class=\"line\">     var newArr = [],</span><br><span class=\"line\">         len = his.length;</span><br><span class=\"line\">     for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">         func.call(context, this[i], i, this) ? newArr.push(this[i]) : &apos;&apos;;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return newArr;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"map源码\"><a href=\"#map源码\" class=\"headerlink\" title=\"map源码\"></a><strong>map源码</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myMap = function (func, context) &#123;</span><br><span class=\"line\">    var newArr = [],</span><br><span class=\"line\">        len = this.length;</span><br><span class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        newArr.push(func.call(context, this[i], i, this));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce源码-跟原数组的reduce不太一样\"><a href=\"#reduce源码-跟原数组的reduce不太一样\" class=\"headerlink\" title=\"reduce源码(跟原数组的reduce不太一样)\"></a><strong>reduce源码(跟原数组的reduce不太一样)</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myReduce = function (func, orgin) &#123;</span><br><span class=\"line\">    var previous = orgin,</span><br><span class=\"line\">        i = 0,</span><br><span class=\"line\">        len = this.length;</span><br><span class=\"line\">    if (orgin === undefined) &#123;</span><br><span class=\"line\">        orgin = this[0];</span><br><span class=\"line\">        i = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (i; i &lt; len; i++) &#123;</span><br><span class=\"line\">        previous = func(previous, this[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return previous;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"下面这个跟原数组的reduce不太一样\"><a href=\"#下面这个跟原数组的reduce不太一样\" class=\"headerlink\" title=\"下面这个跟原数组的reduce不太一样\"></a><strong>下面这个跟原数组的reduce不太一样</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myReduce = function (func, initialValue, context) &#123;</span><br><span class=\"line\">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class=\"line\">        initialValue = func.call(context, initialValue, this[i], i, this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return initialValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"some源码\"><a href=\"#some源码\" class=\"headerlink\" title=\"some源码\"></a><strong>some源码</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.mySome = function (func, context) &#123;</span><br><span class=\"line\">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class=\"line\">        if (func.call(context, this[i], i, this)) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"every源码\"><a href=\"#every源码\" class=\"headerlink\" title=\"every源码\"></a><strong>every源码</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myEvery = function (func, context) &#123;</span><br><span class=\"line\">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class=\"line\">        if (!func.call(context, this[i], i, this)) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a><strong>防抖</strong></h3><p>运动场景：比如 oInp.oninout = debounce(ajax, 2000);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(handle, delay)&#123;</span><br><span class=\"line\">    var timer = null;</span><br><span class=\"line\">    return function ()&#123;</span><br><span class=\"line\">        var _self = this,</span><br><span class=\"line\">            _arg = arguments;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = setTimeout(function ()&#123;</span><br><span class=\"line\">            handle.apply(_self, _arg)</span><br><span class=\"line\">        &#125;,delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a><strong>节流</strong></h3><p>运用场景： 窗口调整，页面滚动，抢购疯狂点击</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(handle, wait)&#123;</span><br><span class=\"line\">    var lastTime = 0;</span><br><span class=\"line\">    var nowTime;</span><br><span class=\"line\">    return function (e)&#123;</span><br><span class=\"line\">        nowTime = new Date().getTime();</span><br><span class=\"line\">        if(nowTime - lastTime &gt; wait)&#123;</span><br><span class=\"line\">            handle.apply(this,arguments);</span><br><span class=\"line\">            lastTime = nowTime;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"bind-的源码\"><a href=\"#bind-的源码\" class=\"headerlink\" title=\"bind 的源码\"></a><strong>bind 的源码</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newBind = function (target) &#123;</span><br><span class=\"line\">    target = target || window;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    var arg = [].slice.call(arguments, 1);</span><br><span class=\"line\">    var Temp = function () &#123; &#125;;</span><br><span class=\"line\">    var F = function () &#123;</span><br><span class=\"line\">        var _arg = [].slice.call(arguments, 0);</span><br><span class=\"line\">        return self.apply(this instanceof Temp ? this : target, arg.concat(_arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Temp.prototype = this.prototype;</span><br><span class=\"line\">    F.prototype = new Temp(); //将F函数的的原型跟调用newBind 函数的原型一样（就是将函数F变得跟调用newBind 的函数一样）</span><br><span class=\"line\"></span><br><span class=\"line\">    return F;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"call的原理实现\"><a href=\"#call的原理实现\" class=\"headerlink\" title=\"call的原理实现\"></a><strong>call的原理实现</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newCall = function () &#123;</span><br><span class=\"line\">    var ctx = arguments[0] || window;</span><br><span class=\"line\">    ctx.fn = this;</span><br><span class=\"line\">    var args = [];</span><br><span class=\"line\">    for (var i = 1; i &lt;= arguments.length; i++) &#123;</span><br><span class=\"line\">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class=\"line\">    delete ctx.fn;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"apply的原理实现\"><a href=\"#apply的原理实现\" class=\"headerlink\" title=\"apply的原理实现\"></a><strong>apply的原理实现</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newApply = function (ctx, arr) &#123;</span><br><span class=\"line\">    var ctx = ctx || window;</span><br><span class=\"line\">    ctx.fn = this;</span><br><span class=\"line\">    var args = [];</span><br><span class=\"line\">    if (arr) &#123;</span><br><span class=\"line\">        console.log(&apos;haha&apos;)</span><br><span class=\"line\">        for (var i = 0; i &lt;= arr.length; i++) &#123;</span><br><span class=\"line\">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        var result = ctx.fn();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete ctx.fn;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装的manageCookie的方法\"><a href=\"#封装的manageCookie的方法\" class=\"headerlink\" title=\"封装的manageCookie的方法\"></a><strong>封装的manageCookie的方法</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var manageCookie = &#123;</span><br><span class=\"line\">    setCookie: function (name, age, time) &#123;</span><br><span class=\"line\">        document.cookie = name + &apos;=&apos; + value + &apos;; max-age=&apos; + time;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    removeCookie: function (name) &#123;</span><br><span class=\"line\">        return this.setCookie(name, &apos;&apos;, -1);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getCookie: function (name, callback) &#123;</span><br><span class=\"line\">        var cookieStrArr = document.cookie.split(&apos;; &apos;);</span><br><span class=\"line\">        var len = cookieStrArr.length;</span><br><span class=\"line\">        for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">            var cookieName = cookieStrArr[i].split(&apos;=&apos;)[0];</span><br><span class=\"line\">            if (cookieName == name) &#123;</span><br><span class=\"line\">                callback(cookieStrArr[i].split(&apos;=&apos;)[1]);</span><br><span class=\"line\">                return this;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callback(null);</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装requestAnimationFrame的实现\"><a href=\"#封装requestAnimationFrame的实现\" class=\"headerlink\" title=\"封装requestAnimationFrame的实现\"></a><strong>封装requestAnimationFrame的实现</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.requestAnimFrame = (function () &#123;</span><br><span class=\"line\">    return window.requestAnimationFrame ||</span><br><span class=\"line\">        window.webkitRequestAnimationFrame ||</span><br><span class=\"line\">        window.mozRequestAnimationFrame ||</span><br><span class=\"line\">        function (callback) &#123;</span><br><span class=\"line\">            window.setTimeout(callback, 1000 / 60);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">window.cancelAnimFrame = (function () &#123;</span><br><span class=\"line\">    return window.cancelAnimationFrame ||</span><br><span class=\"line\">        window.webkitCancelAnimationFrame ||</span><br><span class=\"line\">        window.mozCancelAnimationFrame ||</span><br><span class=\"line\">        function (id) &#123;</span><br><span class=\"line\">            window.clearTimeout(id);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"传func-返回新的函数\"><a href=\"#传func-返回新的函数\" class=\"headerlink\" title=\"传func 返回新的函数\"></a><strong>传func 返回新的函数</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var getSingle = function (func) &#123;</span><br><span class=\"line\">    var result;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        if (!result) &#123;</span><br><span class=\"line\">            result = func.apply(this, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"this的全面解析","url":"http://yoursite.com/2018/10/11/This/","content":"<h2 id=\"什么是this\"><a href=\"#什么是this\" class=\"headerlink\" title=\"什么是this\"></a><strong>什么是this</strong></h2><ol>\n<li>对于this，this的作用是提供了一种更优雅的方式来隐式“传递”一个对象引用（即上下文对象），它的特性跟动态作用域有点相似，this 是在运行时进行绑定的,即this在一个函数调用时发生绑定，就是当函数调用时，函数会创建一个AO对象，这个对象中会存放记录函数内的变量，函数传进来的参数，函数是在哪里被调用的等息，this就是其中的一个属性，会在函数执行过程中用到，<strong>this的指向取决于函数在哪里被调用</strong>。</li>\n</ol>\n<h2 id=\"对于this的绑定有四个绑定规则\"><a href=\"#对于this的绑定有四个绑定规则\" class=\"headerlink\" title=\"对于this的绑定有四个绑定规则\"></a><strong>对于this的绑定有四个绑定规则</strong></h2><ol>\n<li>this含有四种绑定规则</li>\n</ol>\n<p><strong>默认绑定</strong>：</p>\n<ul>\n<li><p>一个函数foo在不带任何参数修饰调用时（即foo函数执行时没有被任何对象调用），这个函数内部的this就会使用默认绑定，this指向window，但前提是在非严格模式下，如果在严格模式下，this就会绑定undefiend，注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式，看下面的例子：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">        console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\">    (function () &#123;</span><br><span class=\"line\">        &quot;use strict&quot;; </span><br><span class=\"line\">        foo();    // 2 </span><br><span class=\"line\">    &#125;)();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</p>\n</li>\n</ul>\n<p><strong>隐式绑定</strong>：</p>\n<ul>\n<li>当一个函数在一个上下文对象中调用时，隐式绑定规则就会将函数中的this绑定到这个上下文对象中，比如obj.fn();对象属性引用链中只有最顶层或者说最后一层会影响调用位置,比如, obj1.obj2.fn()，fn执行中this指向obj2，还存在一些javascript内置函数比如：setTimeout它第一个参数函数中的this指向的是window，还有一些事件处理函数中的回调函数中的this指向的是dom元素</li>\n</ul>\n<p>-这里存在一个隐式丢失的问题，如下例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var bar = obj.foo; // 函数别名！</span><br><span class=\"line\">var a = &quot;oops, global&quot;; // a 是全局对象的属性</span><br><span class=\"line\">bar(); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>\n<p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定,其实setTimeout类似于这种，他的函数实现与下面的伪代码类似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setTimeout(fn,delay) &#123;</span><br><span class=\"line\">// 等待 delay 毫秒</span><br><span class=\"line\">fn(); // &lt;-- 调用位置！</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>显示绑定</strong>：</p>\n<ul>\n<li><p>显示绑定就是通过函数原型链上的两个方法call和apply还有bind来实现改变this的指向，数组的foreach和map函数中的就用到了call和apply来进行显示绑定this</p>\n</li>\n<li><p>注意：call、apply和bind的第一个参数如果传的是字符串，数字，布尔类型的值时，这个原始值就会被转换成包装对象</p>\n</li>\n<li><p>还有像bind这种将一个函数的this强绑定要一个对象中，无论何时调用该函数该函数中的this都指向这个对象，这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。与之相反的是软绑定，很好体现软绑定的就是内置函数bind，它的<a href=\"https://shine-hfrao.github.io/2018/10/14/tools/#bind-%E7%9A%84%E6%BA%90%E7%A0%81\" target=\"_blank\" rel=\"noopener\">实现原理</a>是当函数调用bind之后改变了该函数的this指向，但是当通过new操作符来执行这个通过bind调用过的函数时，它的this指向会改变变成指向该函数的实例对象</p>\n</li>\n</ul>\n<p><strong>new绑定</strong>：</p>\n<ul>\n<li>每个函数都可以通过new操作符来实例化一个对象，每个函数在new之后函数内部就会隐式创建一个this对象，this对象中有一个默认属性<strong>proto</strong>指向该函数的原型链，如果该函数最后没有返回值，那么会隐式返回这个this对象，如果该函数返回一个不是对象的值，那么还是会返回这个this对象，如果返回的是一个对象，呢么该函数将会返回的是这个对象</li>\n</ul>\n<ol start=\"2\">\n<li>绑定优先级</li>\n</ol>\n<ul>\n<li>New绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</li>\n</ul>\n<h2 id=\"对于涉及到this但是不关心this的情况\"><a href=\"#对于涉及到this但是不关心this的情况\" class=\"headerlink\" title=\"对于涉及到this但是不关心this的情况\"></a><strong>对于涉及到this但是不关心this的情况</strong></h2><ol>\n<li><p>比如在一个函数进行执行的过程中传入的参数是一个数组的话，可以用apply来将数组作为第二个参数进行传入（fn.apply(null,[1,2])），但是对于该函数来说第一个参数是没有不需要关心的，但人需要一个占位符，这是null是一个很不错的选择（undefined也可以），在es6直接可以使用扩展运算符fn(…[1,2])。另外一个引用就是使用bind来实现柯里化思想时，这是this也是我们不会关心的对象。</p>\n</li>\n<li><p>但考虑到this只想全局对象后会对全局对象有影响，我们给出了一个更好的解决方法，就是我们在忽略 this 绑定时总是传入一个 DMZ（它就是一个空的非委托的对象）对象，在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和{}很 像， 但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”，用这个对象去表示“ 我希望this是空”，这比 null 的含义更清楚。</p>\n</li>\n</ol>\n<h2 id=\"说说箭头函数中的this\"><a href=\"#说说箭头函数中的this\" class=\"headerlink\" title=\"说说箭头函数中的this\"></a><strong>说说箭头函数中的this</strong></h2><ol>\n<li><p>要知道箭头函数不是使用function来定义的，它是通过被称为“胖箭头”的操作符“=&gt;”来定义的。箭头函数不使用this的四种绑定规则，而是根据离他最近的作用域来决定this的，而且箭头函数的this绑定是无法被修改的（new也不行）</p>\n</li>\n<li><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式，就是使用self=this:</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    var self = this; // lexical capture of this</span><br><span class=\"line\">    setTimeout( function()&#123;</span><br><span class=\"line\">        console.log( self.a );</span><br><span class=\"line\">    &#125;, 100 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"理清[[scope]]、运行期上下文和函数作用域链、闭包","url":"http://yoursite.com/2018/10/06/[[scope]]-/","content":"<p>在谈作用域之前，我们先来谈谈 <strong>词法作用域</strong> 和 <strong>动态作用域</strong>，而我们接触的javascript是属于词法作用域。简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的），也就会出现作用域嵌套，当然像eval、width他是会改变词法作用域的（<strong>称为欺骗词法作用域，欺骗词法作用域会导致性能下降</strong>）</p>\n<p>再来说一说 <strong>编译</strong> ，我们知道语言分为编译语言还有一个是解析语言，尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但是它的编译的步骤比传统的编译语言在某些方面要稍微复杂一些，例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。javascript的编译过程不是发生在构造之前，对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。编译的过程中会有一个提升的过程，你可以在<a href=\"\">预编译</a>这篇文章中找到答案。</p>\n<p>当然我们也要了解 <strong>编译器编译的过程</strong>，他会经历三个步骤：</p>\n<p><strong>1. 分词/词法分析</strong>（Tokenizing/Lexing）</p>\n<blockquote>\n<p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</p>\n</blockquote>\n<p><strong>2. 解析/语法分析</strong>（Parsing）</p>\n<blockquote>\n<p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。</p>\n</blockquote>\n<p><strong>3. 代码生成</strong></p>\n<blockquote>\n<p>将 AST 转换为可执行代码的过程称被称为代码生成。</p>\n</blockquote>\n<h3 id=\"scope-是啥，它与作用域链之间的关系\"><a href=\"#scope-是啥，它与作用域链之间的关系\" class=\"headerlink\" title=\"[[scope]]是啥，它与作用域链之间的关系\"></a><strong>[[scope]]是啥，它与作用域链之间的关系</strong></h3><p>我们都知道每个JavaScript函数都是一个对象，更确切的说它是一个函数的实例，他会像对象那样存在自身的属性（可以被程序访问），还存在一系列只被JS引擎使用的内部属性，其中一个内部属性就是[[scope]]，[[scope]]属性中包含了一个函数被创建时作用域对象的集合，此集合就称作是作用域链，这些作用域对象就是代表在创建此函数的环境中能够访问的数据</p>\n<p>add函数的内置属性[[scope]]图：<br>    <img src=\"/images/blog_images/scope1.png\" alt=\"image\"></p>\n<h3 id=\"再来讲下运行期上下文\"><a href=\"#再来讲下运行期上下文\" class=\"headerlink\" title=\"再来讲下运行期上下文\"></a><strong>再来讲下运行期上下文</strong></h3><p>函数被执行时，函数会创建一个内部对象，称作“运行期上下文”。这个运行期上下文定义了一个函数运行时的环境，而且运行期上下文有自己独立的作用域链，这个作用域链在此对象创建时就会被初始化，此时函数内部属性[[scope]]中的作用域链中的对象会按顺序被复制到运行期上下文的作用域链中，此时还会创建一新对象（即此函数的作用域）AO放到运行期上下文作用域链的前端，这个新对象被称为“激活对象”，它存放着此函数的局部变量和this接口等。</p>\n<p>运行期上下文在函数执行完就被销毁，所以函数每次执行的运行期上下文是独一无二的</p>\n<p>add函数执行时的作用域链<br>    <img src=\"/images/blog_images/scope2.png\" alt=\"image\"></p>\n<p>函数在运行时所遇到的变量（即标识符）都会按照运行期上下文的作用域链前端进行查找，变量所处的越深，它的读写书读就越慢，从而影响性能，所以为了能够减少性能损耗，最好将所需的变量编程局部变量（<strong>局部变量访问的总是最快的</strong>），有些也可以通过优化JS引擎来解决</p>\n<p>说到在作用域链上访问变量，我们又可以联想到在对象中 <strong>原型链</strong> 上访问对象属性和方法，与访问变量一样，在对象中访问的属性和方法所在原型链越深搜索速度越慢，性能损耗越多，也可通过缓存属性或方法来提升性能（基于不会改变的值），但是 <strong>记住搜索实例成员的过程比访问直接量或局部变量负担更重</strong>。还有一个需要注意的就是 <strong>嵌套对象</strong>（如window.location.href.toString()，它的情况也与前两个很类似，在处理嵌套对象成员时要特别注意，否则它会对运行速度产生难以置信的影响</p>\n<p>下面的代码就是将全局的变量document变成局部变量来提高性能，虽然一次不能够有较大性能的提升，但是访问多次的话性能改进将显的很出色<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initUI() &#123;</span><br><span class=\"line\">    var doc = document,</span><br><span class=\"line\">        bd = doc.body,</span><br><span class=\"line\">        links = doc.getElementsByTagName_r(&quot;a&quot;),</span><br><span class=\"line\">        i = 0,</span><br><span class=\"line\">        len = links.length;</span><br><span class=\"line\">    while (i &lt; len) &#123;</span><br><span class=\"line\">        update(links[i++]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doc.getElementById(&quot;go-btn&quot;).onclick = function () &#123;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    bd.className = &quot;active&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"改变作用域链\"><a href=\"#改变作用域链\" class=\"headerlink\" title=\"改变作用域链\"></a><strong>改变作用域链</strong></h3><p>一般来说，一个运行期上下文的作用域链不会被改变，但是有两种表达式可以改变其作用域链，第一个是width：width属性会为所有的对象属性添加一个操作变量，当代码在width运算符中执行，函数运行期上下文的作用域链就会被临时改变，一个新的对象（作用域）会被创建，这个对象包含with括号中执行对象的所有属性，他会被放到运行期上下文中的前端，意味着现在函数的作用域对象将被放置于作用域的第二位，是的访问局部变量的速度变慢了，正是这个原因，最好不要用width表达式，如下只要将document对象变成局部变量就可以获得性能提升<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initUI() &#123;</span><br><span class=\"line\">    with (document) &#123; //avoid!</span><br><span class=\"line\">        var bd = body,</span><br><span class=\"line\">            links = getElementsByTagName_r(&quot;a&quot;),</span><br><span class=\"line\">            i = 0,</span><br><span class=\"line\">            len = links.length;</span><br><span class=\"line\">        while (i &lt; len) &#123;</span><br><span class=\"line\">            update(links[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getElementById(&quot;go-btn&quot;).onclick = function () &#123;</span><br><span class=\"line\">            start();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bd.className = &quot;active&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为一个表达书就是try-catch表达式的catch语句，当进入catch块中，会将异常的对象放入到运行期上下文作用域链的最前端，将存有局部变量的对象放入到作用域链的第二个位置（ 但是只要catch执行完作用域链就会回到原来的样子 ），如果非要用catch可以将catch中的对象给外部的函数来处理，如下：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    methodThatMightCauseAnError();</span><br><span class=\"line\">&#125; catch (ex) &#123;</span><br><span class=\"line\">    handleError(ex); //delegate to handler method</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a><strong>闭包</strong></h3><ol>\n<li><p>闭包可以理解成“定义在一个函数内部的函数“。即当函数可以记住并访问所在的词法作用域时，就产生了闭包。在本质上，闭包是将函数内部和函数外部连接起来的桥梁，通过将函数内部定义的函数赋值给外部变量或用return返回出来。</p>\n<ul>\n<li><p>闭包其实就是创造出了一些函数私有的 ”持久化变量“， 是的函数外部的变量可以访问到函数内容的变量。</p>\n</li>\n<li><p>闭包产生的私有化变量可以用来作缓存，外部函数根本访问不到他就不会受到污染了。</p>\n</li>\n</ul>\n</li>\n<li><p>闭包无处不在：</p>\n<ul>\n<li><p>在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</p>\n</li>\n<li><p>还有个非常典型的例子就是立即执行函数（IIFE模式），看下面的代码，尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\">(function IIFE() &#123;</span><br><span class=\"line\">    console.log( a );</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>利用了闭包的强大的威力：<strong>模块</strong></p>\n<ul>\n<li><p>考虑以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function CoolModule() &#123;</span><br><span class=\"line\">    var something = &quot;cool&quot;;</span><br><span class=\"line\">    var another = [1, 2, 3];</span><br><span class=\"line\">    function doSomething() &#123;</span><br><span class=\"line\">        console.log( something );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function doAnother() &#123;</span><br><span class=\"line\">        console.log( another.join( &quot; ! &quot; ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        doSomething: doSomething,</span><br><span class=\"line\">        doAnother: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = CoolModule();</span><br><span class=\"line\">foo.doSomething(); // cool</span><br><span class=\"line\">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以上这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。</p>\n</li>\n<li><p>从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。</p>\n</li>\n<li><p>如果要更简单的描述，模块模式需要具备两个必要条件。</p>\n<ul>\n<li><p>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</p>\n</li>\n<li><p>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"词法作用域和动态作用域\"><a href=\"#词法作用域和动态作用域\" class=\"headerlink\" title=\"词法作用域和动态作用域\"></a><strong>词法作用域和动态作用域</strong></h3><ol>\n<li><p>JavaScript 中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval() 或 with）</p>\n</li>\n<li><p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p>\n</li>\n<li><p>事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域</p>\n</li>\n<li><p>主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>\n</li>\n</ol>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"同源策略，cookie、iframe和ajax跨域","url":"http://yoursite.com/2018/10/03/tongyuan/","content":"<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a><strong>同源策略</strong></h3><p>同源策略是有浏览器实施的（所以其实不同源的网站相互发送请求是能够接收到的，也能够响应请求，但是就是浏览器把他们阻止了，服务器与服务器相互跨域就是可以的因为没有了浏览器），它是针对不同源的网站进行限制相互访问数据，保护用户信息安全，所谓同源就是两个网址的协议、域名、端口都相同，在不同源的情况下：</p>\n<pre><code>- （1）cookie、LocalStorage、sessionStorage 和 IndexDB 无法读取\n- （2）对于网页嵌套iframe,不可一相互访问到dom\n- （3）不能发送ajax请求\n</code></pre><p>当然针对这个问题有时候我们需要解决跨域这个问题，针对不同的事物有不同的方法</p>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a><strong>跨域</strong></h3><ul>\n<li><p><strong>针对于cookie跨域</strong></p>\n<ul>\n<li><p>针对两个网页一级域名相同，只是二级域名不同（A网页是<a href=\"http://w1.example.com/a.html，B网页是http://w2.example.com/b.html），那么只要两个页面的脚本下都设置相同的document.domain，两个网页就可以共享Cookie\" target=\"_blank\" rel=\"noopener\">http://w1.example.com/a.html，B网页是http://w2.example.com/b.html），那么只要两个页面的脚本下都设置相同的document.domain，两个网页就可以共享Cookie</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.domain = &apos;example.com&apos;;        //这种方法还是适用于iframe</span><br></pre></td></tr></table></figure>\n<p>另外一种就是在设置cookie的时候，指定Cookie的所属域名为一级域名(二级域名和三级域名不用做任何设置)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: key=value; domain=.example.com; path=/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>针对于iframe跨域</strong></p>\n<ul>\n<li><p>以下子窗口和父窗口相互访问dom都是被同源策略限制的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;myIFrame&quot;).contentWindow.document;</span><br><span class=\"line\"></span><br><span class=\"line\">window.parent.document.body;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一个是设置跟cookie一样，脚本里设置document.domain</p>\n</li>\n<li><p>使用 <strong>片段标识符</strong>,片段标识符（fragment identifier）指的是，URL的#号后面的部分(也可以说成hash值)，添加hash值是不会刷新页面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父窗口可以把信息写入子窗口的hash值</span><br><span class=\"line\">var src = originURL + &apos;#&apos; + data;</span><br><span class=\"line\">document.getElementById(&apos;myIFrame&apos;).src = src;</span><br><span class=\"line\"></span><br><span class=\"line\">//子窗口通过监听hashchange事件得到通知</span><br><span class=\"line\">window.onhashchange = checkMessage;</span><br><span class=\"line\">function checkMessage() &#123;</span><br><span class=\"line\">    var message = window.location.hash;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，子窗口用同样的方式来传递信息给父窗口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.parent.location.href= target + &quot;#&quot; + hash;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用window.name, 只要在同一个窗口里不同的网页都可以获取这个属性，所以可以通过这个来传递信息，这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能</p>\n</li>\n<li><p>window.postMessage（<strong>HTML5</strong>），跨文档通信 API，不论两个网站是否同源都可以使用个这个API来传递数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//发送</span><br><span class=\"line\">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</span><br><span class=\"line\">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//监听</span><br><span class=\"line\">window.addEventListener(&apos;message&apos;, function(event) &#123;</span><br><span class=\"line\">    console.log(event.data);</span><br><span class=\"line\">    //event.source：发送消息的窗口</span><br><span class=\"line\">    //event.origin: 消息发向的网址</span><br><span class=\"line\">    //event.data: 消息内容</span><br><span class=\"line\">    //event.origin属性可以过滤不是发给本窗口的消息  </span><br><span class=\"line\">&#125;,false);</span><br><span class=\"line\"></span><br><span class=\"line\">//子窗口向父窗口发送消息的写法类似</span><br><span class=\"line\">window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);</span><br></pre></td></tr></table></figure>\n<p>该方法也适用于LocalStorage，sessionStorage， indexDB</p>\n</li>\n</ul>\n</li>\n<li><p><strong>针对于AJAX跨域</strong><br>这是非常常见的跨域</p>\n<ul>\n<li><p>前面不是说了嘛同源策略是浏览器设置的，所以我们可以规避浏览器，通过客户端先请求同源服务器，然后同源服务器访问外部服务器来获取数据（称为服务器代理）</p>\n</li>\n<li><p>JSONP来实现跨域，它是最常用的跨域方式，兼容性很好，它的基本思想是，网页通过添加一个<script>元素，通过url传递回调函数命名参数的方式来向服务器请求JSON数据，这种做法不受同源政策限制，服务器收到请求后，将数据放在一个指定名字的回调函数里传回来，通过想页面添加script的方式来发送get请求，返回的参数会被放到script中（是一个函数执行，里面传的是我们要获取的数据，这个函数在前面就被定义好了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    function addScriptTag(src) &#123;</span><br><span class=\"line\">        var script = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">        script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class=\"line\">        script.src = src;</span><br><span class=\"line\">        document.body.appendChild(script);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    window.onload = function () &#123;</span><br><span class=\"line\">        addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo(data) &#123;</span><br><span class=\"line\">        console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当然JSONP的限制是 <strong>只能发送get请求</strong></p>\n</li>\n<li><p>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀，该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。<br>详细的webSocket如何通信可以参考阮一峰老师的 <a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\">WebSocket 教程</a></p>\n</li>\n<li><p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求,实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信</p>\n<ul>\n<li><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）</p>\n<p>只要同时满足以下两大条件，就属于简单请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1) 请求方法是以下三种方法之一：</span><br><span class=\"line\"></span><br><span class=\"line\">    HEAD</span><br><span class=\"line\">    GET</span><br><span class=\"line\">    POST</span><br><span class=\"line\">(2) HTTP的头信息不超出以下几种字段：</span><br><span class=\"line\"></span><br><span class=\"line\">    Accept</span><br><span class=\"line\">    Accept-Language</span><br><span class=\"line\">    Content-Language</span><br><span class=\"line\">    Last-Event-ID</span><br><span class=\"line\">    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure>\n<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）Access-Control-Allow-Origin</span><br><span class=\"line\"></span><br><span class=\"line\">    该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）Access-Control-Allow-Credentials</span><br><span class=\"line\"></span><br><span class=\"line\">    含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）Access-Control-Expose-Headers</span><br><span class=\"line\"></span><br><span class=\"line\">    该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&apos;FooBar&apos;)可以返回FooBar字段的值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>withCredentials 属性<br>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>\n<p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest();</span><br><span class=\"line\">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>\n<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>\n<p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>\n</li>\n<li><p>预检请求<br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>\n<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>\n<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>\n<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS /cors HTTP/1.1</span><br><span class=\"line\">Origin: http://api.bob.com</span><br><span class=\"line\">Access-Control-Request-Method: PUT</span><br><span class=\"line\">Access-Control-Request-Headers: X-Custom-Header</span><br><span class=\"line\">Host: api.alice.com</span><br><span class=\"line\">Accept-Language: en-US</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>\n<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>\n<p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>\n<p>（1）Access-Control-Request-Method</p>\n<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>\n<p>（2）Access-Control-Request-Headers</p>\n<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>\n<p>预检请求的响应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 (Unix)</span><br><span class=\"line\">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class=\"line\">Content-Type: text/html; charset=utf-8</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 0</span><br><span class=\"line\">Keep-Alive: timeout=2, max=100</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br></pre></td></tr></table></figure>\n<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class=\"line\">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>\n<p>服务器回应的其他CORS相关字段如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class=\"line\">Access-Control-Allow-Credentials: true</span><br><span class=\"line\">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）Access-Control-Allow-Methods</span><br><span class=\"line\"></span><br><span class=\"line\"> 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</span><br><span class=\"line\"></span><br><span class=\"line\"> （2）Access-Control-Allow-Headers</span><br><span class=\"line\"></span><br><span class=\"line\"> 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</span><br><span class=\"line\"></span><br><span class=\"line\"> （3）Access-Control-Allow-Credentials</span><br><span class=\"line\"></span><br><span class=\"line\"> 该字段与简单请求时的含义相同。</span><br><span class=\"line\"></span><br><span class=\"line\"> （4）Access-Control-Max-Age</span><br><span class=\"line\"></span><br><span class=\"line\"> 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>预检请求后正常的请求和响应<br>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>\n<p>下面是”预检”请求之后，浏览器的正常CORS请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /cors HTTP/1.1</span><br><span class=\"line\">Origin: http://api.bob.com</span><br><span class=\"line\">Host: api.alice.com</span><br><span class=\"line\">X-Custom-Header: value</span><br><span class=\"line\">Accept-Language: en-US</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>\n<p>上面头信息的Origin字段是浏览器自动添加的。<br>下面是服务器正常的回应。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class=\"line\">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>\n<p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>\n<li><a href=\"http://www.dailichun.com/2017/03/22/ajaxCrossDomainSolution.html\">http://www.dailichun.com/2017/03/22/ajaxCrossDomainSolution.html</a></li>\n</ol>\n</script></p></li></ul></li></ul>","categories":["网络"],"tags":["网络"]},{"title":"节点的类型、访问和获取，不同节点的属性和方法（归纳）","url":"http://yoursite.com/2018/09/30/node_js-/","content":"<h2 id=\"DOM中节点的类型\"><a href=\"#DOM中节点的类型\" class=\"headerlink\" title=\"DOM中节点的类型\"></a><strong>DOM中节点的类型</strong></h2><ol>\n<li><p>JavaScript 中的所有节点类型都继承自 Node 类型（构造函数），因此所有节点类型都共享着相同的基本属性和方法，除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。</p>\n<ul>\n<li>dom结构树如下（Document下面还有XMLDocument，Element 下面也有XMLElement，DOM树代表的就是继承关系）：<br><img src=\"/images/blog_images/js_basic/7.jpg\" alt=\"image\"></li>\n</ul>\n</li>\n<li><p>节点类型有（只列举了常用的）：</p>\n<ul>\n<li>元素节点 （节点对应的nodeType值是：1）</li>\n<li>属性节点  2</li>\n<li>文本节点  3</li>\n<li>注释节点  8</li>\n<li>document节点  9</li>\n<li>ducumentFragment节点  11</li>\n</ul>\n</li>\n<li><p>各类节点如图:</p>\n<p> <img src=\"/images/blog_images/js_basic/1.jpg\" alt=\"image\"><br> <img src=\"/images/blog_images/js_basic/2.jpg\" alt=\"image\"></p>\n</li>\n</ol>\n<h2 id=\"Document类型\"><a href=\"#Document类型\" class=\"headerlink\" title=\"Document类型\"></a>Document类型</h2><ol>\n<li><p>JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，而且，document 对象是 window 对象的一个属性，Document可以理解成一个构造函数，但不能new</p>\n</li>\n<li><p>有两个内置的访问其子节点的快捷方式：</p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var html = document.documentElement; //取得对&lt;html&gt;的引用</span><br><span class=\"line\">alert(html === document.childNodes[0]); //true </span><br><span class=\"line\">alert(html === document.firstChild); //true</span><br></pre></td></tr></table></figure>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var body = document.body; //取得对&lt;body\\&gt;的引用</span><br><span class=\"line\">var head = document.body; //取得对&lt;head\\&gt;的引用</span><br></pre></td></tr></table></figure>\n<p><strong>所有浏览器都支持 document.documentElement 和 document.body 属性</strong></p>\n</li>\n</ul>\n</li>\n<li><p>作为 HTMLDocument 的一个实例，document 对象还有一些标准的 Document 对象所没有的属性。这些属性提供了 document 对象所表现的网页的一些信息。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//取得文档标题</span><br><span class=\"line\">var originalTitle = document.title; </span><br><span class=\"line\"></span><br><span class=\"line\">//设置文档标题</span><br><span class=\"line\">document.title = &quot;New page title&quot;;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//取得完整的 URL</span><br><span class=\"line\">var url = document.URL; </span><br><span class=\"line\"></span><br><span class=\"line\">//取得域名</span><br><span class=\"line\">var domain = document.domain; </span><br><span class=\"line\"></span><br><span class=\"line\">//取得来源页面的 URL</span><br><span class=\"line\">var referrer = document.referrer;</span><br></pre></td></tr></table></figure>\n<p> <strong>在这 3 个属性中，只有 domain 是可以设置的</strong></p>\n</li>\n</ol>\n<h2 id=\"节点的属性\"><a href=\"#节点的属性\" class=\"headerlink\" title=\"节点的属性\"></a><strong>节点的属性</strong></h2><ol>\n<li><p>nodeType：返回数字，用来区分节点类型，只读</p>\n</li>\n<li><p>nodeName: 主要是用于元素节点，返回元素节点的标签名，已大写形式表示，只读</p>\n</li>\n<li><p>nodeValue: 主要用于文本节点和注释节点，访问其文本内容，值可读写</p>\n</li>\n<li><p>attribute：属性节点的属性集合</p>\n</li>\n<li><p>关于属性节点：关于属性节点，属性名改不了，属性值改得了，如图：</p>\n<p> <img src=\"/images/blog_images/js_basic/3.jpg\" alt=\"image\"><br> <img src=\"/images/blog_images/js_basic/4.jpg\" alt=\"image\"><br> <img src=\"/images/blog_images/js_basic/5.jpg\" alt=\"image\"><br> <img src=\"/images/blog_images/js_basic/6.jpg\" alt=\"image\"></p>\n<p> <strong>尽管属性节点也是节点，但特性却不被认为是 DOM 文档树的一部分。开发人员最常使用的是 getAttribute()、setAttribute()和 remveAttribute()方法，很少直接引用特性节点。</strong></p>\n</li>\n</ol>\n<h2 id=\"节点的关系和访问\"><a href=\"#节点的关系和访问\" class=\"headerlink\" title=\"节点的关系和访问\"></a><strong>节点的关系和访问</strong></h2><ol>\n<li><p>childNodes</p>\n<ul>\n<li>每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象（类数组）</li>\n<li>在 NodeList 中的节点——可以通过方括号，也可以使用 item()方法</li>\n</ul>\n</li>\n<li><p>parentNode </p>\n</li>\n<li><p>previousSibling</p>\n</li>\n<li><p>nextSibling </p>\n</li>\n<li><p>firstChild </p>\n</li>\n<li><p>lastChild</p>\n</li>\n<li><p>hasChildNodes()</p>\n</li>\n<li><p>ownerDocument: 该属性指向表示整个文档的文档节点</p>\n</li>\n<li><p>appendChild(): 用于向 childNodes 列表的末尾添加一个节点,返回新增的节点</p>\n</li>\n<li><p>insertBefore():这个方法接受两个参数：要插入的节点和作为参照的节点,插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回</p>\n</li>\n<li><p>replaceChild():接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置</p>\n</li>\n<li><p>removeChild():这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值，</p>\n</li>\n<li><p>cloneNode():接受一个布尔值参数，表示是否执行深复制。在参数为 true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为 false 的情况下，执行浅复制，即只复制节点本身</p>\n<ul>\n<li><strong>cloneNode()方法不会复制添加到 DOM 节点中的 JavaScript 属性，例如事件处理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切都不会复制。IE 在此存在一个 bug，即它会复制事件处理程序，所以我们建议在复制之前最好先移除事件处理程序</strong></li>\n</ul>\n</li>\n<li><p>normalize():这个方法唯一的作用就是处理文档树中的文本节点</p>\n</li>\n</ol>\n<p><img src=\"/images/blog_images/js_basic/9.jpg\" alt=\"image\"><br><strong>PARENTNODE.appendChild()是剪切操作，parent.removeChild()是剪切出来，返回出来，child.remove()是真正的销毁,parent.replaceChild(new,origin)也是剪切出来</strong></p>\n<p><img src=\"/images/blog_images/js_basic/10.jpg\" alt=\"image\"></p>\n<ol start=\"15\">\n<li><p>还有outerHtml/outerText</p>\n<blockquote>\n<p>支持 innerText/outerText 属性的浏览器包括 IE4+、Safari 3+、Opera 8+和 Chrome。Firefox 虽然不支持innerText，但支持作用类似的 textContent 属性。textContent 是 DOM Level 3 规定的一个属性，其他支持 textContent 属性的浏览器还有 IE9+、Safari 3+、Opera 10+和 Chrome。为了确保跨浏览器兼容，有必要编写一个类似于下面的函数来检测可以使用哪个属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">兼容函数</span><br><span class=\"line\">function getInnerText(element)&#123; </span><br><span class=\"line\">return (typeof element.textContent == &quot;string&quot;) ? element.textContent : element.innerText; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">function setInnerText(element, text)&#123; </span><br><span class=\"line\">if (typeof element.textContent == &quot;string&quot;)&#123; </span><br><span class=\"line\">    element.textContent = text; </span><br><span class=\"line\">&#125; else &#123; </span><br><span class=\"line\">    element.innerText = text; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>InnerHTML,innerText都是覆盖原有的内容，看下面的例子：<br><img src=\"/images/blog_images/js_basic/11.jpg\" alt=\"image\"><br><img src=\"/images/blog_images/js_basic/12.jpg\" alt=\"image\"></p>\n</li>\n</ol>\n<blockquote>\n<p>NodeList 对象的独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中，NodeList 是有生命、有呼吸的对象，而不是在我们第一次访问它们的某个瞬间拍摄下来的一张快照</p>\n</blockquote>\n<h2 id=\"元素节点的关系和访问\"><a href=\"#元素节点的关系和访问\" class=\"headerlink\" title=\"元素节点的关系和访问\"></a><strong>元素节点的关系和访问</strong></h2><ol>\n<li><p>Element Traversal API 为 DOM 元素添加了以下 5 个属性。</p>\n<ul>\n<li>childElementCount：返回子元素（不包括文本节点和注释）的个数。</li>\n<li>firstElementChild：指向第一个子元素；firstChild 的元素版。</li>\n<li>lastElementChild：指向最后一个子元素；lastChild 的元素版。</li>\n<li>previousElementSibling：指向前一个同辈元素；previousSibling 的元素版</li>\n<li><p>nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。</p>\n<p><strong>（以上支持 Element Traversal 规范的浏览器有 IE 9+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10+。）</strong></p>\n</li>\n</ul>\n</li>\n<li><p>兼容性很好的一个元素子节点的访问</p>\n<ul>\n<li>children: 只返回当前元素的元素子节点</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"元素节点的获取-通过document的方法\"><a href=\"#元素节点的获取-通过document的方法\" class=\"headerlink\" title=\"元素节点的获取(通过document的方法)\"></a><strong>元素节点的获取(通过document的方法)</strong></h2><ol>\n<li><p>getElementsByTagName()</p>\n<ul>\n<li><p>这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似</p>\n</li>\n<li><p>HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name特性取得集合中的项</p>\n</li>\n<li><p>在提供按索引访问项的基础上，HTMLCollection 还支持按名称访问项，这就为我们取得实际想要的元素提供了便利。而且，对命名的项也可以使用方括号语法来访问</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myImage = images[&quot;myImage&quot;];</span><br></pre></td></tr></table></figure>\n<p><strong>对 HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 item()，而对字符串索引就会调用 namedItem()。</strong></p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>getElementsById()</p>\n<ul>\n<li><p>这里的 ID 必须与页面中元素的 id特性（attribute）严格匹配，包括大小写(<strong>IE8 及较低版本不区分 ID 的大小写，因此”myDiv”和”mydiv”会被当作相同的元素 ID</strong>)</p>\n</li>\n<li><p>如果页面中多个元素的 ID 值相同，getElementById()只返回文档中第一次出现的元素</p>\n<blockquote>\n<p>IE7 及较低版本还为此方法添加了一个有意思的“怪癖”：name 特性与给定 ID 匹配的表单元素（input、textarea、button及 select）也会被该方法返回。如果有哪个表单元素的 name 特性等于指定的 ID，而且该元素在文档中位于带有给定 ID 的元素前面，那么 IE 就会返回那个表单元素</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>getElementsByName()</p>\n<ul>\n<li>与 getElementsByTagName()类似，getElementsByName()方法也会返回一个 HTMLCollectioin。但是，对于这里的单选按钮来说，namedItem()方法则只会取得第一项（因为每一项的 name 特性都相同）</li>\n</ul>\n</li>\n<li><p>getElementsByClassName()</p>\n<ul>\n<li><p>HTML5 添加的 getElementsByClassName()方法是最受人欢迎的一个方法，可以通过 document对象及所有 HTML 元素调用该方法</p>\n</li>\n<li><p><strong>支持 getElementsByClassName()方法的浏览器有 IE 9+、Firefox 3+、Safari 3.1+、Chrome 和 Opera 9.5+</strong></p>\n<p><img src=\"/images/blog_images/js_basic/8.jpg\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li><p>除了属性和方法，document 对象还有一些特殊的集合</p>\n<ul>\n<li>document.anchors，包含文档中所有带 name 特性的&lt;a>元素；</li>\n<li>document.applets，包含文档中所有的&lt;applet>元素，因为不再推荐使用&lt;applet>元素，<br>所以这个集合已经不建议使用了；</li>\n<li>document.forms，包含文档中所有的&lt;form>元素，与 document.getElementsByTagName(“form”)<br>得到的结果相同；</li>\n<li>document.images，包含文档中所有的&lt;img>元素，与 document.getElementsByTagName (“img”)得到的结果相同；</li>\n<li><p>document.links，包含文档中所有带 href 特性的&lt;a>元素。</p>\n<p><strong>这个特殊集合始终都可以通过 HTMLDocument 对象访问到，而且，与 HTMLCollection 对象类似，集合中的项也会随着当前文档内容的更新而更新</strong></p>\n</li>\n</ul>\n</li>\n<li><p>其他常见的方法：document.write()、document.writeln()、document.open()和 document.close()</p>\n<ul>\n<li><p>document.write()在页面被呈现的过程中直接向其中输出了内容。如果在文档加载结束后再调用 document.write(),比如在document.onload触发后</p>\n</li>\n<li><p>在document.write()中动态地包含外部资源，要将字符串中的”&lt;/script>“标签用转义字符转义，不然但字符串”&lt;/script>“将被解释为与外部的&lt;script>标签匹配，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt; </span><br><span class=\"line\">    &lt;head&gt; </span><br><span class=\"line\">        &lt;title&gt;document.write() Example 3&lt;/title&gt; </span><br><span class=\"line\">    &lt;/head&gt; </span><br><span class=\"line\">    &lt;body&gt; </span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt; </span><br><span class=\"line\">        document.write(&quot;&lt;script type=\\&quot;text/javascript\\&quot; src=\\&quot;file.js\\&quot;&gt;&quot; + </span><br><span class=\"line\">        &quot;&lt;\\/script&gt;&quot;); </span><br><span class=\"line\">    &lt;/script&gt; </span><br><span class=\"line\">    &lt;/body&gt; </span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"元素节点的获取-通过querySelector-的方法\"><a href=\"#元素节点的获取-通过querySelector-的方法\" class=\"headerlink\" title=\"元素节点的获取(通过querySelector()的方法)\"></a><strong>元素节点的获取(通过querySelector()的方法)</strong></h2><ol>\n<li>Selectors API（<a href=\"http://www.w3.org/TR/selectors-api/）是由\" target=\"_blank\" rel=\"noopener\">www.w3.org/TR/selectors-api/）是由</a> W3C 发起制定的一个标准（两个方法：querySelector()和 querySelectorAll()属于Selectors API Level 1）</li>\n</ol>\n<p>2.支持querySelector()可以通过 Document 及 Element 类型的实例调用它们</p>\n<p>3.目前已完全支持 Selectors API Level 1的浏览器有 IE 8+、Firefox 3.5+、Safari 3.1+、Chrome 和 Opera 10+</p>\n<p>4.querySelector()方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null，如果传入了不被支持的选择符，querySelector()会抛出错误。</p>\n<p>5.querySelectorAll()方法接收的参数是一个 CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个 NodeList 的实例，其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询，能够调用 querySelectorAll()方法的类型包括 Document、DocumentFragment 和 Element</p>\n<p>6.其实还有一个matchesSelector()方法，用来查看调用元素与该选择符是否匹配，匹配返回 true；否则返回 false。兼容性不好很少用</p>\n<h2 id=\"html元素的属性和方法\"><a href=\"#html元素的属性和方法\" class=\"headerlink\" title=\"html元素的属性和方法\"></a><strong>html元素的属性和方法</strong></h2><ol>\n<li><h3 id=\"获取元素的特性\"><a href=\"#获取元素的特性\" class=\"headerlink\" title=\"获取元素的特性\"></a><strong>获取元素的特性</strong></h3><ul>\n<li><p>所有 HTML 元素都由 HTMLElement 类型表示，HTMLElement 类型直接继承自Element 并添加了一些属性，添加的这些属性分别对应于每个 HTML<br>元素中都存在的下列标准特性：</p>\n<ul>\n<li><p>id，元素在文档中的唯一标识符。</p>\n</li>\n<li><p>title，有关元素的附加说明信息，一般通过工具提示条显示出来。</p>\n</li>\n<li><p>lang，元素内容的语言代码，很少使用。</p>\n</li>\n<li><p>dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），<br>也很少使用。</p>\n</li>\n<li><p>className，与元素的class 特性对应，即为元素指定的CSS类。没有将这个属性命名为class，<br>是因为 class 是 ECMAScript 的保留字</p>\n<p><strong>上述这些属性都可以用来取得或修改相应的特性值。</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>除了上面的获取和修改dom特性的方法，操作特性的DOM 方法主要有三个，分别是 getAttribute()、setAttribute()和 removeAttribute()，主要可以获取自定义的属性，不过，特性的名称是不区分大小写的，即”ID”和”id”代表的都是同一个特性。另外也要注意，根据 HTML5 规范，自定义特性应该加上 data-前缀以便验证</p>\n</li>\n<li><h3 id=\"脚本化css\"><a href=\"#脚本化css\" class=\"headerlink\" title=\"脚本化css\"></a>脚本化css</h3><ul>\n<li><p><strong>dom.style</strong>:获取元素行间样式，返回的是一个对象</p>\n<ul>\n<li>可读写行间样式，没有兼容性问题，碰到float保留字，在前面加css（cssFloat）</li>\n<li>复合属性必须拆解，组合单词编程小驼峰式   </li>\n<li>写入的值必须是字符串格式</li>\n<li><p>dom.style.prop展示的行间的样式，返回的是字符串</p>\n</li>\n<li><p>“DOM2级样式”规范还为 style 对象定义了一些属性和方法</p>\n<blockquote>\n<p>cssText：如前所述，通过它能够访问到 style 特性中的 CSS 代码。<br>length：应用给元素的 CSS 属性的数量。<br>parentRule：表示 CSS 信息的 CSSRule 对象。。<br>getPropertyCSSValue(propertyName)：返回包含给定属性值的 CSSValue 对象。<br>getPropertyPriority(propertyName)：如果给定的属性使用了!important 设置，则返回<br>  “important”；否则，返回空字符串。<br>getPropertyValue(propertyName)：返回给定属性的字符串值。<br>item(index)：返回给定位置的 CSS 属性的名称。<br>removeProperty(propertyName)：从样式中删除给定属性。<br>setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先    权标志（”important”或者一个空字符串）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>查询计算样式</strong>： DOM2 级样式”增强了 document.defaultView，提供了window.getComputedStyle(ele, null)方法</p>\n<ul>\n<li>计算样式只读</li>\n<li>返回样式的值都是绝对值，没有相对单位，比如如果有em会被转换成px<br>  <img src=\"/images/blog_images/js_basic/13.jpg\" alt=\"image\"><br>  <img src=\"/images/blog_images/js_basic/14.jpg\" alt=\"image\"></li>\n<li>IE8及以下不兼容</li>\n<li>获取的是这个当前元素所展示一切css的显示值 （就是你看到css的最终属性，包括默认值）</li>\n<li>Window.getComputedStyle(ele,null)括号里面的null可以获取伪元素的样式表<br>  <img src=\"/images/blog_images/js_basic/15.jpg\" alt=\"image\"></li>\n</ul>\n</li>\n<li><p><strong>IE浏览器特有的查询计算样式</strong>：ele.currentStyle</p>\n<ul>\n<li>计算样式只读</li>\n<li>返回的计算样式不是经过转换的绝对值</li>\n</ul>\n</li>\n<li><p><strong>针对计算样式封装兼容性</strong><br>  <img src=\"/images/blog_images/js_basic/16.jpg\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>dom.onclick:设置行间点击事件</p>\n</li>\n<li><p>HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList 属性。这个 classList 属性是新集合类型 DOMTokenList 的实例。与其他 DOM 集合类似，DOMTokenList 有一个表示自己包含多少元素的 length 属性，而要取得每个元素可以使用 item()方法，也可以使用方括号语法。此外，这个新类型还定义如下方法。</p>\n<ul>\n<li>add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。</li>\n<li>contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。</li>\n<li>remove(value)：从列表中删除给定的字符串。</li>\n<li>toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。这样，前面那么多行代码用下面这一行代码就可以代替了</li>\n</ul>\n</li>\n<li><h3 id=\"获取元素的偏移量等\"><a href=\"#获取元素的偏移量等\" class=\"headerlink\" title=\"获取元素的偏移量等\"></a>获取元素的偏移量等</h3><ul>\n<li><p>偏移量</p>\n<ul>\n<li><p>offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。</p>\n</li>\n<li><p>offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）直滚动条的宽度、左边框宽度和右边框宽度。</p>\n</li>\n<li><p>offsetLeft：<strong>元素的左外边框</strong> 至包含元素的 <strong>左内边框之间的像素距离</strong>。对于无定位的父级，但会相对于文档的坐标，对于有定位的父级，返回相对于最近有定位父级的坐标</p>\n</li>\n<li><p>offsetTop：元素的上外边框至包含元素的上内边框之间的像素，同上</p>\n<p><strong>所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高</strong></p>\n</li>\n</ul>\n</li>\n<li><p>客户区大小    </p>\n<ul>\n<li><p>clientHeight：表示的是可视区域的高度，不包含border和滚动条，其他同理 </p>\n</li>\n<li><p>针对浏览器视口大小的获取可以使用clientHeight，innerHeight（只有window中有，IE8及以下不兼容），封装函数如下：<br><img src=\"/images/blog_images/js_basic/17.jpg\" alt=\"image\"></p>\n<blockquote>\n<p>这个函数首先检查 document.compatMode 属性，以确定浏览器是否运行在混杂模式</p>\n</blockquote>\n<p><strong>与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的</strong></p>\n</li>\n</ul>\n</li>\n<li><p>滚动大小</p>\n<ul>\n<li><p>存在浏览器窗口的滚动条，还有则需要通过 CSS 的overflow 属性进行设置才能滚动元素</p>\n</li>\n<li><p>scrollHeight：在没有滚动条的情况下，元素内容的总高度。</p>\n</li>\n<li>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。</li>\n<li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li>\n<li><p>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</p>\n</li>\n<li><p>针对于浏览器窗口的滚动，还有一个可以获取滚动距离的是window.pageXoffset(IE8及以下不兼容)</p>\n</li>\n</ul>\n</li>\n<li><p>元素大小</p>\n<ul>\n<li>IE、Firefox 3+、Safari 4+、Opera 9.5及 Chrome为每个元素都提供了一个 getBoundingClientRect()方法。这个方法返回会一个矩形对象，包含 4 个属性：left、top、right 和 bottom，这些属性给出了元素在页面中相对于视口的位置，还有width和height（老版本IE没有实现），包含了padding和border，<strong>返回的结果不是实时的</strong><br>12</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"谈JavaScript性能提升","url":"http://yoursite.com/2018/09/29/JS_High_Performance/","content":"<h3 id=\"一、基于数据访问提升性能\"><a href=\"#一、基于数据访问提升性能\" class=\"headerlink\" title=\"一、基于数据访问提升性能\"></a><strong>一、基于数据访问提升性能</strong></h3><ol>\n<li><p>在JavaScript中，数组的存储位置可以对代码整体性能产生重要的影响。有四种数据访问类型：直接量，变量，数组项，对象成员。他们有不同的性能考虑：</p>\n<ul>\n<li><p>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间</p>\n</li>\n<li><p>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为他们总是位于作用域链的最后一环</p>\n</li>\n<li><p>避免使用width表达式，因为他改变了运行期上下文的作用域链。而且因当小心try-catch表达式的catch子句，因为它具有同样的效果</p>\n</li>\n<li><p>嵌套对象成员会造成重大的性能影响，尽量少用</p>\n</li>\n<li><p>一个属性或方法在原型链中的位置越深，访问他的速度就越慢</p>\n</li>\n</ul>\n</li>\n<li><p><strong>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的书读会快于那些原始变量</strong>通过使用这些策略，你可以极大地提高那些需要大量JavaScript代码的网页应用的实际性能</p>\n</li>\n</ol>\n<h3 id=\"二、基于DOM创建、访问和操作提升性能\"><a href=\"#二、基于DOM创建、访问和操作提升性能\" class=\"headerlink\" title=\"二、基于DOM创建、访问和操作提升性能\"></a><strong>二、基于DOM创建、访问和操作提升性能</strong></h3><ol>\n<li><p>Javascript分为三部分DOM,BOM和ECMAScript，他们都是相互独立的，JavaScript要访问DOM，这两个独立的部分以功能接口连接就会带来性能损耗。一个很形象的的比域就是帮他们两个比作是两个独立的岛屿，其中一个岛屿要到另一岛屿就要通过一座桥，通过这座桥是要交费用的所以每过一次就多一次费用，好比JavaScript对DOM的访问获取，所以要尽量减少对DOM节点的访问获取，努力停留在ECMAScript岛屿上，还有DOM获取后还会操作DOM，那这个费用就更高了（即修改DOM的长宽、颜色等会导致页面的回流和重绘，消耗性能，也应该尽量减少）</p>\n</li>\n<li><p>在innerHTML和document.createElemnt来给文档创建DOM节点中，innerHTML速度会更快些，除了最新的基于webkit的浏览器（Chrome和Safari，反而另外一个更快），还有一种创建新的DOM节点就是通过克隆已有的节点，在大多数浏览器中，克隆节点更有效率，但提高不太多</p>\n</li>\n<li><p>HTML集合是存放DOM的一个对象（类数组），比如下面函数返回的就是一个集合：</p>\n</li>\n</ol>\n<blockquote>\n<p>document.getElementsByName()<br>document.getElementsByClassName()<br>document.getElementsByTagName_r()<br>document.images 页面中所有的<img>元素<br>document.links 页面中所有的<a>元素<br>document.forms 页面中所有的表单<br>document.forms[0].elements 页面中第一个表单的所有字段</a></p>\n</blockquote>\n<p><strong>记住：正如DOM标准所定义那样，HTML集合是一个“虚拟存在，意味着底层文档更新时，它们将自动更新”</strong></p>\n<ol start=\"4\">\n<li>HTML集合实际上在查询文档，当你信息更新时，每次都要重复这种查询操作，例如读取集合元素的数目。这正是低效率的来源</li>\n</ol>\n<h3 id=\"三、基于DOM节点的访问的性能提升\"><a href=\"#三、基于DOM节点的访问的性能提升\" class=\"headerlink\" title=\"三、基于DOM节点的访问的性能提升\"></a><strong>三、基于DOM节点的访问的性能提升</strong></h3><ol>\n<li><p>节点访问的时候如果有直接访问元素节点的API就直接用（比如children的访问肯定比childrenNode访问要快，因为children集合项更新少遍历快），不能直接访问元素节点的 <strong>如IE9及以下仅支持node.children</strong> </p>\n</li>\n<li><p>DOM选择器API：querySelectorAll()，括号内的查找跟css选择器查找类似（IE8及以上支持）,还有一个就是querySelector()，这个选择器放回符合元素节点的<br>第一位，<strong>他们不是HTML集合（即信息不是实时的）</strong>，相比于通过getElementsByClassName等的方法来通过迭代操作获取到精确的DOM，querySelectorAll()更快</p>\n</li>\n<li><p>获取DOM布局信息的操作时也会导致重排重绘制（因为这些信息要返回的时最新的数据，所以要重新计算)：如</p>\n<ul>\n<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>\n<li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li>\n<li>clientTop, clientLeft, clientWidth, clientHeight</li>\n<li>getComputedStyle() (currentStyle in IE)在IE中此函数称作为currentStyle</li>\n</ul>\n</li>\n<li><p>页面上的某一个元素的大小信息的改变都会导致一部分需要重排重绘，但是某些改变可导致重排整个页面，例如，当一个咕哝当条的出现</p>\n</li>\n</ol>\n<h3 id=\"四、减少DOM的重派重绘\"><a href=\"#四、减少DOM的重派重绘\" class=\"headerlink\" title=\"四、减少DOM的重派重绘\"></a><strong>四、减少DOM的重派重绘</strong></h3><ol>\n<li><p>优化style的改变</p>\n<ul>\n<li><p>为减少重排重绘的发生次数，应该将多个DOM和风格的改变合并到一块一次性执行（大多数浏览器都会进行优化只进行一次重排重绘）。</p>\n</li>\n<li><p>还有一个具有同样效果的方法就是使用cssText属性：el.style.cssText = ‘border-left: 1px; border-right: 2px; padding: 5px;’;el.style.cssText += ‘; border-left: 1px;’;</p>\n</li>\n<li><p>还有另外一种就是改变DOM的class值，通过切换class值来达到样式的改变</p>\n</li>\n</ul>\n</li>\n<li><p>批量修改DOM</p>\n<ul>\n<li><p>要对一个DOM元素进行修改，将他的display设置为none之后进行操作，操作完毕后将display再设置回去</p>\n</li>\n<li><p>针对要增加节点之类的可以通过文档片断，文档片断是一个轻量级的document对象，将你到添加的DOM内容放入文档片断中，然后将文档片断添加到实际的DOM中，注意实际添加的时文档片断中的内容，不是片断本身( <strong>推荐尽可能的用这种，因为这种涉及最少的DOM操作</strong> )</p>\n</li>\n<li><p>可以通过克隆节点的方法，将克隆下来的节点进行修改（ele.cloneNode()），修改后再替换旧的节点</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"五、基于动画性能优化\"><a href=\"#五、基于动画性能优化\" class=\"headerlink\" title=\"五、基于动画性能优化\"></a><strong>五、基于动画性能优化</strong></h3><ol>\n<li><p>动画中使用绝对坐标定位页面中的动画元素，使他位于页面布局流之外</p>\n</li>\n<li><p>启动GPU硬件加速</p>\n<ul>\n<li><a href=\"https://aotu.io/notes/2017/04/11/GPU/\" target=\"_blank\" rel=\"noopener\">GPU加速是什么</a></li>\n<li><a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">普通图层和复合图层</a></li>\n<li><a href=\"http://web.jobbole.com/83575/\" target=\"_blank\" rel=\"noopener\">CSS3硬件加速也有坑</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"六、-hover\"><a href=\"#六、-hover\" class=\"headerlink\" title=\"六、:hover\"></a><strong>六、:hover</strong></h3><ol>\n<li>避免过多的元素中（如500-1000行5列构成的表）使用：hover时 否则会降低反映速度，cpu使用率会提高到80%-90%</li>\n</ol>\n<h3 id=\"七、事件委托\"><a href=\"#七、事件委托\" class=\"headerlink\" title=\"七、事件委托\"></a><strong>七、事件委托</strong></h3><ol>\n<li>利用了事件流的事件冒泡和事件源对象来实现事件委托</li>\n</ol>\n<p>2.优点：</p>\n<p>① 不需要对每个dom进行绑定事件，只需对父级进行绑定，减少内存消耗，提高性能</p>\n<p>② 动态绑定事件，对新添进来的子元素不需要绑定事件</p>\n<h3 id=\"八、基于循环的性能优化\"><a href=\"#八、基于循环的性能优化\" class=\"headerlink\" title=\"八、基于循环的性能优化\"></a><strong>八、基于循环的性能优化</strong></h3><ol>\n<li><p>JavaScript有四种循环： for循环，while，do-while，for-in</p>\n</li>\n<li><p>JavaScript提供的四中循环里，只有一种循环比其他的循环明显要慢：for-in循环，由于每次迭代时都要搜索对象中的属性和对象原型上的属性，同样的循环迭代的操作中，for-in循环要比其它的循环慢7倍之多，除非你对数目不详的对象属性进行操作，否则避免使用for-in循环，其它的三个循环性能都相当</p>\n</li>\n<li><p>对一个数组的循环遍历属性，一个优化就是将数组的长度存放到局部变量中，以防止每次循环都要访问数组的长度arr.length,以此提升性能</p>\n</li>\n<li><p>还有一个很重要的优化就是使用倒序循环，并在控制条件中使用了减法，每个控制条件只是简单的和0进行比较。控制条件与true值进行比较，任何非零数字转化为true，0转化为false，控制条件已从两次比较（迭代次数小于总数了吗？它等于false了吗）变成了一次比较（它等于true了吗？），以此可以大幅度提高循环速度，<strong>通过倒序循环和最小化属性查询，当循环迭代次数很多时可以大幅度提升执行速度</strong></p>\n</li>\n<li><p>事实证明大多数情况下switch表达式比if-else更快，担当只有条件数量很大时才明显更快，if-else适合判断两个离散的值或判断几个不同的值域。如果判断多余两个离散值，switch表达式更好</p>\n</li>\n</ol>\n<h3 id=\"九、递归和迭代\"><a href=\"#九、递归和迭代\" class=\"headerlink\" title=\"九、递归和迭代\"></a><strong>九、递归和迭代</strong></h3><ol>\n<li><p>任何可以实现递归的算法都可以用迭代实现。迭代算法通常包括几个不同的循环，分别对应算法过程的不同方面，也会导致自己的性能问题。但是，使用优化的循环代替长时间的运行的递归函数可以提高性能，因为运行一个循环比反复调用一个函数的开销要低。</p>\n</li>\n<li><p>将递归算法切换为迭代只是避免栈溢出错误的方法之一</p>\n</li>\n</ol>\n<h3 id=\"十、制表\"><a href=\"#十、制表\" class=\"headerlink\" title=\"十、制表\"></a><strong>十、制表</strong></h3><ol>\n<li><p>制表，通过缓存先前计算结果为后续计算所重复使用，避免了重复的工作。这使得制表成为递归算法中有用的技术</p>\n</li>\n<li><p>为了是一个函数的制表过程更加容易，你可以定义一个memorize()函数封装基本功能。例如：</p>\n<pre><code>function memoize(fundamental, cache){\n    cache = cache || {};\n    var shell = function(arg){\n        if (!cache.hasOwnProperty(arg)){\n            cache[arg] = fundamental(arg);\n        }\n        return cache[arg];\n    };\n    return shell;\n}\n</code></pre></li>\n</ol>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"事件, 事件处理模型, 事件流, 事件委托","url":"http://yoursite.com/2018/09/28/Event-/","content":"<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"如何绑定事件-事件是天生自然有的\"><a href=\"#如何绑定事件-事件是天生自然有的\" class=\"headerlink\" title=\"如何绑定事件(事件是天生自然有的)\"></a><strong>如何绑定事件(事件是天生自然有的)</strong></h3><ol>\n<li><p>行间绑定事件，属于 <strong>HTML事件处理程序</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>ele.onxxx = function (event) {}，属于<strong>DOM0 级事件处理程序</strong></p>\n<ul>\n<li><p>兼容性很好，但是一个元素只能绑定一个处理程序</p>\n</li>\n<li><p>基本等同于写在HTML行间上（两种都称为句柄的绑定方式）</p>\n</li>\n<li><p>程序this指向是dom元素本身</p>\n</li>\n</ul>\n</li>\n<li><p>ele.addEventListener(type, fn, false)，属于 <strong>DOM2 级事件处理程序</strong></p>\n<ul>\n<li><p><strong>IE9 以下不兼容</strong>，可以为一个事件绑定多个处理程序，并且按绑定的顺序去执行（谁先绑定谁先执行， 但不能够给同一个函数绑定多次）</p>\n</li>\n<li><p>程序this指向是dom元素本身</p>\n</li>\n</ul>\n</li>\n<li><p>ele.attachEvent(‘on’ + type, fn);    属于<strong>IE 事件处理程序</strong>，支持 IE 事件处理程序的浏览器有 IE 和 Opera。   </p>\n<ul>\n<li><p>IE独有，一个事件同样可以绑定多个处理程序（但是它一个对象的一个事件绑定同一个函数绑定了多次，它都能执行多次）</p>\n</li>\n<li><p>程序this指向window</p>\n</li>\n<li><p>不过，与 DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。单击这个例子中的按钮，首先看到的是”Hello world!”，然后才是”Clicked”。如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var btn = document.getElementById(&quot;myBtn&quot;); </span><br><span class=\"line\">btn.attachEvent(&quot;onclick&quot;, function()&#123; </span><br><span class=\"line\">    alert(&quot;Clicked&quot;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">btn.attachEvent(&quot;onclick&quot;, function()&#123; </span><br><span class=\"line\">    alert(&quot;Hello world!&quot;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>封装兼容性的 addEvent(elem, type, handle)方法：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addEvent(elem,type,handle)&#123;</span><br><span class=\"line\">    if(elem.addEventListener)&#123;</span><br><span class=\"line\">        elem.addEventListener(type,handle,false);</span><br><span class=\"line\">    &#125;else if(elem.attachEvent)&#123;</span><br><span class=\"line\">        elem.attachEvent(&apos;on&apos; + type,function()&#123;</span><br><span class=\"line\">            handle.call(elem);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        elem[&apos;on&apos;+ type] = handle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"解除事件处理程序\"><a href=\"#解除事件处理程序\" class=\"headerlink\" title=\"解除事件处理程序\"></a><strong>解除事件处理程序</strong></h3><ol>\n<li><p>ele.onclick = false/‘’/null;</p>\n</li>\n<li><p>ele.removeEventListener(type, fn, false);</p>\n</li>\n<li><p>ele.detachEvent(‘on’ + type, fn);</p>\n</li>\n<li><p>注:解除事件，要用相对应的解除事件处理程序，若绑定匿名函数，则无法解除</p>\n</li>\n<li><p>封装兼容性的 removeEvent(elem, type, handle)方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function removeEvent(elem, type, handle) &#123;</span><br><span class=\"line\">    if (elem.removeEventListener) &#123;</span><br><span class=\"line\">        elem.removeEventListener(type, handle, false);</span><br><span class=\"line\">    &#125; else if (elem.detachEvent) &#123;</span><br><span class=\"line\">        elem.detachEvent(&apos;on&apos; + type, function () &#123;</span><br><span class=\"line\">            handle.call(elem);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        elem[&apos;on&apos; + type] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"事件处理模型-事件冒泡、事件捕获\"><a href=\"#事件处理模型-事件冒泡、事件捕获\" class=\"headerlink\" title=\"事件处理模型 - 事件冒泡、事件捕获\"></a><strong>事件处理模型 - 事件冒泡、事件捕获</strong></h3><ol>\n<li><p>事件冒泡：结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上，<strong>IE8 及更早版本只支持事件冒泡，</strong>）<br> <img src=\"/images/blog_images/event/1.jpg\" alt=\"image\"></p>\n</li>\n<li><p>事件捕获：结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向下,<strong>IE9、Safari、Chrome、Opera和 Firefox 目前也都支持这种事件流模型</strong>）<br> <img src=\"/images/blog_images/event/1.jpg\" alt=\"image\"></p>\n</li>\n<li><p>IE没有捕获事件</p>\n</li>\n<li><p>触发顺序，先捕获，后冒泡，focus blur change submit reset select load unload等事件不冒泡</p>\n</li>\n<li><p>当一个对象的一个事件类型绑定两个函数是，一个是冒泡，一个是捕获，执行的顺序是先捕获后冒泡：（执行结果中box在boxBubble下面是因为一个对象的一个事件类型绑定不同的函数，谁先绑定谁先执行）注意：冒泡的开始不属于冒泡是执行，捕获的最终不属于捕获是执行，如下：</p>\n<p> <img src=\"/images/blog_images/event/3.jpg\" alt=\"image\"> <img src=\"/images/blog_images/event/4.jpg\" alt=\"image\"></p>\n</li>\n</ol>\n<h3 id=\"取消冒泡和阻止默认事件\"><a href=\"#取消冒泡和阻止默认事件\" class=\"headerlink\" title=\"取消冒泡和阻止默认事件\"></a><strong>取消冒泡和阻止默认事件</strong></h3><ol>\n<li><p>取消冒泡：</p>\n<ul>\n<li><p>W3C标准 event.stopPropagation();但不支持ie9以下版本,<strong>stopPropagatioin()可以同时取消事件捕获和冒泡。</strong></p>\n</li>\n<li><p>IE独有 event.cancelBubble = true;</p>\n</li>\n<li><p>封装取消冒泡的函数 stopBubble(event)：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function stopBubble(event) &#123;</span><br><span class=\"line\">    if(event.stopPropagation)&#123;</span><br><span class=\"line\">        event.stopPropagation();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.cancelBubble = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>阻止默认事件:</p>\n<ul>\n<li>默认事件 — 表单提交，a标签跳转，右键菜单等</li>\n<li>return false;  以对象属性的方式注册的事件才生效（是句柄的方式来阻止默认事件。只有我们用句柄的方式绑定默认事件用return false才好使）</li>\n<li>event.preventDefault(); W3C标准，IE9以下不兼容</li>\n<li>event.returnValue = false; 兼容IE</li>\n<li><p>封装阻止默认事件的函数 cancelHandler(event)，<strong>return false 是封装不进去的</strong>：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function cancelHandle(event) &#123;</span><br><span class=\"line\">    if(event.preventDefault)&#123;</span><br><span class=\"line\">        event.preventDefault();</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>2.div.onclick = function(e){},这个e参数添加后，系统会帮我们传一个事件对象，对象上面有很多属性，每一个属性都记载了事件发生时的关键性数据和一系列信息，event.stopPropagation();  e.cancelBubble = true:谷歌也能实现了</p>\n</li>\n<li><p>A标签有一个默认事件，就是点击后会回到页面最顶端，取消这个默认事件的简便方法有：void（false/ 0）意思是return false：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;javascript: void(false)&quot;&gt;demo&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a><strong>事件流</strong></h3><ol>\n<li><p>事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。</p>\n<ul>\n<li>事件捕获阶段（IE8及以下不支持）</li>\n<li>处于目标阶段</li>\n<li>事件冒泡阶段</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a><strong>事件委托</strong></h3><ol>\n<li><p>利用事件冒泡，和事件源对象进行处理</p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>不需要对每个dom进行绑定事件，只需对父级进行绑定，减少内存消耗，提高性能</li>\n<li>动态绑定事件，对新添进来的子元素不需要绑定事件</li>\n</ul>\n</li>\n<li><p>适合用事件委托的事件：click, mousedown, mouseup, keydown, keyup, keypress</p>\n</li>\n</ol>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a><strong>事件对象</strong></h3><ol>\n<li><p>window.event适合于IE8及以下 || event</p>\n</li>\n<li><p>事件源对象：event.target || event.srcElement(IE8及以下)</p>\n</li>\n<li><p><strong>只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。</strong></p>\n</li>\n</ol>\n<h3 id=\"事件分类\"><a href=\"#事件分类\" class=\"headerlink\" title=\"事件分类\"></a><strong>事件分类</strong></h3><ol>\n<li><p>鼠标事件：click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout、 mouseenter mouseleave</p>\n</li>\n<li><p>表单事件：submit、reset、change、focus、blur、input、</p>\n</li>\n<li><p>window事件：load、DOMContentLoaded、unload、beforeLoad、scroll、resize</p>\n</li>\n</ol>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"预编译, 递归, 作用域和作用域链","url":"http://yoursite.com/2018/09/25/precompile-/","content":"<h2 id=\"预编译-递归\"><a href=\"#预编译-递归\" class=\"headerlink\" title=\"预编译, 递归\"></a>预编译, 递归</h2><h3 id=\"Js运行机制\"><a href=\"#Js运行机制\" class=\"headerlink\" title=\"Js运行机制\"></a><strong>Js运行机制</strong></h3><ol>\n<li>语法分析 2. 预编译 3. 解析执行</li>\n</ol>\n<h3 id=\"预编译前奏\"><a href=\"#预编译前奏\" class=\"headerlink\" title=\"预编译前奏\"></a><strong>预编译前奏</strong></h3><p>1.暗示全局变量（imply global）：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有</p>\n<ol start=\"2\">\n<li>一切声明的全局变量，全是window的属性（window就是全局的域）</li>\n</ol>\n<h3 id=\"预编译四部曲（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）\"><a href=\"#预编译四部曲（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）\" class=\"headerlink\" title=\"预编译四部曲（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）\"></a><strong>预编译四部曲</strong>（预编译发生在函数执行的前一刻，每个作用于都会进行提升操作）</h3><ol>\n<li><p>创建AO对象（Activity  Object （执行期上下文）），全局的话是生成一个GO对象（Global Object ,   GO === window）</p>\n</li>\n<li><p>找形参和变量声明，将变量和形参名作为AO属性名，值为undefined</p>\n</li>\n<li><p>将实参值和形参统一</p>\n</li>\n<li><p>在函数体里面找函数声明，值赋予函数体</p>\n</li>\n</ol>\n<p>同时也要记住，函数表达式是不会被提升的，还有具名的函数表达式,它的名称标识符是存在函数作用域中的，外接式访问不到的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); // TypeError</span><br><span class=\"line\">bar(); // ReferenceError</span><br><span class=\"line\">var foo = function bar() &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个代码片段经过提升后，实际上会被理解为以下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo;</span><br><span class=\"line\">foo(); // TypeError</span><br><span class=\"line\">bar(); // ReferenceError</span><br><span class=\"line\">foo = function() &#123;</span><br><span class=\"line\">    var bar = ...self...</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：现在的语法是不允许在if和for的{}中定义变量或者函数的（以前好使），但是定义了不会报错，变量可以访问但是值是undefined。预编译的时候也不会看if（）里面的东西<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(test); //undefined</span><br><span class=\"line\">console.log(foo); //报错referenceError</span><br><span class=\"line\">if(function foo()&#123;&#125;)&#123;</span><br><span class=\"line\">    function test()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a><strong>递归</strong></h3><ol>\n<li><p>递归要符合两点：1.找规律（递归的过程），2.递归必须要有出口(递归的中止条件)</p>\n</li>\n<li><p>递归的一点好处就是能是代码变得更加简洁，除此之外没有任何好处，递归特别慢,而且函数递归调用过多超过调用栈的大小，会导致栈溢出</p>\n</li>\n<li><p>递归应用：</p>\n<ul>\n<li><p>递归求n的阶乘</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mul(n)&#123;</span><br><span class=\"line\">    if(n == 1 || n == 0)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return n * mul(n-1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>斐波那契数列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fb(n)&#123;</span><br><span class=\"line\">    if(n == 1 || n == 2)&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return fb(n - 1) + fb(n - 2); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>说到这就说下斐波那契的非递归实现方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fb(n)&#123;</span><br><span class=\"line\">    var n1 = 1,</span><br><span class=\"line\">        n2 = 1,</span><br><span class=\"line\">        n = 1;</span><br><span class=\"line\">    for(var i = 3; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        n = n1 + n2;</span><br><span class=\"line\">        n1 = n2;</span><br><span class=\"line\">        n2 = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"作用域和作用域链\"><a href=\"#作用域和作用域链\" class=\"headerlink\" title=\"作用域和作用域链\"></a><strong>作用域和作用域链</strong></h3><ol>\n<li><p>[[scope]]:每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供javascript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域,其中存储了执行期上下文的集合</p>\n</li>\n<li><p>作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链</p>\n</li>\n<li><p>执行期上下文:当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁</p>\n</li>\n<li><p>查找变量：从作用域链的顶端依次向下查找</p>\n</li>\n</ol>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"BFC、margin塌陷问题","url":"http://yoursite.com/2018/09/20/HTML_Important-/","content":"<h2 id=\"BFC、margin塌陷问题\"><a href=\"#BFC、margin塌陷问题\" class=\"headerlink\" title=\"BFC、margin塌陷问题\"></a><strong>BFC、margin塌陷问题</strong></h2><h3 id=\"块级元素、行级元素\"><a href=\"#块级元素、行级元素\" class=\"headerlink\" title=\"块级元素、行级元素\"></a><strong>块级元素、行级元素</strong></h3><ol>\n<li><p>块级元素：独占一行，可以设置widh，可以设置height</p>\n</li>\n<li><p>行级元素：不可以设置widh，可以设置height，并且在垂直方向的 <strong>margin</strong> 会失效，<strong>padding-top</strong> 会失效</p>\n</li>\n</ol>\n<h2 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a><strong>BFC</strong></h2><ol>\n<li><p>BFC（block ，format，context）叫做块级格式化上下文，可以简单理解为改变语法规则，你可以认为 BFC 在网页中是一个迷你布局。一旦一个元素创建的 BFC ，所有东西都包含在里面了。正如我们所看到的，它包含浮动元素使其不再超出盒子底部。同时 BFC 也产生了一些其他有用的行为。</p>\n</li>\n<li><p>如何 <strong>触发</strong> 一个盒子bfc：</p>\n<ul>\n<li><p>Position : absolute/fixed;  display : inline-block;  float : left/right; display: table-cell 及 display: table-caption    （ <strong>用于父子级，也可以用于兄弟结构之间</strong> ）</p>\n</li>\n<li><p>其中 table-cell 以及 table-captions 是 HTML 元素的默认属性，所以如果有一个 table 数据，那么它的每个格子都将创建 BFC 。 column-span: all 多被使用在多列布局中。 Flex 和 Grid 项目也会创建类似的 BFC ，它们分别被描述为 Flex 格式化上下文和 Grid 格式化上下文，这分别反映了不同的布局类型。 BFC 表示块级布局， FFC 代表 Flex 布局。在实际项目中结果是一样的，都是包含浮动并且外边距不会发生塌陷。</p>\n</li>\n<li><p>overflow : hidden; overflow: auto（ <strong>用于父子级的父级</strong> ）</p>\n</li>\n<li><p>display: flow-root: display: flow-root做的唯一的一件事就是去创建一个BFC，因此可以避免其他创建BFC方法带来的问题 (只兼容部分浏览器)  </p>\n</li>\n<li><p>特点</p>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>- 可以解决margin塌陷问题，但是应该针对着使用，所以叫弥补不叫解决margin塌陷 ，BFC 使元素包含在其中，阻止其外边距塌陷或超出盒模型。\n\n- BFC的一个特点就是可以包含浮动，\n\n- BFC 阻止内容环绕浮动元素， 这是我们创建多列浮动布局常用的方式。浮动一个元素同时也为另一个元素创建了 BFC ，所以当右边的元素比左边高时，创建的列也不再尝试环绕对方。\n</code></pre><h3 id=\"margin塌陷问题\"><a href=\"#margin塌陷问题\" class=\"headerlink\" title=\"margin塌陷问题\"></a><strong>margin塌陷问题</strong></h3><ol>\n<li><p>垂直方向的 margin 父子结构（或 兄弟结构 ）是结合到一起的，他俩会取 <strong>最大</strong> 的那个值</p>\n</li>\n<li><p>折叠的结果为：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的 <strong>相加</strong> 的和。</li>\n</ul>\n</li>\n<li><p>解决的方法有：<br>给他们加 <strong>border/padding</strong>（不专业），还有一种叫 <strong>BFC</strong>（block ，format，context）叫做块级格式化上下文，可以简单理解为改变语法规则</p>\n</li>\n</ol>\n","categories":["html/css"],"tags":["html/css"]},{"title":"浏览器缓存sessionStorage, localStorage, cookie","url":"http://yoursite.com/2018/09/17/Browser_Cache/","content":"<h2 id=\"sessionStorage-localStorage-cookie\"><a href=\"#sessionStorage-localStorage-cookie\" class=\"headerlink\" title=\"sessionStorage, localStorage, cookie\"></a>sessionStorage, localStorage, cookie</h2><p>三个存储的共同点：都存储在浏览器端，都需符合同源策略</p>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a><strong>cookie</strong></h3><ol>\n<li><p>主要用于用户的身份信息存储，cookie的内容会在请求的时候传递给服务器</p>\n</li>\n<li><p>cookie数据还有path路径的概念，可以限制cookie只属于某个路径下</p>\n</li>\n<li><p>cookie可以设置过期时间，当超过时间期限后cookie就会自动消失</p>\n</li>\n<li><p>cookie没有增删改查对应的api，但是我们可以自己封装一个</p>\n</li>\n<li><p>cookie的存储大小在 4KB 左右，很多浏览器都限制一个站点最多保存20个cookie</p>\n</li>\n<li><p>封装的 manageCookie 的方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var manageCookie = &#123;</span><br><span class=\"line\">    setCookie: function (name, age, time) &#123;</span><br><span class=\"line\">        document.cookie = name + &apos;=&apos; + value + &apos;; max-age=&apos; + time;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    removeCookie: function (name) &#123;</span><br><span class=\"line\">        return this.setCookie(name, &apos;&apos;, -1);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getCookie: function (name, callback) &#123;</span><br><span class=\"line\">        var cookieStrArr = document.cookie.split(&apos;; &apos;);</span><br><span class=\"line\">        var len = cookieStrArr.length;</span><br><span class=\"line\">        for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">            var cookieName = cookieStrArr[i].split(&apos;=&apos;)[0];</span><br><span class=\"line\">            if (cookieName == name) &#123;</span><br><span class=\"line\">                callback(cookieStrArr[i].split(&apos;=&apos;)[1]);</span><br><span class=\"line\">                return this;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callback(null);</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a><strong>sessionStorage</strong></h3><ol>\n<li><p>它的生命周期同标签页的生命周期，当当前标签页被关闭，他存储的数据将被销毁</p>\n</li>\n<li><p>sessionStorage的存储大小 5MB 左右</p>\n</li>\n</ol>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a><strong>localStorage</strong></h3><ol>\n<li><p>localStorage存储的数据是永久性的，不主动删除数据，数据永远存在</p>\n</li>\n<li><p>localStorage的存储大小 5MB 左右</p>\n</li>\n<li><p>sessionStorage和localStorage有增删改查的api, 例如setItem、getItem和removeItem等</p>\n<ul>\n<li>setItem存储value, getItem获取value, removeItem删除key, clear清除所有的key/value</li>\n<li>web Storage不但可以用自身的setItem,getItem等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储及读取</li>\n<li>sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历</li>\n<li>storage只能存储字符串的数据，对于数组和对象可以用JSON来转换成字符串</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"本地大容量存储WebSql，IndexDB\"><a href=\"#本地大容量存储WebSql，IndexDB\" class=\"headerlink\" title=\"本地大容量存储WebSql，IndexDB\"></a><strong>本地大容量存储WebSql，IndexDB</strong></h3><ol>\n<li>WebSql: 关系型数据库，被W3C标准废弃</li>\n<li>IndexDB: 非关系型数据库，大小 50MB 左右</li>\n</ol>\n<h3 id=\"浏览器缓存还有-应用缓存，PWA和往返缓存，-在这里就不描述了\"><a href=\"#浏览器缓存还有-应用缓存，PWA和往返缓存，-在这里就不描述了\" class=\"headerlink\" title=\"浏览器缓存还有 应用缓存，PWA和往返缓存， 在这里就不描述了\"></a><strong>浏览器缓存还有 应用缓存，PWA和往返缓存， 在这里就不描述了</strong></h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p><a href=\"https://segmentfault.com/a/1190000015809379#articleHeader6\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000015809379#articleHeader6</a><br><a href=\"http://hjingren.cn/2017/04/26/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8sessionStorage%E4%B8%8ElocalStorage/\" target=\"_blank\" rel=\"noopener\">http://hjingren.cn/2017/04/26/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8sessionStorage%E4%B8%8ElocalStorage/</a></p>\n","categories":["网络"],"tags":["网络"]},{"title":"函数式编程","url":"http://yoursite.com/2018/09/14/Functional_Programming/","content":"<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><ul>\n<li><p>我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式与命令式相比，这样做的好处在哪？主要有以下几点：</p>\n<ul>\n<li>语义更加清晰</li>\n<li>可复用性更高</li>\n<li>可维护性更好</li>\n<li>作用域局限，副作用少<h3 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a><strong>纯函数</strong></h3></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>纯函数是指不依赖，修改其作用域之外变量的函数（不会对外面的变量和函数产生影响的）</p>\n</li>\n<li><p>纯函数非常容易进行单元测试，因为不再需要考虑上下文环境，只需要考虑输入<br>和输出</p>\n</li>\n<li><p>纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行</p>\n</li>\n</ol>\n<h3 id=\"函数记忆函数\"><a href=\"#函数记忆函数\" class=\"headerlink\" title=\"函数记忆函数\"></a><strong>函数记忆函数</strong></h3><ol>\n<li><p>针对的是需要用到之前运算结果的，比如：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache = &#123;&#125;;</span><br><span class=\"line\">function factorial(n) &#123;</span><br><span class=\"line\">    if (cache[n]) &#123;</span><br><span class=\"line\">        return cache[n]</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (n == 1 || n == 0) &#123;</span><br><span class=\"line\">            cache[n] = 1</span><br><span class=\"line\">            return cache[n]</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            cache[n] = n * factorial(n - 1)</span><br><span class=\"line\">            return cache[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>记忆函数的封装：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function memory(fn)&#123;</span><br><span class=\"line\">    var cache = &#123;&#125;;</span><br><span class=\"line\">    return function ()&#123;</span><br><span class=\"line\">        var key = Array.prototype.join.call(arguments);</span><br><span class=\"line\">        if(cache[key])&#123;</span><br><span class=\"line\">            return cache[key];</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            cache[key] = fn.apply(this, arguments);</span><br><span class=\"line\">            return cache[key]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a><strong>柯里化</strong></h3><ol>\n<li><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>\n</li>\n<li><p>前端使用柯理化的用途主要就应该是简化代码结构，提高系统的维护性，一个方法，只有一个参数，强制了功能的单一性，很自然就做到了功能内聚，降低耦合。</p>\n</li>\n<li><p>柯理化的优点就是降低代码的重复，提高代码的适应性</p>\n</li>\n<li><p><strong>调用形式</strong>：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(a,b,c)&#123;&#125; ; </span><br><span class=\"line\">var newAdd = Curry(add);</span><br><span class=\"line\">newAdd(1)(2)(3)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>柯里化函数的 <strong>封装实现</strong>：</p>\n<ul>\n<li><p>柯里化前奏-需要固定数量参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(a, b, c, d)&#123;</span><br><span class=\"line\">    return a + b + c + d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function FixedParamCurry(fn)&#123;</span><br><span class=\"line\">    var _arg = Array.prototype.slice.call(arguments,1);</span><br><span class=\"line\">    return function ()&#123;</span><br><span class=\"line\">        var newArg = _arg.concat(Array.prototype.slice.call(arguments,0));</span><br><span class=\"line\">        return fn.apply(this, newArg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var newAdd = FixedParamCurry(add, 1, 2);</span><br><span class=\"line\">console.log(newAdd(2, 3))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现柯里化-期待固定数量参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Curry(fn, length)&#123;</span><br><span class=\"line\">    var length = length || fn.length;</span><br><span class=\"line\">    return function ()&#123;</span><br><span class=\"line\">        if(arguments.length &lt; length)&#123;</span><br><span class=\"line\">            var combined = [fn].concat(Array.prototype.slice.call(arguments, 0));</span><br><span class=\"line\">            return Curry(FixedParamCurry.apply(this, combined), length - arguments.length);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return fn.apply(this, arguments)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>应用柯里化：比如在ajax中对于同一个地址参数不同的post的请求，就可以使用柯里化，<strong>流程剖析</strong>：</p>\n<p><img src=\"/images/blog_images/Ajax_Curry.png\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"惰性函数\"><a href=\"#惰性函数\" class=\"headerlink\" title=\"惰性函数\"></a><strong>惰性函数</strong></h3><ol>\n<li><p>针对于优化频繁使用的函数</p>\n</li>\n<li><p>常用于，函数库的编写，单例模式之中</p>\n</li>\n<li><p>写一个 test 函数，这个函数返回首次调用时的 new Date().getTime()时间，注意是首次。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test = function ()&#123;</span><br><span class=\"line\">    var t;</span><br><span class=\"line\">    t = new Date().getTime();</span><br><span class=\"line\">    test = function ()&#123;</span><br><span class=\"line\">        return t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return test()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>惰性函数应用：事件函数的封装 、 滚动条偏移量函数的封装 、 jQuery函数库的封装</p>\n</li>\n</ol>\n<h3 id=\"函数组合应用\"><a href=\"#函数组合应用\" class=\"headerlink\" title=\"函数组合应用\"></a><strong>函数组合应用</strong></h3><ol>\n<li><p>函数的组合应用（自右向左，自内向外依次执行），是一种高阶函数的思想</p>\n</li>\n<li><p>封装实现：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compose()&#123;</span><br><span class=\"line\">    var args = Array.prototype.slice.call(arguments);</span><br><span class=\"line\">    var len = args.length - 1;</span><br><span class=\"line\">    return function (x)&#123;</span><br><span class=\"line\">        var result = args[len](x);</span><br><span class=\"line\">        while(len --)&#123;</span><br><span class=\"line\">            result = args[len](result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 数组reduceRight的实现方法：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compose()&#123;</span><br><span class=\"line\">    var args = Array.prototype.slice.call(arguments);</span><br><span class=\"line\">    return function (x)&#123;</span><br><span class=\"line\">        return args.reduceRight(function (res, cb)&#123;</span><br><span class=\"line\">            return cb(res);</span><br><span class=\"line\">        &#125;, x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">es6写法</span><br><span class=\"line\"></span><br><span class=\"line\">const compose = (...args) =&gt; x =&gt; args.reduceRight((res, cb) =&gt; cb(res), x)</span><br></pre></td></tr></table></figure>\n<p> 从左向右依次执行的实现方法：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compose()&#123;</span><br><span class=\"line\">    var args = Array.prototype.slice.call(arguments);</span><br><span class=\"line\">    return function (x)&#123;</span><br><span class=\"line\">        return args.reduce(function (res, cb)&#123;</span><br><span class=\"line\">            return cb(res);</span><br><span class=\"line\">        &#125;, x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Js必会数据处理之扁平化\"><a href=\"#Js必会数据处理之扁平化\" class=\"headerlink\" title=\"Js必会数据处理之扁平化\"></a><strong>Js必会数据处理之扁平化</strong></h3><ol>\n<li><p>可以用在后台给出的数据来进行处理<br>主要用在两大方面一个是 <strong>数组</strong>（是一个降维，多维数组通过扁平化变为一维数组），一个是 <strong>对象</strong>（深度很深的对象经过扁平化编程深度为1的对象）</p>\n</li>\n<li><p>函数封装的实现</p>\n<ul>\n<li><p><strong>方法1</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.flatter = function ()&#123;</span><br><span class=\"line\">    var resArr = [];</span><br><span class=\"line\">    this.forEach(function (item)&#123;</span><br><span class=\"line\">        Object.prototype.toString.call(item) == &apos;[object Array]&apos; ? resArr = resArr.concat(this.flatter()) : resArr.push(item)</span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">    return resArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>方法2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.flatter = function ()&#123;</span><br><span class=\"line\">    return this.reduce(function (prev, item)&#123;</span><br><span class=\"line\">        return Object.prototype.toString.call(item) == &apos;[object Array]&apos; ? prev.concat(item.flatter()) : prev.push(item);</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a><strong>高阶函数</strong></h3><ol>\n<li>接受或者返回一个函数的函数称为高阶函数</li>\n</ol>\n","categories":["函数式编程"],"tags":["函数式编程"]},{"title":"再读JavaScript权威指南（词法结构、类型、值、变量）","url":"http://yoursite.com/2018/09/13/JavaScript_Authoritative_Guide2_3/","content":"<h2 id=\"JavaScript-权威指南（第二章词法结构）\"><a href=\"#JavaScript-权威指南（第二章词法结构）\" class=\"headerlink\" title=\"JavaScript 权威指南（第二章词法结构）\"></a>JavaScript 权威指南（第二章词法结构）</h2><h3 id=\"JavaScript结尾分号的问题\"><a href=\"#JavaScript结尾分号的问题\" class=\"headerlink\" title=\"JavaScript结尾分号的问题\"></a><strong>JavaScript结尾分号的问题</strong></h3><ol>\n<li><p>JavaScript 并不会在所有的换行处填补分号，只有在缺少分号就无法正确解析的时候，JavaScript 才会填补分号。换句话讲如果 <strong>当前语句</strong> 和 <strong>随后的的非空格字符</strong> 不能当一个整体来解析的话，JavaScript 就会在当前语句行的结束处填补分号。</p>\n</li>\n<li><p>有两个例外</p>\n<ul>\n<li><p>第一个例外是在涉及 <strong>return</strong>、<strong>break</strong> 和 <strong>continue</strong> 语句的场景中。如果这三个关键词后紧跟着换行，JavaScript则会在换行处填补分号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return</span><br><span class=\"line\">true;</span><br><span class=\"line\"></span><br><span class=\"line\">//JavaScript会解析成：</span><br><span class=\"line\"> </span><br><span class=\"line\"> return; true;</span><br><span class=\"line\"></span><br><span class=\"line\">//  而代码的本意是这样：</span><br><span class=\"line\"></span><br><span class=\"line\">return true;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个例外是在涉及 <strong>++</strong>、<strong>–</strong> 运算符的时候，这些运算符可以作为表达式的前缀，也可作为表达式的后缀。如果做后缀，他和表达式应该在同一行，否则行尾将增加分号，同时 ++、– 将作为下一行代码的前缀操作符并与其一起解析，<strong>例如</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x</span><br><span class=\"line\">++</span><br><span class=\"line\">y</span><br><span class=\"line\"></span><br><span class=\"line\">//这段代码的解析为 “ x; ++y;” ,而不是 “ x++; y”</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JavaScript-权威指南（第三章类型，值，变量）\"><a href=\"#JavaScript-权威指南（第三章类型，值，变量）\" class=\"headerlink\" title=\"JavaScript 权威指南（第三章类型，值，变量）\"></a>JavaScript 权威指南（第三章类型，值，变量）</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a><strong>数据类型</strong></h3><ol>\n<li><p>能够表示并操作的值的类型称做 <strong>数据类型</strong> ，变量是一个值的符号名称，可以通过名称来获得对值的引用</p>\n</li>\n<li><p>javaScript数据类型分为两类：<strong>原始类型</strong> 和 <strong>对象类型</strong> ，也可分为 <strong>可变类型</strong> 和 <strong>不可变类型</strong> ，null和undefined是两个特殊的原始值（是无法拥有方法的值），函数和数组是特殊的对象</p>\n<ul>\n<li>原始类型/不可变类型：数字，字符串，布尔值，null，undefined</li>\n<li>对象类型/可变类型：对象</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a><strong>字符串类型</strong></h3><ol>\n<li><p>在 <strong>es5</strong> 中字符串的直接量可以拆分成数行，每行必须以反斜线（\\）结束</p>\n</li>\n<li><p><strong>JavaScript转义字符表</strong>：</p>\n<p> <img src=\"/images/blog_images/Escape_Character1.png\" alt=\"image\"><br> <img src=\"/images/blog_images/Escape_Character2.png\" alt=\"image\"></p>\n</li>\n<li><p><strong>字符串方法</strong>：</p>\n<p> <img src=\"/images/blog_images/String_Methods.png\" alt=\"image\"><br> <img src=\"/images/blog_images/String_Methods2.png\" alt=\"image\"></p>\n<ul>\n<li>在JavaScript中字符串是固定不变的，类似replace()和toUpperCase()的方法都返回新字符串，原字符串本身并没有变化</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数字类型\"><a href=\"#数字类型\" class=\"headerlink\" title=\"数字类型\"></a><strong>数字类型</strong></h3><ol>\n<li><p>JavaScript支持 <strong>十进制</strong> ，<strong>十六进制</strong> ，对于八进制是有些支持，有些不支持，但在es6的严格模式下，八进制是禁止的</p>\n</li>\n<li><p>可以使用 <strong>指数计数法</strong> 来表示浮点型直接量，即在实数后面跟字母e或E，后面再跟<br>正负号，其后再加一个整型的整数</p>\n</li>\n<li><p>JavaScript的算术运算在溢出、下溢或被0整除时不报错，<strong>0/0 = NaN</strong>， <strong>Infinity/Infinity = NaN</strong>，Infinity和NaN在es3中可读写，在es5中只可读，在es3中 <strong>Number</strong> 的属性值也是只读的,</p>\n</li>\n<li>判断 <strong>NaN</strong> 和 <strong>infinity</strong> 的有两个函数：isNaN() 和 isInfinite()</li>\n<li><p>关于 <strong>二进制浮点数精度不准</strong> 的解释：</p>\n<ul>\n<li>JavaScript采用了 <strong>IEEE-754</strong> 浮点数表示法（几乎现代所有编程语言所采用），这是一种<strong>二进制表示法</strong>，可以精确地表示分数，比如 1/2、1/81 和 /1024。遗憾的是，我们常用的分数（特别是在金融计算方面的）都是 <strong>十进制分数</strong> 1/10、1/100等。<strong>二进制浮点数</strong> 表示法不能够精确表示类似0.1这样简单的数字。</li>\n<li>JavaScript中的数字具有足够的精度，并可以及其近似 <strong>0.1</strong>。但事实是，数字不能精确</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Math对象的属性\"><a href=\"#Math对象的属性\" class=\"headerlink\" title=\"Math对象的属性\"></a><strong>Math对象的属性</strong></h3><p><img src=\"/images/blog_images/Math_Methods.png\" alt=\"image\"></p>\n<h3 id=\"日期与时间函数Date-简单的教程\"><a href=\"#日期与时间函数Date-简单的教程\" class=\"headerlink\" title=\"日期与时间函数Date()简单的教程\"></a><strong>日期与时间函数Date()简单的教程</strong></h3><p><img src=\"/images/blog_images/Date_Methods.png\" alt=\"image\"></p>\n<h3 id=\"RegExp\"><a href=\"#RegExp\" class=\"headerlink\" title=\"RegExp\"></a><strong>RegExp</strong></h3><ol>\n<li><p>RegExp对象定义了很多很有用的方法，字符串同样可以具有接收RegExp参数的方法，<strong>例如</strong>：</p>\n<p> <img src=\"/images/blog_images/RegExp.png\" alt=\"image\"></p>\n</li>\n</ol>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a><strong>Boolean</strong></h3><ol>\n<li><p>下面这些值会被转化成 <strong>false</strong>:                       <strong>undefined</strong>、<strong>null</strong>、<strong>0</strong>、<strong>-0</strong>、<strong>NaN</strong>、<strong>“”</strong></p>\n</li>\n<li><p>Boolean原型上有 <strong>toString()</strong> 方法(除了这个，还有一个方法是 <strong>valueOf()</strong>，再没有别的方法了)，可以使用这个方法将布尔值转换为字符串 <strong>“true”</strong> 或 <strong>“false”</strong></p>\n</li>\n<li><p>三个重要的布尔运算符：<strong>&amp;&amp;</strong> 、<strong>||</strong> 、<strong>!</strong></p>\n</li>\n</ol>\n<h3 id=\"null-和-undefined\"><a href=\"#null-和-undefined\" class=\"headerlink\" title=\"null 和 undefined\"></a><strong>null 和 undefined</strong></h3><ol>\n<li><p>null是JavaScript的 <strong>关键字</strong>，他表示一个特殊值，常用来描述 <strong>空值</strong>, <strong>typeof null 等于 “object”</strong>, 但他实际上不是一个对象， 通常认为 <strong>null</strong> 是它自有类型的唯一一个成员</p>\n</li>\n<li><p>undefined是预定义的 <strong>全局变量</strong>（他和null不一样，他不是关键字），它的值就是 <strong>“未定义”</strong>，在es3中undefined是 <strong>可读/写</strong> 的变量，可以给他赋任意值，但在es5中undefinde <strong>只读</strong>，使用typeof运算符得到的是 “undefined” ，是undefined类型 undefined使这个类型的唯一成员</p>\n</li>\n<li><p>null 和 undefined 相等于（====），但不严格等于（=====）</p>\n</li>\n<li><p>null 和 undefined 都不包括任何的 <strong>属性</strong> 和 <strong>方法</strong>，使用 “.” 和 [] 来存取这两个值的成员和方法都会产生一个类型错误</p>\n</li>\n<li><p>如果你想将他们赋值给 <strong>变量</strong> 或者 <strong>属性</strong>，或将他们作为 <strong>参数</strong> 传入函数，最佳的选择是使用 <strong>null</strong></p>\n</li>\n</ol>\n<h3 id=\"全局对象-、包装对象、值的比较\"><a href=\"#全局对象-、包装对象、值的比较\" class=\"headerlink\" title=\"全局对象 、包装对象、值的比较\"></a><strong>全局对象 、包装对象、值的比较</strong></h3><ol>\n<li><p>当JavaScript解析器启动时（或者任何一个Web浏览器家在新页面的时候），它将创建一个新的全局对象，并给他一组定义的初始属性：全局属性、全局对象、全局函数、构造函数</p>\n</li>\n<li><p>包装对象注意的两点：</p>\n<ul>\n<li><p>当一个字符串引用是一属性时，会被JavaScript将字符串通过new String()的方式转换成 <strong>临时对象</strong>，一旦引用结束，这个临时对象就会销毁</p>\n</li>\n<li><p>JavaScript会在必要时将包装对象转换成原始值（但不总是）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;xixi&apos;;</span><br><span class=\"line\">var str1 = new String(str);</span><br><span class=\"line\">console.log(str == str1)    //true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>原始值的比较是 <strong>值</strong> 的比较，对象的比较是 <strong>引用</strong> 的比较</p>\n</li>\n</ol>\n<h3 id=\"字符串到对象的转换：toSting-valueOf\"><a href=\"#字符串到对象的转换：toSting-valueOf\" class=\"headerlink\" title=\"字符串到对象的转换：toSting(), valueOf()\"></a><strong>字符串到对象的转换：toSting(), valueOf()</strong></h3><ol>\n<li><p>以下数组类、函数类、日期类、RegExp类的 <strong>toString()</strong> 方法</p>\n<p> <img src=\"/images/blog_images/Different_ToString.png\" alt=\"image\"></p>\n</li>\n<li><p><strong>valueof()</strong>:</p>\n<p> 调用valueOf()函数时，如果对象存在任意的原始值（比如包装类对象），他就默认将对象转化为表示他的原始值，大对数的对象无法真正表示一个原始值，因此默认的valueOf()方法返回对象本身（如： 数组、函数、正则表达式），日期类定义的返回它的一个内部表示：1970年1月1日依赖的毫秒数</p>\n</li>\n<li><p>JavaScript从 <strong>对象到字符串的转换</strong> 经过以下步骤：</p>\n<ul>\n<li>如果对象具有toString()方法的话，则调用这个方法，如果返回的一个原始值，JavaScript会将它转化为字符串（如果本身不是字符串的话），并返回这个字符串结果</li>\n<li>如果没有toString()方法，或者这个方法返回一个原始值，JavaScript就会调用valueOf()方法（前提是存在）如果返回的一个原始值，JavaScript会将它转化为字符串（如果本身不是字符串的话）</li>\n<li>对象转换成数字的过程，JavaScript做了同样的事情，只是他首先会尝试valueOf()方法</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a><strong>变量</strong></h3><ol>\n<li><p>编程语言分为 <strong>动态类型语言</strong> 和 <strong>静态类型</strong> 语言</p>\n<ul>\n<li>动态类型语言：是指在运行期间才去做数据类型的检查的语言，如JavaScript、Python、Ruby</li>\n<li>静态编程语言：是指数据类型在编译期间检查的，如C/C++、C#、Java</li>\n</ul>\n</li>\n<li><p>当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除，在非严格模式下，未声明的变量会变成全局变量，这个变量是可以配置的，可以删除他们</p>\n</li>\n</ol>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a><strong>作用域链</strong></h3><ol>\n<li><p>作用域链是一对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript查找变量的时候x时候，如果当前对象有x的值，则使用这个值，如果没有则从当前对象依次向上查找</p>\n</li>\n<li><p>当定义一个函数时，它实际上保存着一个作用域链，当调用这个函数式，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的作用域链上，同时创建一个新的更长的表示函数调用作用域的链</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p>《JavaScript权威指南》第六版  David Flanagan 著</p>\n","categories":["JavaScript权威指南"],"tags":["JavaScript权威指南"]},{"title":"数据结构（树）","url":"http://yoursite.com/2018/09/12/Data_Structure/","content":"<h2 id=\"数据结构（树）\"><a href=\"#数据结构（树）\" class=\"headerlink\" title=\"数据结构（树）\"></a>数据结构（树）</h2><h3 id=\"树（二叉树）\"><a href=\"#树（二叉树）\" class=\"headerlink\" title=\"树（二叉树）\"></a><strong>树（二叉树）</strong></h3><ol>\n<li><p><strong>树</strong> 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合</p>\n</li>\n<li><p>树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有 <strong>N</strong> 个节点和 <strong>N-1</strong> 条边的一个有向无环图</p>\n</li>\n<li><p><strong>二叉树</strong> 是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“ <strong>左子树</strong> ”和“ <strong>右子树</strong> ”。</p>\n<ul>\n<li><p>完全二叉树：除了最后一层，所有层的节点数达到最大，与此同时，最后一层的所有节点都在最左侧</p>\n</li>\n<li><p>满二叉树：所有层的节点数达到最大</p>\n</li>\n<li><p>平衡二叉树：每一个节点的左右子树的高度差不超过1</p>\n</li>\n</ul>\n</li>\n<li><p>本章目标：</p>\n<ul>\n<li>理解和区分树的遍历方法</li>\n<li>能够运用 <strong>递归</strong> 方法解决树的为前序遍历、中序遍历和后序遍历问题</li>\n<li>能用运用 <strong>迭代</strong> 方法解决树的为前序遍历、中序遍历和后序遍历问题</li>\n<li>能用运用 <strong>广度优先</strong> 搜索解决树的层序遍历问题 </li>\n</ul>\n</li>\n<li><p>二叉树的结构图</p>\n<p> <img src=\"/images/blog_images/Two_forked_tree.png\" alt=\"image\"></p>\n<ul>\n<li>这幅图中有如下概念：<ul>\n<li>根节点：一棵树最顶部的节点</li>\n<li>内部节点：在它上面还有其它内部节点或者叶节点的节点</li>\n<li>叶节点：处于一棵树根部的节点</li>\n<li>子树：由树中的内部节点和叶节点组成</li>\n</ul>\n</li>\n<li>它也是二叉搜索树（左侧子节点的数字小于父节点，右侧子节点的数字大于父节点）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"二叉树的实现-介绍\"><a href=\"#二叉树的实现-介绍\" class=\"headerlink\" title=\"二叉树的实现 - 介绍\"></a><strong>二叉树的实现 - 介绍</strong></h3><ol>\n<li><p>二叉树的表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function BinarySearchTree() &#123;</span><br><span class=\"line\">    var Node = function (key) &#123;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">        this.left = null;</span><br><span class=\"line\">        this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var root = null;</span><br><span class=\"line\">    var size = 0;</span><br><span class=\"line\">    this.insert = function (key) &#123;      //插入元素</span><br><span class=\"line\">        root = add(root, node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.getNode = function () &#123;        //打印二叉搜索树</span><br><span class=\"line\">        return root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.contain = function (key) &#123;     //查看是否存在元素</span><br><span class=\"line\">        search(root, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.preOrderTraverse = function () &#123;       //前序遍历</span><br><span class=\"line\">        preOrderTraverse(root);                 </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    this.inOrderTraverse = function () &#123;        //中序遍历</span><br><span class=\"line\">        inOrderTraverse(root);                 </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    this.postOrderTraverse = function () &#123;      //后续遍历  可以应用在释放内存 </span><br><span class=\"line\">        postOrderTraverse(root);                 </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    this.levelOrder = function()&#123;       //层序遍历</span><br><span class=\"line\">        levelOrder(root)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.min = function()&#123;      //返回最小值</span><br><span class=\"line\">        if(root)&#123;</span><br><span class=\"line\">            var node = root;</span><br><span class=\"line\">            while(node.left)&#123;</span><br><span class=\"line\">                node = node.left</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.max = function()&#123;      //返回最大值</span><br><span class=\"line\">        if(root)&#123;</span><br><span class=\"line\">            var node = root;</span><br><span class=\"line\">            while(node.right)&#123;</span><br><span class=\"line\">                node = node.right</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.removeMin = function()&#123;      //删除最小值</span><br><span class=\"line\">        removeMin(root);</span><br><span class=\"line\">        return this.min();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function removeMin(node)&#123;</span><br><span class=\"line\">        if(node)&#123;</span><br><span class=\"line\">            if(node.left == null)&#123;</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">                node.right = null;</span><br><span class=\"line\">                return node.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node.left = removeMin(node.left);</span><br><span class=\"line\">            return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.removeMax = function()&#123;      //删除最大值</span><br><span class=\"line\">        removeMax(root);</span><br><span class=\"line\">        return this.max(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function removeMax(node)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>插入元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(root, node) &#123;</span><br><span class=\"line\">    if (!root) &#123;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        return new Node(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (node.key &lt; root.key) &#123;</span><br><span class=\"line\">        root.left = add(root.left, node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (node.key &gt; root.key) &#123;</span><br><span class=\"line\">        root.right = add(root.right, node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>搜索元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function search(node, key) &#123;</span><br><span class=\"line\">    if (!root) return false;</span><br><span class=\"line\">    if (root.key === key) return true;</span><br><span class=\"line\">    if (root.key &gt; key) return search(root.left, key);</span><br><span class=\"line\">    if (root.key &lt; key) return search(root.right, key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前序遍历： 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p>\n<p> <strong>递归：</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function preOrderTraverse(node, arr = [])&#123;</span><br><span class=\"line\">    if(node)&#123;</span><br><span class=\"line\">        arr.push(node.key);</span><br><span class=\"line\">        preOrderTraverse(node.left, arr);</span><br><span class=\"line\">        preOrderTraverse(node.right, arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <strong>非递归方法(利用栈)，比递归实现复杂，中序遍历和后续遍历的非递归实现更复杂，实际应用也不广</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.preOrderTraverseNR = function () &#123;</span><br><span class=\"line\">    var stack = [];</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    while(stack.length)&#123;</span><br><span class=\"line\">        var node = stack.pop()</span><br><span class=\"line\">        result.push(node);</span><br><span class=\"line\">        if(node.right)&#123;</span><br><span class=\"line\">            stack.push(node.right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.left)&#123;&#125;</span><br><span class=\"line\">            stack.push(node.left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>中序遍历： 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。（通常来说，对于<strong>二叉搜索树</strong>，我们可以通过中序遍历得到一个递增的有序序列）</p>\n<p> <strong>递归：</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function inOrderTraverse(node, arr = [])&#123;</span><br><span class=\"line\">    if(node)&#123;</span><br><span class=\"line\">        inOrderTraverse(node.left, arr);</span><br><span class=\"line\">        arr.push(node.key);</span><br><span class=\"line\">        inOrderTraverse(node.right, arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>后序遍历： 后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。（值得注意的是，当你<strong>删除树中的节点</strong>时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。）</p>\n<p> <strong>递归：</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function postOrderTraverse(node, arr = [])&#123;</span><br><span class=\"line\">    if(node)&#123;</span><br><span class=\"line\">        postOrderTraverse(node.left, arr);</span><br><span class=\"line\">        postOrderTraverse(node.right, arr);</span><br><span class=\"line\">        arr.push(node.key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>层序遍历（递归）</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">/ \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @return &#123;number[][]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var levelOrder = function(node, index = 0, stack = []) &#123;</span><br><span class=\"line\">    if(node)&#123;</span><br><span class=\"line\">        if(!stack[index])&#123;</span><br><span class=\"line\">           stack[index] = []; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        stack[index].push(node.val);</span><br><span class=\"line\">        levelOrder(node.left, index + 1, stack);</span><br><span class=\"line\">        levelOrder(node.right, index + 1, stack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return stack;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外，后序在数学表达中被广泛使用。 编写程序来 <strong>解析后缀表示法</strong> 更为容易。 这里是一个例子：</p>\n<p> <img src=\"/images/blog_images/mathematical_expression.png\" alt=\"image\"></p>\n<p> 您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。</p>\n<p> 如果你想对这棵树进行后序遍历，使用 <strong>栈</strong> 来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p>\n</li>\n</ol>\n<h3 id=\"层序遍历-介绍\"><a href=\"#层序遍历-介绍\" class=\"headerlink\" title=\"层序遍历 - 介绍\"></a><strong>层序遍历 - 介绍</strong></h3><ol>\n<li><p>层序遍历就是逐层遍历树结构。</p>\n</li>\n<li><p><strong>广度优先搜索</strong> 是一种广泛运用在 <strong>树</strong> 或 <strong>图</strong> 这类数据结构中， <strong>遍历</strong> 或 <strong>搜索</strong> 的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。</p>\n</li>\n<li><p>当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。</p>\n</li>\n<li><p>通常，我们使用一个叫做 <strong>队列</strong> 的数据结构来帮助我们做广度优先搜索</p>\n</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p><a href=\"https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/</a></p>\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"读JavaScript权威指南（函数）","url":"http://yoursite.com/2018/09/11/JavaScript_Authoritative_Guide8/","content":"<h2 id=\"JavaScript-权威指南（第八章函数）\"><a href=\"#JavaScript-权威指南（第八章函数）\" class=\"headerlink\" title=\"JavaScript 权威指南（第八章函数）\"></a>JavaScript 权威指南（第八章函数）</h2><h3 id=\"顶级语句：函数声明\"><a href=\"#顶级语句：函数声明\" class=\"headerlink\" title=\"顶级语句：函数声明\"></a><strong>顶级语句：函数声明</strong></h3><ol>\n<li><p>美元符号和下划线是除了字母和数字以外的两个合法的javaScript标识符</p>\n</li>\n<li><p>函数声明语句并非真正的语句，ECMAScript规范只是允许它们作为顶级域名。它们可以出现在全局代码里，或者内嵌在其他的函数中，但是他们不能够出现在<strong>循环、条件判断、或者try/cache/finnally/以及width</strong>语句中。注意，此限制仅用于语句声明的形式定义的函数。<strong>函数定义表达式可以出现在javaScript代码的任何地方</strong></p>\n</li>\n<li><p><strong>*补充：</strong></p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(a) &#123;</span><br><span class=\"line\">    var b = 123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">c</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//虽然不允许在<span class=\"keyword\">if</span>定义函数声明，但是现代的浏览器不报错，</span><br><span class=\"line\">//而且在预编译过程中，c为undefined（老版本的IE可以存在c预编译为<span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">c</span></span>()&#123;&#125;）</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数表达式本身就是一个属性访问表达式\"><a href=\"#函数表达式本身就是一个属性访问表达式\" class=\"headerlink\" title=\"函数表达式本身就是一个属性访问表达式\"></a><strong>函数表达式本身就是一个属性访问表达式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o.m(x, y)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>上面的代码是一个调用的表达式，它包括一个函数表达式o.m，以及两个是实参表达式x和y，函数表达式本身就是一个<strong>属性访问表达式</strong>，这意味着该函数被当做一个<strong>方法</strong>，而不是作为一个普通函数来调用。</li>\n</ol>\n<h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a><strong>arguments</strong></h3><ol start=\"2\">\n<li><p>arguments数组对象的数组元素是函数形参所对应实参额别名，实参对象一数字为索引，并且形参名称可以认为是相同变量的不同命名。即两个的值是互通的，<strong>只要这其中一个改变那么另外一个就跟着改变</strong>，但是在es5的严格模式中这一特性就不存在了，而且在非严格模式中函数中的arguments是一个<strong>标识符</strong>，而在严格模式中它变成了一个<strong>保留字</strong>，严格模式中函数无法使用arguments作为形参或局部变量，也不能够给arguments赋值</p>\n</li>\n<li><p>arguments并不是一个<strong>关键字</strong>，但在调用每个函数时都会自动声明它</p>\n</li>\n<li><p><strong>*补充：</strong></p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"use strict\"</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"built_in\">test</span>(a)&#123;</span><br><span class=\"line\">    arguments[0] = 2;</span><br><span class=\"line\">    console.log(a);//1,如果没有严格模式这里的输出是2</span><br><span class=\"line\">    console.log(arguments[0])//2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">test</span>(1);</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-7-函数属性、方法、构造函数\"><a href=\"#8-7-函数属性、方法、构造函数\" class=\"headerlink\" title=\"8.7 函数属性、方法、构造函数\"></a><strong>8.7 函数属性、方法、构造函数</strong></h3><ol>\n<li><p>一个名为test函数，<strong>test.length</strong>和函数呢内<strong>argument.callee.length</strong>指的是函数形参的个数，<strong>argument.length</strong>指的是实参的个数</p>\n</li>\n<li><p>Call和apply的区别是传参形式不同，call是第一个参数之后的参数就是执行函数传入的实参，而apply的的第二个参数传入的<strong>真实数组</strong>或者<strong>类数组对象</strong>，对象里面的元素就是函数执行传入的实参</p>\n</li>\n<li><p>Call和apply的使用相当于如下代码，根据此可以封装一个call和apply</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.call(o);</span><br><span class=\"line\">f.apply(o);</span><br><span class=\"line\"></span><br><span class=\"line\">//每行的代码和下面代码的功能类似（假设对象中预先不存在名为m的属性）</span><br><span class=\"line\"></span><br><span class=\"line\">o.m = f;    //将m存储为临时的方法</span><br><span class=\"line\">o.m();      //调用它不传入参数</span><br><span class=\"line\">delete o.m; //将临时方法删除</span><br></pre></td></tr></table></figure>\n<p><strong>*call的封装实现</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newCall = function () &#123;</span><br><span class=\"line\">            var ctx = arguments[0] || window;</span><br><span class=\"line\">            ctx.fn = this;</span><br><span class=\"line\">            var args = [];</span><br><span class=\"line\">            for (var i = 1; i &lt;= arguments.length; i++) &#123;</span><br><span class=\"line\">                args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class=\"line\">            delete ctx.fn;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>*apply的封装实现：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newApply = function (ctx, arr) &#123;</span><br><span class=\"line\">    var ctx = ctx || window;</span><br><span class=\"line\">    ctx.fn = this;</span><br><span class=\"line\">    var args = [];</span><br><span class=\"line\">    if (arr) &#123;</span><br><span class=\"line\">        console.log(&apos;haha&apos;)</span><br><span class=\"line\">        for (var i = 0; i &lt;= arr.length; i++) &#123;</span><br><span class=\"line\">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var result = eval(&apos;ctx.fn(&apos; + args.join() + &apos;)&apos;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        var result = ctx.fn();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete ctx.fn;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>在ECMAScript 5的严格模式中，<strong>call和apply的第一个实参都会变成this的值</strong>，哪怕传入的实参是原始值甚至是undefined和null。在es3和非严格模式中，<strong>传入的null和undefined都会被全局所代替</strong>，而其他原始值则会被相应的包装对象（wrapper bject）所代替</p>\n</li>\n<li><p>bind是es5新增的方法</p>\n</li>\n</ol>\n<p>bind的封装实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newBind = function (target) &#123;</span><br><span class=\"line\">    target = target || window;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    var arg = [].slice.call(arguments, 1);</span><br><span class=\"line\">    var Temp = function () &#123; &#125;;</span><br><span class=\"line\">    var F = function () &#123;</span><br><span class=\"line\">        var _arg = [].slice.call(arguments, 0);</span><br><span class=\"line\">        return self.apply(this instanceof Temp ? this : target, arg.concat(_arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Temp.prototype = this.prototype;</span><br><span class=\"line\">    F.prototype = new Temp(); //将F函数的的原型跟调用newBind 函数的原型一样（就是将函数F变得跟调用newBind 的函数一样）</span><br><span class=\"line\"></span><br><span class=\"line\">    return F;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>和所有的javaScript对象一样，函数也有toString()方法，ECMAScript规范规定这个方法返回一个字符串，这字符串和函数声明语句的的语法相关。实际上，大多数（非全部）的toString()方法实现都返回函数的完整源码。<strong>内置函数往往返回一个类似”[native code]”的字符串作为函数体</strong></li>\n</ol>\n<p>*如下(使用的是浏览器自带的开发者工具)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; function test()&#123;var c = &apos;i&apos;&#125;</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; test.toString()</span><br><span class=\"line\">&quot;function test()&#123;var c = &apos;i&apos;&#125;&quot;</span><br><span class=\"line\">&gt; Object.toString()</span><br><span class=\"line\">&quot;function Object() &#123; [native code] &#125;&quot;</span><br><span class=\"line\">&gt; Date.toString()</span><br><span class=\"line\">&quot;function Date() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>不管是通过函数定义的语句还是函数直接量的表达式，函数的定义都要使用function关键字。但是函数还可以<strong>通过Function()构造函数来定义</strong>，比如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//这行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价</span><br><span class=\"line\"></span><br><span class=\"line\">var f = function (x,y)&#123; return x*y; &#125;</span><br></pre></td></tr></table></figure>\n<p>注意：Function()构造函数并不需要通过传入实参以指定函数名。就想函数直接量一样，Function()构造函数创建一个匿名函数。还有用Function()构造函数创建的函数并不是使用<strong>词法作用域</strong>，相反，函数体代码的编译总是会到顶部函数执行。</p>\n<p>我们可以将Function()构造函数认为是在全局作用域中执行的eval(),eval()可以在自己的私有作用域内定义新变量和函数，Function()构造函数在实际编程中很少会用到。</p>\n<h3 id=\"8-8-函数式编程\"><a href=\"#8-8-函数式编程\" class=\"headerlink\" title=\"8.8 函数式编程\"></a><strong>8.8 函数式编程</strong></h3><ol>\n<li><p>使用函数处理数组</p>\n</li>\n<li><p>高阶函数：所谓的高阶函数就是操作函数的函数，它接受一个或多个函数作为参数，并返回一个新函数</p>\n</li>\n<li><p>不完全函数：那一次完整的函数调用拆成对此函数调用，每次传入的参数都是完整参数的一部分，每一个拆分出的函数叫做不完全函数，每次函数调用叫做不完全调用，被称为柯里化</p>\n</li>\n<li><p>记忆：记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度换取更优的时间复杂度</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p>《JavaScript权威指南》第六版  David Flanagan 著</p>\n","categories":["JavaScript权威指南"],"tags":["JavaScript权威指南"]},{"title":"从Event Loop谈JS的运行机制","url":"http://yoursite.com/2018/09/10/Event-Loop/","content":"<h2 id=\"从Event-Loop谈JS的运行机制\"><a href=\"#从Event-Loop谈JS的运行机制\" class=\"headerlink\" title=\"从Event Loop谈JS的运行机制\"></a>从Event Loop谈JS的运行机制</h2><blockquote>\n<h3 id=\"javaScript引擎是单线程\"><a href=\"#javaScript引擎是单线程\" class=\"headerlink\" title=\"javaScript引擎是单线程\"></a><strong>javaScript引擎是单线程</strong></h3></blockquote>\n<ul>\n<li><p>我们都知道javaScript引擎是单线程，为什么不是多线程的呢？想下javaScript的主要作用是用户的互动和DOM的操作，假定javaScript有多个线程，一个线程在DOM节点上添加，同时另一个线程在这时删除这一个节点，这时浏览器应该以哪个线程为主呢？这就会导致很复杂的同步问题。</p>\n</li>\n<li><p>还有一个就是HTML5提出的Web Worker的标准，允许javaScript引擎创建多个子线程，利用多核cpu的计算能力，但是子线程是浏览器开的，完全由主线程控制，而且不能操作DOM，javaScript引擎线程与worker线程间是通过特定的方式通信的（postMessageAPI，需要通过序列化对象来与线程交互特定的数据）</p>\n</li>\n</ul>\n<p><strong>对于Web Worker MDN的官方解释是：</strong></p>\n<p> Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面，一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件，这个文件包含将在工作线程中运行的代码; workers运行在另一个全局上下文中,不同于当前的window。因此，使用window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误**</p>\n<ul>\n<li>所以针对大量计算问题非常耗时的工作时，请单独开一个Worker线程，不管这个线程里面发生什么样翻天覆地的变化都不会影响多javaScript主线程，只待计算结果出来之后，将结果通信给主线程，所以javaScript引擎是单线程的这一本质一点都没变（其实还有一个sharedWorker,这里就不做介绍了）</li>\n</ul>\n<blockquote>\n<h3 id=\"javaScript运行机制\"><a href=\"#javaScript运行机制\" class=\"headerlink\" title=\"javaScript运行机制\"></a><strong>javaScript运行机制</strong></h3></blockquote>\n<ul>\n<li>js执行任务分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务都在主线程中执行，形成一个执行栈，主线程之外还有一个任务队列（task queue），任务队列是<strong>事件触发线程</strong>管理的，只要异步任务有运行结果时，就会在任务队列中放置一个事件</li>\n<li>一旦执行栈中所有的同步任务执行完毕后，系统就才会去读取任务队列，将任务放入到执行栈中执行（<strong>任务队列是一个先进先出的数据结构</strong>）</li>\n</ul>\n<p>下图是主线程和任务队列的示意图（图片来自参考资料2中）<br><img src=\"/images/blog_images/js_event_loop.png\" alt=\"image\"></p>\n<p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复</p>\n<blockquote>\n<h3 id=\"事件循环机制\"><a href=\"#事件循环机制\" class=\"headerlink\" title=\"事件循环机制\"></a><strong>事件循环机制</strong></h3></blockquote>\n<p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href=\"https://vimeo.com/96425312\" target=\"_blank\" rel=\"noopener\">Help, I’m stuck in an event-loop</a>》，图片来自参考资料2中）<br><img src=\"/images/blog_images/js_event_loop2.png\" alt=\"image\"></p>\n<ul>\n<li><p>上述循环机制的核心是：<strong>js引擎线程</strong>和<strong>事件触发线程</strong></p>\n</li>\n<li><p>主线程运行时会产生执行栈，栈中的调用某些api时，当满足触发条件后，会将事件放入到事件队列中去</p>\n</li>\n<li><p>但是对于定时器（<strong>setTimeout和setInterval</strong>）来说它是通过<strong>定时器引擎线程</strong>来控制回调函数在等待特定的时间后添加到事件队列中</p>\n</li>\n</ul>\n<p>定时器要注意的一点就是设置的时间间隔：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(&apos;2&apos;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;1&apos;);</span><br><span class=\"line\">//执行结果是 先 “1” 后 “2”</span><br></pre></td></tr></table></figure>\n<p>虽然上述的代码中设置的时间间隔是0，但是根据W3C的HTML标准中的规定定时器最小的时间间隔不得低于4ms，低于4ms的间间隔算为4ms，即使是按0ms来，还是会先执行“1”，因为事件队列中任务总是要等到主线程执行完了之后才执行</p>\n<blockquote>\n<h3 id=\"setTimeOut和setInterval在事件循环机制中的区别\"><a href=\"#setTimeOut和setInterval在事件循环机制中的区别\" class=\"headerlink\" title=\"setTimeOut和setInterval在事件循环机制中的区别\"></a><strong>setTimeOut和setInterval在事件循环机制中的区别</strong></h3></blockquote>\n<ul>\n<li><p>主线程设置一个定时器后，setInterval在每个一段时间都会执行一个回调函数（回调函数就会被定时器引擎线程放入到事件队列中去），但是当主线程执行时间很长（时间大于好几个setInterval设置的时间间隔），那么事件队列中就会存在有好几个setInterval的回调函数，在主线程执行完后去执行事件队列中的事件，那么堆叠着的定时器回调函数就会连续执行（累计效应），setTimeOut没有这样的问题</p>\n</li>\n<li><p>还有一种情况就是把浏览器最小化后，setInterval并不是不执行程序，回调函数还是会被放到事件队列中去，但是不会被执行，当浏览器打开以后，这些回调函数就会被一起全部执行</p>\n</li>\n<li><p>所以最好的方法就是用setTimeOut来模拟setInterval，或者用requestAnimationFrame</p>\n</li>\n<li><p><strong>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。</strong></p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"事件循环进阶：macrotask与microtask\"><a href=\"#事件循环进阶：macrotask与microtask\" class=\"headerlink\" title=\"事件循环进阶：macrotask与microtask\"></a><strong>事件循环进阶：macrotask与microtask</strong></h3></blockquote>\n<ul>\n<li>上面讲的事件循环机制在es5中的情况是够用了，但是es6中就会遇到一些问题了</li>\n</ul>\n<p>如下题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&apos;setTimeout&apos;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function() &#123;</span><br><span class=\"line\">    console.log(&apos;promise1&apos;);</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&apos;promise2&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure>\n<p>他执行的正确顺序是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br></pre></td></tr></table></figure>\n<p>这个知识点自己接触的较少，参考<a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a><strong>参考资料：</strong></h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br><a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html</a></p>\n","categories":["javascript"],"tags":["jsִ执行机制 时间循环机制"]},{"title":"磨刀不误砍柴工","url":"http://yoursite.com/2018/08/15/hello-world/","content":"<p>本博客实际编写时间是2018-09-09，将以前记录在word中的笔记进行了整和，将其中重要的知识重新梳理写入博客，之后将在博客中记录的自己的成长过程</p>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"资源库收藏\"><a href=\"#资源库收藏\" class=\"headerlink\" title=\"资源库收藏\"></a>资源库收藏</h3><p><a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">阿里矢量图库</a><br><a href=\"https://icomoon.io\" target=\"_blank\" rel=\"noopener\">icomoon</a><br><a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">详细列出了哪些CSS属性在不同的渲染引擎中是否会触发重排或重绘</a></p>\n<p>关于网络性能 </p>\n<ol>\n<li>网络传输性能优化<br> 1.1.浏览器缓存<br> 1.2.资源打包压缩: JS压缩, HTML压缩, 提取公共资源, 提取css并压缩, 将webpack开发环境修改为生产环境, 在服务器上开启Gzip传输压缩(不要对图片文件进行Gzip压缩)<br> 1.3.图片资源优化<br> 1.3.1.不要在HTML里缩放图像<br> 1.3.2.使用雪碧图（CSS Sprite）<br> 1.3.3.使用字体图标（iconfont）<br> 1.3.4.使用WebP<br> 1.4.网络传输性能检测工具——Page Speed<br> 1.5.使用CDN<br>2.页面渲染性能优化<br> 2.1.浏览器渲染过程（Webkit）<br> 2.2.DOM渲染层与GPU硬件加速<br> 2.3.重排与重绘<br> 2.4.优化策略<br>3.JS阻塞性能</li>\n</ol>\n<ul>\n<li><a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></li>\n<li><a href=\"https://mp.weixin.qq.com/mp/homepage?__biz=MzI2NTQ5NTE4OA==&amp;hid=1&amp;sn=d38e63d4e863c39b3db1494e81e40c97&amp;scene=18&amp;uin=&amp;key=&amp;devicetype=Windows+10&amp;version=62060426&amp;lang=zh_CN&amp;ascene=7&amp;winzoom=1.125\" target=\"_blank\" rel=\"noopener\">域名解析、7层网络协议等访问During</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" target=\"_blank\" rel=\"noopener\">同源策略和cookie、iframe、localStorage跨域</a></li>\n<li><a href=\"https://juejin.im/post/5b8359f351882542ba1dcc31\" target=\"_blank\" rel=\"noopener\">postMessage实现跨域通信</a><!-- - 针对ajax跨域，除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。\n  - JSONP\n  - WebSocket\n  - CORS --></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">CORS是跨源资源分享</a></li>\n<li><a href=\"http://www.dailichun.com/2017/03/22/ajaxCrossDomainSolution.html\" target=\"_blank\" rel=\"noopener\">ajax跨域，这应该是最全的解决方案了</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"noopener\">webSocket</a></li>\n<li><p><a href=\"http://imweb.io/topic/56d67baaca5e865230c1d4fa\" target=\"_blank\" rel=\"noopener\">https</a></p>\n</li>\n<li><p><a href=\"http://imweb.io/topic/5b6fd3c13cb5a02f33c013bd\" target=\"_blank\" rel=\"noopener\">网站性能优化实战——从12.67s到1.06s的故事</a></p>\n</li>\n<li><a href=\"https://juejin.im/post/5abb40596fb9a028c42e3efe\" target=\"_blank\" rel=\"noopener\">webpack</a></li>\n<li><a href=\"http://imweb.io/topic/5baca58079ddc80f36592f1a\" target=\"_blank\" rel=\"noopener\">webpack原理</a></li>\n<li><p><a href=\"https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/\" target=\"_blank\" rel=\"noopener\">display: grid</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/xianyulaodi/p/5755079.html\" target=\"_blank\" rel=\"noopener\">雅虎军规</a></p>\n</li>\n<li><a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">强缓存和协商缓存</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015809379#articleHeader0\" target=\"_blank\" rel=\"noopener\">web缓存</a></li>\n<li><a href=\"http://hjingren.cn/2017/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/#%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">征服前端面试</a></li>\n<li><p><a href=\"https://segmentfault.com/a/1190000015597029#articleHeader7\" target=\"_blank\" rel=\"noopener\">跨域</a></p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/nav/\" target=\"_blank\" rel=\"noopener\">前端网站导航</a></p>\n</li>\n<li><p><a href=\"https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html\" target=\"_blank\" rel=\"noopener\">W3CPlus</a></p>\n</li>\n<li><a href=\"https://yq.aliyun.com/articles/293693\" target=\"_blank\" rel=\"noopener\">云栖社区</a></li>\n<li><a href=\"https://yq.aliyun.com/articles/293693\" target=\"_blank\" rel=\"noopener\">如何使用CSS3来获取屏幕宽度并且用来计算DIV高度</a></li>\n</ul>\n<ul>\n<li><a href=\"http://blog.leapoahead.com/2015/09/06/understanding-jwt/\" target=\"_blank\" rel=\"noopener\">关于token验证</a></li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener\">关于token验证</a></p>\n</li>\n<li><p><a href=\"https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-07-08-Device-Viewport-and-Pixel-Introduction.md\" target=\"_blank\" rel=\"noopener\">关于移动端的分辨率</a></p>\n</li>\n</ul>\n<ul>\n<li>博客<ul>\n<li><a href=\"http://blog.leapoahead.com/\" target=\"_blank\" rel=\"noopener\">http://blog.leapoahead.com/</a></li>\n<li><a href=\"https://blog.souche.com/tag/qian-duan-kai-fa/\" target=\"_blank\" rel=\"noopener\">大搜车团队</a></li>\n<li><a href=\"https://tech.youzan.com/tag/front-end/\" target=\"_blank\" rel=\"noopener\">有赞技术团队博客</a></li>\n<li><a href=\"http://fex.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度web前端研发部博客</a></li>\n<li><a href=\"https://fed.renren.com\" target=\"_blank\" rel=\"noopener\">人人网前端博客</a></li>\n<li><a href=\"https://tech.meituan.com/archives\" target=\"_blank\" rel=\"noopener\">美团技术团队</a></li>\n<li><a href=\"http://xiangzongliang.com/\" target=\"_blank\" rel=\"noopener\">http://xiangzongliang.com/</a></li>\n<li><a href=\"https://aerotwist.com/\" target=\"_blank\" rel=\"noopener\">https://aerotwist.com/</a></li>\n</ul>\n</li>\n<li><p>css学习网站</p>\n<ul>\n<li><a href=\"https://css-tricks.com/almanac/\" target=\"_blank\" rel=\"noopener\">https://css-tricks.com/almanac/</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2018/05/guide-css-layout/?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\" target=\"_blank\" rel=\"noopener\">https://www.smashingmagazine.com/2018/05/guide-css-layout/?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more</a><h3 id=\"推荐书籍\"><a href=\"#推荐书籍\" class=\"headerlink\" title=\"推荐书籍\"></a>推荐书籍</h3></li>\n</ul>\n</li>\n</ul>\n<p>《Webkit技术内幕》：有关浏览器内核的<br>《大型网站性能监测、分析与优化》<br>《css揭秘》<br>《你不知道的js上、中、下》<br>《高性能javascript》<br>《javascript权威指南》<br>《Javascript高级程序设计》<br>《javascript模式》</p>\n<h3 id=\"css属性\"><a href=\"#css属性\" class=\"headerlink\" title=\"css属性\"></a>css属性</h3><pre><code>outline\noutline-offset\nhyphens\n布局：\ndisplay:flex;\ndisplay:grid;\ndisplay:table/table-cell;\n</code></pre><p>IE9及以上兼容：calc<br>IE10及以上兼容：transform flex grid</p>\n<p>绝对定位：为了使一个固定定位的元素不相对于视口进行定位，你需要为容器元素设置transform、perspective、filter三个属性之一（不为默认值none）。这样固定的元素就会相对于该块级元素偏移，而非视口</p>\n<h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><pre><code>- 浏览器有哪些进程、进程\n- [HTML5 web worker](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)\n    - https://www.ibm.com/developerworks/cn/web/1112_sunch_webworker/\n</code></pre><h3 id=\"wepack\"><a href=\"#wepack\" class=\"headerlink\" title=\"wepack\"></a>wepack</h3><h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p><strong>针对于压缩文件来加快下载速度</strong></p>\n<pre><code>- 压缩html、css、js、图片的压缩，服务器开启gzip压缩整个文件集\n- Gzip在文本资源上表现最好，并且通常可以达到70%的压缩（对于大型文件甚至更高）。然而，压缩已经单独压缩的非文本资源（例如图像）通常不会显著减小大小。（协议对应Accept-Encoding: gzip, deflate，  Content-Encoding: gzip）\n- GZIP 是一种可以作用于任何字节流的通用压缩程序。它会在后台记忆一些之前看到的内容，并尝试以高效方式查找并替换重复的数据片段。（欲知详情，请参阅浅显易懂的 GZIP 低阶说明。）但实际上，GZIP 对基于文本的内容的压缩效果最好，在压缩较大文件时往往可实现高达 70-90% 的压缩率，而如果对已经通过替代算法压缩过的资产（例如，大多数图片格式）运行 GZIP，则效果甚微，甚至毫无效果。\n- 已经压缩的内容：大多数图像、音乐和视频已经被压缩。不要浪费时间再压缩它们。事实上，您可能只需要压缩“大3”（HTML、CSS和JavaScript）。\n- 不要按需加载您的javascript（这会导致明显的缺口），而是在延迟之后在后台加载您的脚本。使用类似的东西\n- 使用HTTP压缩优化您的站点（即gzip等）\n- 针对不同的大小的屏幕使用不同大小的图片\n</code></pre><p><strong>针对图片的优化</strong></p>\n<p><strong>针对用户呈现</strong></p>\n<pre><code>- 因为js文件会阻塞页面的加载所以通常把js文件放在标签最后，这允许浏览器加载和渲染页面内容，然后允许它在用户感知初始内容的同时下载脚本\n- 此技术的例外是任何在呈现之前或期间操纵初始内容或DOM或提供所需页面功能的脚本。像这样的关键脚本可以放入一个单独的文件中，并像往常一样加载到页面头部，其余的脚本仍然可以放在页面的最后一个位置，以便仅在呈现页面之后加载\n- 如果CSS文件适用于当前设备，则它们仅被视为渲染阻止。 &lt;link rel =“stylesheet”&gt;标签可以接受媒体属性，我们可以在其中指定适用于其中的样式的任何媒体查询。 例如，如果我们有一个样式表，其媒体属性为orientation：landscape，而我们正在以纵向模式查看页面，则该资源将不被视为渲染阻止。\n</code></pre><p><strong>减少http请求</strong></p>\n<pre><code>- 减少页面需要的组件数量相应地减少了它必须发出的HTTP请求的数量\n- 针对于较小的图片用精灵图将图片组合到一个图片中，使用css的background-position定位图片，减少http请求。然而在http2中\n- 然而，如上所述的物理组合文件可能不会在HTTP/2上获得期望的结果，这主要是因为服务器请求在HTTP/2上更快，所以组合文件以消除请求可能没有实质生产力此外，如果将相当静态的资源与相当动态的资源结合起来保存请求，则可能会通过强制重新加载资源的静态部分以获取动态部分而影响缓存效率。\n- 在这里，不是将关键脚本放在单独的文件中并在页头中引用它，而是在头部或正文中添加&lt;script&gt; ... &lt;/ script&gt;块，并插入脚本本身（不是一个文件引用，但实际的脚本代码）在它需要的时候。假设脚本不是太大，此方法会将脚本与HTML一起加载并立即执行，并避免将其放入页眉中的额外HTTP请求开销\n&lt;p&gt;Welcome back, &lt;script&gt;insertText(username)&lt;/script&gt;!&lt;/p&gt;\n</code></pre><p><strong>针对http缓存的性能优化</strong></p>\n<pre><code>- [How To Optimize Your Site With HTTP Caching](https://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/)\n- [How To Optimize Your Site With GZIP Compression](https://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/)\n- [How To Debug Web Applications With Firefox](https://betterexplained.com/articles/how-to-debug-web-applications-with-firefox/)\n- [Speed Up Your Javascript Load Time](https://betterexplained.com/articles/speed-up-your-javascript-load-time/)\n- [Speed Up Your Javascript, Part 2: Downloadable Examples!](https://betterexplained.com/articles/optimized-javascript-example/)\n- [Ajax patterns: Performance Optimization](http://ajaxpatterns.org/Patterns#Performance_Optimisation)\n- [Think vitamin: Serving Javascript Fast](http://www.thinkvitamin.com/features/webapps/serving-javascript-fast)\n- [Detailed post on page load time](https://www.die.net/musings/page_load_time/)\n- [Detailed Caching Tutorial](https://www.mnot.net/cache_docs/) and [online tool to check your cacheability](http://www.ircache.net/cgi-bin/cacheability.py)\n</code></pre><!-- \n- 同源策略就是协议域名端口都要相等的才可以相互访问，这是浏览器规定的，\n\n    不同源之间不能访问dom，比如一个网页中嵌入一个iframe\n\n    不同源之间，cookie、LocalStorage 和 sessionStorage、IndexDB 无法读取。\n\n    不同源之间，不能发送ajax\n\n- 为什么要设置同月策略呢？\n\n    - 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。比如cookie是一般用来保存登录信息的，没有了同源策略，那么cookie就可以被其他的网站所获取，cookie就相当于共享了\n\n- 如果要打破同源策略的限制，即进行跨域，有如下方法：\n\n    - 对于cookie，只有同源策略下才能共享，在两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie，比如wangpan.baidu.com和zhidao.baidu.com，注意document.domain只适用于cookie和iframe窗口，LocalStorage 和 sessionStorage 和 IndexDB 无法通过这种方法，规避同源政策略，另外服务器在设置cookie的时候可以设置cookie的域名比如（Set-Cookie: key=value; domain=.example.com; path=/），设置在了一级域名，那么二级域名和三级域名可以不做任何设置就可以访问到这个cookie\n\n- 有点要注意就是一般我们的url地址中是没有端口显示的，其实它就是默认端口（http是80，https是443） -->","categories":["javascript"],"tags":["html"]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]